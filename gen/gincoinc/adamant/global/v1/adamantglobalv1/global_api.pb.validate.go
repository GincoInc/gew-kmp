// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: gincoinc/adamant/global/v1/adamantglobalv1/global_api.proto

package adamantglobalv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	gincoincglobalv1 "github.com/GincoInc/gew-kmp/gen/gincoinc/global/v1/gincoincglobalv1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.AddressType(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.TransferType(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.TransferType(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)
)

// Validate checks the field values on ApproveWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ApproveWalletRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ApproveWalletRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ApproveWalletRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ApproveWalletRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApproveWalletRequestMultiError(errors)
	}
	return nil
}

// ApproveWalletRequestMultiError is an error wrapping multiple validation
// errors returned by ApproveWalletRequest.Validate(true) if the designated
// constraints aren't met.
type ApproveWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApproveWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApproveWalletRequestMultiError) AllErrors() []error { return m }

// ApproveWalletRequestValidationError is the validation error returned by
// ApproveWalletRequest.Validate if the designated constraints aren't met.
type ApproveWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApproveWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApproveWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApproveWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApproveWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApproveWalletRequestValidationError) ErrorName() string {
	return "ApproveWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ApproveWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApproveWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApproveWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApproveWalletRequestValidationError{}

var _ApproveWalletRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ApproveTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ApproveTransactionRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ApproveTransactionRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ApproveTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ApproveTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ApproveTransactionRequest_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := ApproveTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ApproveTransactionRequestMultiError(errors)
	}
	return nil
}

// ApproveTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by ApproveTransactionRequest.Validate(true) if the
// designated constraints aren't met.
type ApproveTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ApproveTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ApproveTransactionRequestMultiError) AllErrors() []error { return m }

// ApproveTransactionRequestValidationError is the validation error returned by
// ApproveTransactionRequest.Validate if the designated constraints aren't met.
type ApproveTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ApproveTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ApproveTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ApproveTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ApproveTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ApproveTransactionRequestValidationError) ErrorName() string {
	return "ApproveTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ApproveTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sApproveTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ApproveTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ApproveTransactionRequestValidationError{}

var _ApproveTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ApproveTransactionRequest_TransactionId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on CreateWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateWalletRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CreateWalletRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetWalletName()); l < 1 || l > 40 {
		err := CreateWalletRequestValidationError{
			field:  "WalletName",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateWalletRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := CreateWalletRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := CreateWalletRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateWalletRequest_WalletType_NotInLookup[m.GetWalletType()]; ok {
		err := CreateWalletRequestValidationError{
			field:  "WalletType",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := WalletType_name[int32(m.GetWalletType())]; !ok {
		err := CreateWalletRequestValidationError{
			field:  "WalletType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateWalletRequest_AddressType_NotInLookup[m.GetAddressType()]; ok {
		err := CreateWalletRequestValidationError{
			field:  "AddressType",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.AddressType_name[int32(m.GetAddressType())]; !ok {
		err := CreateWalletRequestValidationError{
			field:  "AddressType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetM(); val < 1 || val > 5 {
		err := CreateWalletRequestValidationError{
			field:  "M",
			reason: "value must be inside range [1, 5]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if val := m.GetN(); val < 1 || val > 5 {
		err := CreateWalletRequestValidationError{
			field:  "N",
			reason: "value must be inside range [1, 5]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetMembers()) < 1 {
		err := CreateWalletRequestValidationError{
			field:  "Members",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_CreateWalletRequest_Members_Unique := make(map[string]struct{}, len(m.GetMembers()))

	for idx, item := range m.GetMembers() {
		_, _ = idx, item

		if _, exists := _CreateWalletRequest_Members_Unique[item]; exists {
			err := CreateWalletRequestValidationError{
				field:  fmt.Sprintf("Members[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_CreateWalletRequest_Members_Unique[item] = struct{}{}
		}

		// no validation rules for Members[idx]
	}

	// no validation rules for RequiredApprovalCount

	if !_CreateWalletRequest_PolicyId_Pattern.MatchString(m.GetPolicyId()) {
		err := CreateWalletRequestValidationError{
			field:  "PolicyId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateWalletRequest_DestinationWalletId_Pattern.MatchString(m.GetDestinationWalletId()) {
		err := CreateWalletRequestValidationError{
			field:  "DestinationWalletId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for WatchOnly

	if !_CreateWalletRequest_InheritWalletId_Pattern.MatchString(m.GetInheritWalletId()) {
		err := CreateWalletRequestValidationError{
			field:  "InheritWalletId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateWalletRequestMultiError(errors)
	}
	return nil
}

// CreateWalletRequestMultiError is an error wrapping multiple validation
// errors returned by CreateWalletRequest.Validate(true) if the designated
// constraints aren't met.
type CreateWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWalletRequestMultiError) AllErrors() []error { return m }

// CreateWalletRequestValidationError is the validation error returned by
// CreateWalletRequest.Validate if the designated constraints aren't met.
type CreateWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWalletRequestValidationError) ErrorName() string {
	return "CreateWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWalletRequestValidationError{}

var _CreateWalletRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

var _CreateWalletRequest_WalletType_NotInLookup = map[WalletType]struct{}{
	0: {},
}

var _CreateWalletRequest_AddressType_NotInLookup = map[gincoincglobalv1.AddressType]struct{}{
	0: {},
}

var _CreateWalletRequest_PolicyId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _CreateWalletRequest_DestinationWalletId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _CreateWalletRequest_InheritWalletId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on CreateWalletResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateWalletResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CreateWalletResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	if len(errors) > 0 {
		return CreateWalletResponseMultiError(errors)
	}
	return nil
}

// CreateWalletResponseMultiError is an error wrapping multiple validation
// errors returned by CreateWalletResponse.Validate(true) if the designated
// constraints aren't met.
type CreateWalletResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWalletResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWalletResponseMultiError) AllErrors() []error { return m }

// CreateWalletResponseValidationError is the validation error returned by
// CreateWalletResponse.Validate if the designated constraints aren't met.
type CreateWalletResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWalletResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWalletResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWalletResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWalletResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWalletResponseValidationError) ErrorName() string {
	return "CreateWalletResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWalletResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWalletResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWalletResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWalletResponseValidationError{}

// Validate checks the field values on GetWalletRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in GetWalletRequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *GetWalletRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetWalletRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := GetWalletRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetWalletRequestMultiError(errors)
	}
	return nil
}

// GetWalletRequestMultiError is an error wrapping multiple validation errors
// returned by GetWalletRequest.Validate(true) if the designated constraints
// aren't met.
type GetWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletRequestMultiError) AllErrors() []error { return m }

// GetWalletRequestValidationError is the validation error returned by
// GetWalletRequest.Validate if the designated constraints aren't met.
type GetWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletRequestValidationError) ErrorName() string { return "GetWalletRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletRequestValidationError{}

var _GetWalletRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on BatchGetWalletsWithoutBalanceRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in BatchGetWalletsWithoutBalanceRequestMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *BatchGetWalletsWithoutBalanceRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return BatchGetWalletsWithoutBalanceRequestMultiError(errors)
	}
	return nil
}

// BatchGetWalletsWithoutBalanceRequestMultiError is an error wrapping multiple
// validation errors returned by
// BatchGetWalletsWithoutBalanceRequest.Validate(true) if the designated
// constraints aren't met.
type BatchGetWalletsWithoutBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetWalletsWithoutBalanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetWalletsWithoutBalanceRequestMultiError) AllErrors() []error { return m }

// BatchGetWalletsWithoutBalanceRequestValidationError is the validation error
// returned by BatchGetWalletsWithoutBalanceRequest.Validate if the designated
// constraints aren't met.
type BatchGetWalletsWithoutBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetWalletsWithoutBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetWalletsWithoutBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetWalletsWithoutBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetWalletsWithoutBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetWalletsWithoutBalanceRequestValidationError) ErrorName() string {
	return "BatchGetWalletsWithoutBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetWalletsWithoutBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetWalletsWithoutBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetWalletsWithoutBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetWalletsWithoutBalanceRequestValidationError{}

// Validate checks the field values on BatchGetWalletsWithoutBalanceResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in
// BatchGetWalletsWithoutBalanceResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *BatchGetWalletsWithoutBalanceResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWallets() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = BatchGetWalletsWithoutBalanceResponseValidationError{
					field:  fmt.Sprintf("Wallets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return BatchGetWalletsWithoutBalanceResponseMultiError(errors)
	}
	return nil
}

// BatchGetWalletsWithoutBalanceResponseMultiError is an error wrapping
// multiple validation errors returned by
// BatchGetWalletsWithoutBalanceResponse.Validate(true) if the designated
// constraints aren't met.
type BatchGetWalletsWithoutBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BatchGetWalletsWithoutBalanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BatchGetWalletsWithoutBalanceResponseMultiError) AllErrors() []error { return m }

// BatchGetWalletsWithoutBalanceResponseValidationError is the validation error
// returned by BatchGetWalletsWithoutBalanceResponse.Validate if the
// designated constraints aren't met.
type BatchGetWalletsWithoutBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BatchGetWalletsWithoutBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BatchGetWalletsWithoutBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BatchGetWalletsWithoutBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BatchGetWalletsWithoutBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BatchGetWalletsWithoutBalanceResponseValidationError) ErrorName() string {
	return "BatchGetWalletsWithoutBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e BatchGetWalletsWithoutBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBatchGetWalletsWithoutBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BatchGetWalletsWithoutBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BatchGetWalletsWithoutBalanceResponseValidationError{}

// Validate checks the field values on CancelWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CancelWalletRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CancelWalletRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CancelWalletRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := CancelWalletRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CancelWalletRequestMultiError(errors)
	}
	return nil
}

// CancelWalletRequestMultiError is an error wrapping multiple validation
// errors returned by CancelWalletRequest.Validate(true) if the designated
// constraints aren't met.
type CancelWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelWalletRequestMultiError) AllErrors() []error { return m }

// CancelWalletRequestValidationError is the validation error returned by
// CancelWalletRequest.Validate if the designated constraints aren't met.
type CancelWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelWalletRequestValidationError) ErrorName() string {
	return "CancelWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CancelWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelWalletRequestValidationError{}

var _CancelWalletRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ArchiveWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ArchiveWalletRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ArchiveWalletRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ArchiveWalletRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ArchiveWalletRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ArchiveWalletRequestMultiError(errors)
	}
	return nil
}

// ArchiveWalletRequestMultiError is an error wrapping multiple validation
// errors returned by ArchiveWalletRequest.Validate(true) if the designated
// constraints aren't met.
type ArchiveWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArchiveWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArchiveWalletRequestMultiError) AllErrors() []error { return m }

// ArchiveWalletRequestValidationError is the validation error returned by
// ArchiveWalletRequest.Validate if the designated constraints aren't met.
type ArchiveWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArchiveWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArchiveWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArchiveWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArchiveWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArchiveWalletRequestValidationError) ErrorName() string {
	return "ArchiveWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ArchiveWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArchiveWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArchiveWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArchiveWalletRequestValidationError{}

var _ArchiveWalletRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on UnArchiveWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UnArchiveWalletRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UnArchiveWalletRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UnArchiveWalletRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := UnArchiveWalletRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UnArchiveWalletRequestMultiError(errors)
	}
	return nil
}

// UnArchiveWalletRequestMultiError is an error wrapping multiple validation
// errors returned by UnArchiveWalletRequest.Validate(true) if the designated
// constraints aren't met.
type UnArchiveWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UnArchiveWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UnArchiveWalletRequestMultiError) AllErrors() []error { return m }

// UnArchiveWalletRequestValidationError is the validation error returned by
// UnArchiveWalletRequest.Validate if the designated constraints aren't met.
type UnArchiveWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UnArchiveWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UnArchiveWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UnArchiveWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UnArchiveWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UnArchiveWalletRequestValidationError) ErrorName() string {
	return "UnArchiveWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UnArchiveWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUnArchiveWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UnArchiveWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UnArchiveWalletRequestValidationError{}

var _UnArchiveWalletRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListWalletsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListWalletsRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListWalletsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.GetPageSize() > 100 {
		err := ListWalletsRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 100",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListWalletsRequest_PageToken_Pattern.MatchString(m.GetPageToken()) {
		err := ListWalletsRequestValidationError{
			field:  "PageToken",
			reason: "value does not match regex pattern \"^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListWalletsRequestMultiError(errors)
	}
	return nil
}

// ListWalletsRequestMultiError is an error wrapping multiple validation errors
// returned by ListWalletsRequest.Validate(true) if the designated constraints
// aren't met.
type ListWalletsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletsRequestMultiError) AllErrors() []error { return m }

// ListWalletsRequestValidationError is the validation error returned by
// ListWalletsRequest.Validate if the designated constraints aren't met.
type ListWalletsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletsRequestValidationError) ErrorName() string {
	return "ListWalletsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletsRequestValidationError{}

var _ListWalletsRequest_PageToken_Pattern = regexp.MustCompile("^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$")

// Validate checks the field values on ListWalletsByFilterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListWalletsByFilterRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListWalletsByFilterRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _ListWalletsByFilterRequest_FilterType_NotInLookup[m.GetFilterType()]; ok {
		err := ListWalletsByFilterRequestValidationError{
			field:  "FilterType",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := ListFilterType_name[int32(m.GetFilterType())]; !ok {
		err := ListWalletsByFilterRequestValidationError{
			field:  "FilterType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for WalletId

	if utf8.RuneCountInString(m.GetWalletName()) > 40 {
		err := ListWalletsByFilterRequestValidationError{
			field:  "WalletName",
			reason: "value length must be at most 40 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Address

	// no validation rules for WatchOnly

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := ListWalletsByFilterRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() > 100 {
		err := ListWalletsByFilterRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 100",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListWalletsByFilterRequest_PageToken_Pattern.MatchString(m.GetPageToken()) {
		err := ListWalletsByFilterRequestValidationError{
			field:  "PageToken",
			reason: "value does not match regex pattern \"^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListWalletsByFilterRequestMultiError(errors)
	}
	return nil
}

// ListWalletsByFilterRequestMultiError is an error wrapping multiple
// validation errors returned by ListWalletsByFilterRequest.Validate(true) if
// the designated constraints aren't met.
type ListWalletsByFilterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletsByFilterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletsByFilterRequestMultiError) AllErrors() []error { return m }

// ListWalletsByFilterRequestValidationError is the validation error returned
// by ListWalletsByFilterRequest.Validate if the designated constraints aren't met.
type ListWalletsByFilterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletsByFilterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletsByFilterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletsByFilterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletsByFilterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletsByFilterRequestValidationError) ErrorName() string {
	return "ListWalletsByFilterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletsByFilterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletsByFilterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletsByFilterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletsByFilterRequestValidationError{}

var _ListWalletsByFilterRequest_FilterType_NotInLookup = map[ListFilterType]struct{}{
	0: {},
}

var _ListWalletsByFilterRequest_PageToken_Pattern = regexp.MustCompile("^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$")

// Validate checks the field values on ListWalletsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListWalletsResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListWalletsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWallets() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListWalletsResponseValidationError{
					field:  fmt.Sprintf("Wallets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListWalletsResponseMultiError(errors)
	}
	return nil
}

// ListWalletsResponseMultiError is an error wrapping multiple validation
// errors returned by ListWalletsResponse.Validate(true) if the designated
// constraints aren't met.
type ListWalletsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletsResponseMultiError) AllErrors() []error { return m }

// ListWalletsResponseValidationError is the validation error returned by
// ListWalletsResponse.Validate if the designated constraints aren't met.
type ListWalletsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletsResponseValidationError) ErrorName() string {
	return "ListWalletsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletsResponseValidationError{}

// Validate checks the field values on ListBaseWalletsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListBaseWalletsRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListBaseWalletsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListBaseWalletsRequestMultiError(errors)
	}
	return nil
}

// ListBaseWalletsRequestMultiError is an error wrapping multiple validation
// errors returned by ListBaseWalletsRequest.Validate(true) if the designated
// constraints aren't met.
type ListBaseWalletsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBaseWalletsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBaseWalletsRequestMultiError) AllErrors() []error { return m }

// ListBaseWalletsRequestValidationError is the validation error returned by
// ListBaseWalletsRequest.Validate if the designated constraints aren't met.
type ListBaseWalletsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBaseWalletsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBaseWalletsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBaseWalletsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBaseWalletsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBaseWalletsRequestValidationError) ErrorName() string {
	return "ListBaseWalletsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListBaseWalletsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBaseWalletsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBaseWalletsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBaseWalletsRequestValidationError{}

// Validate checks the field values on ListBaseWalletsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListBaseWalletsResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListBaseWalletsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWallets() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListBaseWalletsResponseValidationError{
					field:  fmt.Sprintf("Wallets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListBaseWalletsResponseMultiError(errors)
	}
	return nil
}

// ListBaseWalletsResponseMultiError is an error wrapping multiple validation
// errors returned by ListBaseWalletsResponse.Validate(true) if the designated
// constraints aren't met.
type ListBaseWalletsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBaseWalletsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBaseWalletsResponseMultiError) AllErrors() []error { return m }

// ListBaseWalletsResponseValidationError is the validation error returned by
// ListBaseWalletsResponse.Validate if the designated constraints aren't met.
type ListBaseWalletsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBaseWalletsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBaseWalletsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBaseWalletsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBaseWalletsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBaseWalletsResponseValidationError) ErrorName() string {
	return "ListBaseWalletsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListBaseWalletsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBaseWalletsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBaseWalletsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBaseWalletsResponseValidationError{}

// Validate checks the field values on UpdateWalletNameRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateWalletNameRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UpdateWalletNameRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateWalletNameRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := UpdateWalletNameRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := UpdateWalletNameRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateWalletNameRequestMultiError(errors)
	}
	return nil
}

// UpdateWalletNameRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateWalletNameRequest.Validate(true) if the designated
// constraints aren't met.
type UpdateWalletNameRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWalletNameRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWalletNameRequestMultiError) AllErrors() []error { return m }

// UpdateWalletNameRequestValidationError is the validation error returned by
// UpdateWalletNameRequest.Validate if the designated constraints aren't met.
type UpdateWalletNameRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWalletNameRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWalletNameRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWalletNameRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWalletNameRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWalletNameRequestValidationError) ErrorName() string {
	return "UpdateWalletNameRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWalletNameRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWalletNameRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWalletNameRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWalletNameRequestValidationError{}

var _UpdateWalletNameRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on UpdateWalletValidationRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateWalletValidationRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UpdateWalletValidationRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateWalletValidationRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := UpdateWalletValidationRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetNewValidatorIds() {
		_, _ = idx, item

		if !_UpdateWalletValidationRequest_NewValidatorIds_Pattern.MatchString(item) {
			err := UpdateWalletValidationRequestValidationError{
				field:  fmt.Sprintf("NewValidatorIds[%v]", idx),
				reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	// no validation rules for NewRequiredApprovalCount

	if len(errors) > 0 {
		return UpdateWalletValidationRequestMultiError(errors)
	}
	return nil
}

// UpdateWalletValidationRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateWalletValidationRequest.Validate(true)
// if the designated constraints aren't met.
type UpdateWalletValidationRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWalletValidationRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWalletValidationRequestMultiError) AllErrors() []error { return m }

// UpdateWalletValidationRequestValidationError is the validation error
// returned by UpdateWalletValidationRequest.Validate if the designated
// constraints aren't met.
type UpdateWalletValidationRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWalletValidationRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWalletValidationRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWalletValidationRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWalletValidationRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWalletValidationRequestValidationError) ErrorName() string {
	return "UpdateWalletValidationRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWalletValidationRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWalletValidationRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWalletValidationRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWalletValidationRequestValidationError{}

var _UpdateWalletValidationRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _UpdateWalletValidationRequest_NewValidatorIds_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on UpdateWalletPolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateWalletPolicyRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UpdateWalletPolicyRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateWalletPolicyRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := UpdateWalletPolicyRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateWalletPolicyRequest_PolicyId_Pattern.MatchString(m.GetPolicyId()) {
		err := UpdateWalletPolicyRequestValidationError{
			field:  "PolicyId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateWalletPolicyRequestMultiError(errors)
	}
	return nil
}

// UpdateWalletPolicyRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateWalletPolicyRequest.Validate(true) if the
// designated constraints aren't met.
type UpdateWalletPolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWalletPolicyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWalletPolicyRequestMultiError) AllErrors() []error { return m }

// UpdateWalletPolicyRequestValidationError is the validation error returned by
// UpdateWalletPolicyRequest.Validate if the designated constraints aren't met.
type UpdateWalletPolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWalletPolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWalletPolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWalletPolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWalletPolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWalletPolicyRequestValidationError) ErrorName() string {
	return "UpdateWalletPolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWalletPolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWalletPolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWalletPolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWalletPolicyRequestValidationError{}

var _UpdateWalletPolicyRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _UpdateWalletPolicyRequest_PolicyId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ReviewWalletProposalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ReviewWalletProposalRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ReviewWalletProposalRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ReviewWalletProposalRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ReviewWalletProposalRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Approve

	if len(errors) > 0 {
		return ReviewWalletProposalRequestMultiError(errors)
	}
	return nil
}

// ReviewWalletProposalRequestMultiError is an error wrapping multiple
// validation errors returned by ReviewWalletProposalRequest.Validate(true) if
// the designated constraints aren't met.
type ReviewWalletProposalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReviewWalletProposalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReviewWalletProposalRequestMultiError) AllErrors() []error { return m }

// ReviewWalletProposalRequestValidationError is the validation error returned
// by ReviewWalletProposalRequest.Validate if the designated constraints
// aren't met.
type ReviewWalletProposalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReviewWalletProposalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReviewWalletProposalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReviewWalletProposalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReviewWalletProposalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReviewWalletProposalRequestValidationError) ErrorName() string {
	return "ReviewWalletProposalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReviewWalletProposalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReviewWalletProposalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReviewWalletProposalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReviewWalletProposalRequestValidationError{}

var _ReviewWalletProposalRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ExistsWalletByNameRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ExistsWalletByNameRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ExistsWalletByNameRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return ExistsWalletByNameRequestMultiError(errors)
	}
	return nil
}

// ExistsWalletByNameRequestMultiError is an error wrapping multiple validation
// errors returned by ExistsWalletByNameRequest.Validate(true) if the
// designated constraints aren't met.
type ExistsWalletByNameRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistsWalletByNameRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistsWalletByNameRequestMultiError) AllErrors() []error { return m }

// ExistsWalletByNameRequestValidationError is the validation error returned by
// ExistsWalletByNameRequest.Validate if the designated constraints aren't met.
type ExistsWalletByNameRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistsWalletByNameRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistsWalletByNameRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistsWalletByNameRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistsWalletByNameRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistsWalletByNameRequestValidationError) ErrorName() string {
	return "ExistsWalletByNameRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExistsWalletByNameRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistsWalletByNameRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistsWalletByNameRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistsWalletByNameRequestValidationError{}

// Validate checks the field values on ExistsWalletByNameResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ExistsWalletByNameResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ExistsWalletByNameResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Exists

	if len(errors) > 0 {
		return ExistsWalletByNameResponseMultiError(errors)
	}
	return nil
}

// ExistsWalletByNameResponseMultiError is an error wrapping multiple
// validation errors returned by ExistsWalletByNameResponse.Validate(true) if
// the designated constraints aren't met.
type ExistsWalletByNameResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistsWalletByNameResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistsWalletByNameResponseMultiError) AllErrors() []error { return m }

// ExistsWalletByNameResponseValidationError is the validation error returned
// by ExistsWalletByNameResponse.Validate if the designated constraints aren't met.
type ExistsWalletByNameResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistsWalletByNameResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistsWalletByNameResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistsWalletByNameResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistsWalletByNameResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistsWalletByNameResponseValidationError) ErrorName() string {
	return "ExistsWalletByNameResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExistsWalletByNameResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistsWalletByNameResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistsWalletByNameResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistsWalletByNameResponseValidationError{}

// Validate checks the field values on ExistsWalletGroupByNameRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ExistsWalletGroupByNameRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ExistsWalletGroupByNameRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Name

	if len(errors) > 0 {
		return ExistsWalletGroupByNameRequestMultiError(errors)
	}
	return nil
}

// ExistsWalletGroupByNameRequestMultiError is an error wrapping multiple
// validation errors returned by ExistsWalletGroupByNameRequest.Validate(true)
// if the designated constraints aren't met.
type ExistsWalletGroupByNameRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistsWalletGroupByNameRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistsWalletGroupByNameRequestMultiError) AllErrors() []error { return m }

// ExistsWalletGroupByNameRequestValidationError is the validation error
// returned by ExistsWalletGroupByNameRequest.Validate if the designated
// constraints aren't met.
type ExistsWalletGroupByNameRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistsWalletGroupByNameRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistsWalletGroupByNameRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistsWalletGroupByNameRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistsWalletGroupByNameRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistsWalletGroupByNameRequestValidationError) ErrorName() string {
	return "ExistsWalletGroupByNameRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExistsWalletGroupByNameRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistsWalletGroupByNameRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistsWalletGroupByNameRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistsWalletGroupByNameRequestValidationError{}

// Validate checks the field values on ExistsWalletGroupByNameResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ExistsWalletGroupByNameResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ExistsWalletGroupByNameResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Exists

	if len(errors) > 0 {
		return ExistsWalletGroupByNameResponseMultiError(errors)
	}
	return nil
}

// ExistsWalletGroupByNameResponseMultiError is an error wrapping multiple
// validation errors returned by
// ExistsWalletGroupByNameResponse.Validate(true) if the designated
// constraints aren't met.
type ExistsWalletGroupByNameResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistsWalletGroupByNameResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistsWalletGroupByNameResponseMultiError) AllErrors() []error { return m }

// ExistsWalletGroupByNameResponseValidationError is the validation error
// returned by ExistsWalletGroupByNameResponse.Validate if the designated
// constraints aren't met.
type ExistsWalletGroupByNameResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistsWalletGroupByNameResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistsWalletGroupByNameResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistsWalletGroupByNameResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistsWalletGroupByNameResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistsWalletGroupByNameResponseValidationError) ErrorName() string {
	return "ExistsWalletGroupByNameResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExistsWalletGroupByNameResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistsWalletGroupByNameResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistsWalletGroupByNameResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistsWalletGroupByNameResponseValidationError{}

// Validate checks the field values on FlushBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in FlushBalanceRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *FlushBalanceRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_FlushBalanceRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := FlushBalanceRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return FlushBalanceRequestMultiError(errors)
	}
	return nil
}

// FlushBalanceRequestMultiError is an error wrapping multiple validation
// errors returned by FlushBalanceRequest.Validate(true) if the designated
// constraints aren't met.
type FlushBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlushBalanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlushBalanceRequestMultiError) AllErrors() []error { return m }

// FlushBalanceRequestValidationError is the validation error returned by
// FlushBalanceRequest.Validate if the designated constraints aren't met.
type FlushBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlushBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlushBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlushBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlushBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlushBalanceRequestValidationError) ErrorName() string {
	return "FlushBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e FlushBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlushBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlushBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlushBalanceRequestValidationError{}

var _FlushBalanceRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on FlushBalanceResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in FlushBalanceResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *FlushBalanceResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFlushedAddresses() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = FlushBalanceResponseValidationError{
					field:  fmt.Sprintf("FlushedAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return FlushBalanceResponseMultiError(errors)
	}
	return nil
}

// FlushBalanceResponseMultiError is an error wrapping multiple validation
// errors returned by FlushBalanceResponse.Validate(true) if the designated
// constraints aren't met.
type FlushBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlushBalanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlushBalanceResponseMultiError) AllErrors() []error { return m }

// FlushBalanceResponseValidationError is the validation error returned by
// FlushBalanceResponse.Validate if the designated constraints aren't met.
type FlushBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlushBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlushBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlushBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlushBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlushBalanceResponseValidationError) ErrorName() string {
	return "FlushBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e FlushBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlushBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlushBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlushBalanceResponseValidationError{}

// Validate checks the field values on ListWalletFlushSettingsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListWalletFlushSettingsResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListWalletFlushSettingsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWalletFlushSettings() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListWalletFlushSettingsResponseValidationError{
					field:  fmt.Sprintf("WalletFlushSettings[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListWalletFlushSettingsResponseMultiError(errors)
	}
	return nil
}

// ListWalletFlushSettingsResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListWalletFlushSettingsResponse.Validate(true) if the designated
// constraints aren't met.
type ListWalletFlushSettingsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletFlushSettingsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletFlushSettingsResponseMultiError) AllErrors() []error { return m }

// ListWalletFlushSettingsResponseValidationError is the validation error
// returned by ListWalletFlushSettingsResponse.Validate if the designated
// constraints aren't met.
type ListWalletFlushSettingsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletFlushSettingsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletFlushSettingsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletFlushSettingsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletFlushSettingsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletFlushSettingsResponseValidationError) ErrorName() string {
	return "ListWalletFlushSettingsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletFlushSettingsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletFlushSettingsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletFlushSettingsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletFlushSettingsResponseValidationError{}

// Validate checks the field values on UpdateWalletFlushSettingRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateWalletFlushSettingRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UpdateWalletFlushSettingRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _UpdateWalletFlushSettingRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := UpdateWalletFlushSettingRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := UpdateWalletFlushSettingRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateWalletFlushSettingRequest_DestinationWalletId_Pattern.MatchString(m.GetDestinationWalletId()) {
		err := UpdateWalletFlushSettingRequestValidationError{
			field:  "DestinationWalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateWalletFlushSettingRequestMultiError(errors)
	}
	return nil
}

// UpdateWalletFlushSettingRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateWalletFlushSettingRequest.Validate(true) if the designated
// constraints aren't met.
type UpdateWalletFlushSettingRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWalletFlushSettingRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWalletFlushSettingRequestMultiError) AllErrors() []error { return m }

// UpdateWalletFlushSettingRequestValidationError is the validation error
// returned by UpdateWalletFlushSettingRequest.Validate if the designated
// constraints aren't met.
type UpdateWalletFlushSettingRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWalletFlushSettingRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWalletFlushSettingRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWalletFlushSettingRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWalletFlushSettingRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWalletFlushSettingRequestValidationError) ErrorName() string {
	return "UpdateWalletFlushSettingRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWalletFlushSettingRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWalletFlushSettingRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWalletFlushSettingRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWalletFlushSettingRequestValidationError{}

var _UpdateWalletFlushSettingRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

var _UpdateWalletFlushSettingRequest_DestinationWalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListCompensationFeeHistoriesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListCompensationFeeHistoriesRequestMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListCompensationFeeHistoriesRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListCompensationFeeHistoriesRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ListCompensationFeeHistoriesRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAddress()) < 25 {
		err := ListCompensationFeeHistoriesRequestValidationError{
			field:  "Address",
			reason: "value length must be at least 25 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListCompensationFeeHistoriesRequestMultiError(errors)
	}
	return nil
}

// ListCompensationFeeHistoriesRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListCompensationFeeHistoriesRequest.Validate(true) if the designated
// constraints aren't met.
type ListCompensationFeeHistoriesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCompensationFeeHistoriesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCompensationFeeHistoriesRequestMultiError) AllErrors() []error { return m }

// ListCompensationFeeHistoriesRequestValidationError is the validation error
// returned by ListCompensationFeeHistoriesRequest.Validate if the designated
// constraints aren't met.
type ListCompensationFeeHistoriesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCompensationFeeHistoriesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCompensationFeeHistoriesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCompensationFeeHistoriesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCompensationFeeHistoriesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCompensationFeeHistoriesRequestValidationError) ErrorName() string {
	return "ListCompensationFeeHistoriesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCompensationFeeHistoriesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCompensationFeeHistoriesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCompensationFeeHistoriesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCompensationFeeHistoriesRequestValidationError{}

var _ListCompensationFeeHistoriesRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListCompensationFeeHistoriesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListCompensationFeeHistoriesResponseMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListCompensationFeeHistoriesResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCompensationFees() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListCompensationFeeHistoriesResponseValidationError{
					field:  fmt.Sprintf("CompensationFees[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListCompensationFeeHistoriesResponseMultiError(errors)
	}
	return nil
}

// ListCompensationFeeHistoriesResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListCompensationFeeHistoriesResponse.Validate(true) if the designated
// constraints aren't met.
type ListCompensationFeeHistoriesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCompensationFeeHistoriesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCompensationFeeHistoriesResponseMultiError) AllErrors() []error { return m }

// ListCompensationFeeHistoriesResponseValidationError is the validation error
// returned by ListCompensationFeeHistoriesResponse.Validate if the designated
// constraints aren't met.
type ListCompensationFeeHistoriesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCompensationFeeHistoriesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCompensationFeeHistoriesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCompensationFeeHistoriesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCompensationFeeHistoriesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCompensationFeeHistoriesResponseValidationError) ErrorName() string {
	return "ListCompensationFeeHistoriesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCompensationFeeHistoriesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCompensationFeeHistoriesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCompensationFeeHistoriesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCompensationFeeHistoriesResponseValidationError{}

// Validate checks the field values on ListUTXOsRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in ListUTXOsRequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *ListUTXOsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListUTXOsRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ListUTXOsRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListUTXOsRequestMultiError(errors)
	}
	return nil
}

// ListUTXOsRequestMultiError is an error wrapping multiple validation errors
// returned by ListUTXOsRequest.Validate(true) if the designated constraints
// aren't met.
type ListUTXOsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUTXOsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUTXOsRequestMultiError) AllErrors() []error { return m }

// ListUTXOsRequestValidationError is the validation error returned by
// ListUTXOsRequest.Validate if the designated constraints aren't met.
type ListUTXOsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUTXOsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUTXOsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUTXOsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUTXOsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUTXOsRequestValidationError) ErrorName() string { return "ListUTXOsRequestValidationError" }

// Error satisfies the builtin error interface
func (e ListUTXOsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUTXOsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUTXOsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUTXOsRequestValidationError{}

var _ListUTXOsRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListUTXOsResponse with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in ListUTXOsResponseMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *ListUTXOsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUtxos() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListUTXOsResponseValidationError{
					field:  fmt.Sprintf("Utxos[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListUTXOsResponseMultiError(errors)
	}
	return nil
}

// ListUTXOsResponseMultiError is an error wrapping multiple validation errors
// returned by ListUTXOsResponse.Validate(true) if the designated constraints
// aren't met.
type ListUTXOsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUTXOsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUTXOsResponseMultiError) AllErrors() []error { return m }

// ListUTXOsResponseValidationError is the validation error returned by
// ListUTXOsResponse.Validate if the designated constraints aren't met.
type ListUTXOsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUTXOsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUTXOsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUTXOsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUTXOsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUTXOsResponseValidationError) ErrorName() string {
	return "ListUTXOsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListUTXOsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUTXOsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUTXOsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUTXOsResponseValidationError{}

// Validate checks the field values on UpdateShouldCheckRemittanceFlagRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in
// UpdateShouldCheckRemittanceFlagRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UpdateShouldCheckRemittanceFlagRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateShouldCheckRemittanceFlagRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := UpdateShouldCheckRemittanceFlagRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ShouldCheckRemittance

	if len(errors) > 0 {
		return UpdateShouldCheckRemittanceFlagRequestMultiError(errors)
	}
	return nil
}

// UpdateShouldCheckRemittanceFlagRequestMultiError is an error wrapping
// multiple validation errors returned by
// UpdateShouldCheckRemittanceFlagRequest.Validate(true) if the designated
// constraints aren't met.
type UpdateShouldCheckRemittanceFlagRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateShouldCheckRemittanceFlagRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateShouldCheckRemittanceFlagRequestMultiError) AllErrors() []error { return m }

// UpdateShouldCheckRemittanceFlagRequestValidationError is the validation
// error returned by UpdateShouldCheckRemittanceFlagRequest.Validate if the
// designated constraints aren't met.
type UpdateShouldCheckRemittanceFlagRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateShouldCheckRemittanceFlagRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateShouldCheckRemittanceFlagRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateShouldCheckRemittanceFlagRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateShouldCheckRemittanceFlagRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateShouldCheckRemittanceFlagRequestValidationError) ErrorName() string {
	return "UpdateShouldCheckRemittanceFlagRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateShouldCheckRemittanceFlagRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateShouldCheckRemittanceFlagRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateShouldCheckRemittanceFlagRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateShouldCheckRemittanceFlagRequestValidationError{}

var _UpdateShouldCheckRemittanceFlagRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on CreateWalletGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateWalletGroupRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CreateWalletGroupRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := CreateWalletGroupRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateWalletGroupRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := CreateWalletGroupRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := CreateWalletGroupRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetWalletIds()) < 1 {
		err := CreateWalletGroupRequestValidationError{
			field:  "WalletIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for WatchOnly

	if len(errors) > 0 {
		return CreateWalletGroupRequestMultiError(errors)
	}
	return nil
}

// CreateWalletGroupRequestMultiError is an error wrapping multiple validation
// errors returned by CreateWalletGroupRequest.Validate(true) if the
// designated constraints aren't met.
type CreateWalletGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWalletGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWalletGroupRequestMultiError) AllErrors() []error { return m }

// CreateWalletGroupRequestValidationError is the validation error returned by
// CreateWalletGroupRequest.Validate if the designated constraints aren't met.
type CreateWalletGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWalletGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWalletGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWalletGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWalletGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWalletGroupRequestValidationError) ErrorName() string {
	return "CreateWalletGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWalletGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWalletGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWalletGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWalletGroupRequestValidationError{}

var _CreateWalletGroupRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

// Validate checks the field values on CreateWalletGroupResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateWalletGroupResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CreateWalletGroupResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletGroupId

	if len(errors) > 0 {
		return CreateWalletGroupResponseMultiError(errors)
	}
	return nil
}

// CreateWalletGroupResponseMultiError is an error wrapping multiple validation
// errors returned by CreateWalletGroupResponse.Validate(true) if the
// designated constraints aren't met.
type CreateWalletGroupResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWalletGroupResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWalletGroupResponseMultiError) AllErrors() []error { return m }

// CreateWalletGroupResponseValidationError is the validation error returned by
// CreateWalletGroupResponse.Validate if the designated constraints aren't met.
type CreateWalletGroupResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWalletGroupResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWalletGroupResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWalletGroupResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWalletGroupResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWalletGroupResponseValidationError) ErrorName() string {
	return "CreateWalletGroupResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWalletGroupResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWalletGroupResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWalletGroupResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWalletGroupResponseValidationError{}

// Validate checks the field values on UpdateWalletGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateWalletGroupRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UpdateWalletGroupRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateWalletGroupRequest_WalletGroupId_Pattern.MatchString(m.GetWalletGroupId()) {
		err := UpdateWalletGroupRequestValidationError{
			field:  "WalletGroupId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetWalletIds()) < 1 {
		err := UpdateWalletGroupRequestValidationError{
			field:  "WalletIds",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateWalletGroupRequestMultiError(errors)
	}
	return nil
}

// UpdateWalletGroupRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateWalletGroupRequest.Validate(true) if the
// designated constraints aren't met.
type UpdateWalletGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWalletGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWalletGroupRequestMultiError) AllErrors() []error { return m }

// UpdateWalletGroupRequestValidationError is the validation error returned by
// UpdateWalletGroupRequest.Validate if the designated constraints aren't met.
type UpdateWalletGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWalletGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWalletGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWalletGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWalletGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWalletGroupRequestValidationError) ErrorName() string {
	return "UpdateWalletGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWalletGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWalletGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWalletGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWalletGroupRequestValidationError{}

var _UpdateWalletGroupRequest_WalletGroupId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on UpdateWalletGroupNameRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateWalletGroupNameRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UpdateWalletGroupNameRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateWalletGroupNameRequest_WalletGroupId_Pattern.MatchString(m.GetWalletGroupId()) {
		err := UpdateWalletGroupNameRequestValidationError{
			field:  "WalletGroupId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := UpdateWalletGroupNameRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateWalletGroupNameRequestMultiError(errors)
	}
	return nil
}

// UpdateWalletGroupNameRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateWalletGroupNameRequest.Validate(true)
// if the designated constraints aren't met.
type UpdateWalletGroupNameRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWalletGroupNameRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWalletGroupNameRequestMultiError) AllErrors() []error { return m }

// UpdateWalletGroupNameRequestValidationError is the validation error returned
// by UpdateWalletGroupNameRequest.Validate if the designated constraints
// aren't met.
type UpdateWalletGroupNameRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWalletGroupNameRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWalletGroupNameRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWalletGroupNameRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWalletGroupNameRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWalletGroupNameRequestValidationError) ErrorName() string {
	return "UpdateWalletGroupNameRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWalletGroupNameRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWalletGroupNameRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWalletGroupNameRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWalletGroupNameRequestValidationError{}

var _UpdateWalletGroupNameRequest_WalletGroupId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on GetWalletGroupRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetWalletGroupRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *GetWalletGroupRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetWalletGroupRequest_WalletGroupId_Pattern.MatchString(m.GetWalletGroupId()) {
		err := GetWalletGroupRequestValidationError{
			field:  "WalletGroupId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetWalletGroupRequestMultiError(errors)
	}
	return nil
}

// GetWalletGroupRequestMultiError is an error wrapping multiple validation
// errors returned by GetWalletGroupRequest.Validate(true) if the designated
// constraints aren't met.
type GetWalletGroupRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWalletGroupRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWalletGroupRequestMultiError) AllErrors() []error { return m }

// GetWalletGroupRequestValidationError is the validation error returned by
// GetWalletGroupRequest.Validate if the designated constraints aren't met.
type GetWalletGroupRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWalletGroupRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWalletGroupRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWalletGroupRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWalletGroupRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWalletGroupRequestValidationError) ErrorName() string {
	return "GetWalletGroupRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWalletGroupRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWalletGroupRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWalletGroupRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWalletGroupRequestValidationError{}

var _GetWalletGroupRequest_WalletGroupId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListWalletGroupsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListWalletGroupsRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListWalletGroupsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WatchOnly

	if m.GetPageSize() > 100 {
		err := ListWalletGroupsRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 100",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListWalletGroupsRequest_PageToken_Pattern.MatchString(m.GetPageToken()) {
		err := ListWalletGroupsRequestValidationError{
			field:  "PageToken",
			reason: "value does not match regex pattern \"^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListWalletGroupsRequestMultiError(errors)
	}
	return nil
}

// ListWalletGroupsRequestMultiError is an error wrapping multiple validation
// errors returned by ListWalletGroupsRequest.Validate(true) if the designated
// constraints aren't met.
type ListWalletGroupsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletGroupsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletGroupsRequestMultiError) AllErrors() []error { return m }

// ListWalletGroupsRequestValidationError is the validation error returned by
// ListWalletGroupsRequest.Validate if the designated constraints aren't met.
type ListWalletGroupsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletGroupsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletGroupsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletGroupsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletGroupsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletGroupsRequestValidationError) ErrorName() string {
	return "ListWalletGroupsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletGroupsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletGroupsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletGroupsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletGroupsRequestValidationError{}

var _ListWalletGroupsRequest_PageToken_Pattern = regexp.MustCompile("^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$")

// Validate checks the field values on ListWalletGroupsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListWalletGroupsResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListWalletGroupsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWalletGroups() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListWalletGroupsResponseValidationError{
					field:  fmt.Sprintf("WalletGroups[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListWalletGroupsResponseMultiError(errors)
	}
	return nil
}

// ListWalletGroupsResponseMultiError is an error wrapping multiple validation
// errors returned by ListWalletGroupsResponse.Validate(true) if the
// designated constraints aren't met.
type ListWalletGroupsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletGroupsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletGroupsResponseMultiError) AllErrors() []error { return m }

// ListWalletGroupsResponseValidationError is the validation error returned by
// ListWalletGroupsResponse.Validate if the designated constraints aren't met.
type ListWalletGroupsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletGroupsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletGroupsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletGroupsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletGroupsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletGroupsResponseValidationError) ErrorName() string {
	return "ListWalletGroupsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletGroupsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletGroupsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletGroupsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletGroupsResponseValidationError{}

// Validate checks the field values on UpdateDestinationWalletIDRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in UpdateDestinationWalletIDRequestMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *UpdateDestinationWalletIDRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateDestinationWalletIDRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := UpdateDestinationWalletIDRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateDestinationWalletIDRequest_DestinationWalletId_Pattern.MatchString(m.GetDestinationWalletId()) {
		err := UpdateDestinationWalletIDRequestValidationError{
			field:  "DestinationWalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateDestinationWalletIDRequestMultiError(errors)
	}
	return nil
}

// UpdateDestinationWalletIDRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateDestinationWalletIDRequest.Validate(true) if the designated
// constraints aren't met.
type UpdateDestinationWalletIDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateDestinationWalletIDRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateDestinationWalletIDRequestMultiError) AllErrors() []error { return m }

// UpdateDestinationWalletIDRequestValidationError is the validation error
// returned by UpdateDestinationWalletIDRequest.Validate if the designated
// constraints aren't met.
type UpdateDestinationWalletIDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateDestinationWalletIDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateDestinationWalletIDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateDestinationWalletIDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateDestinationWalletIDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateDestinationWalletIDRequestValidationError) ErrorName() string {
	return "UpdateDestinationWalletIDRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateDestinationWalletIDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateDestinationWalletIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateDestinationWalletIDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateDestinationWalletIDRequestValidationError{}

var _UpdateDestinationWalletIDRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _UpdateDestinationWalletIDRequest_DestinationWalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on RegisterKeyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in RegisterKeyRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *RegisterKeyRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_RegisterKeyRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := RegisterKeyRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetPubKey()) < 64 {
		err := RegisterKeyRequestValidationError{
			field:  "PubKey",
			reason: "value length must be at least 64 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RegisterKeyRequestMultiError(errors)
	}
	return nil
}

// RegisterKeyRequestMultiError is an error wrapping multiple validation errors
// returned by RegisterKeyRequest.Validate(true) if the designated constraints
// aren't met.
type RegisterKeyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterKeyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterKeyRequestMultiError) AllErrors() []error { return m }

// RegisterKeyRequestValidationError is the validation error returned by
// RegisterKeyRequest.Validate if the designated constraints aren't met.
type RegisterKeyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterKeyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterKeyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterKeyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterKeyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterKeyRequestValidationError) ErrorName() string {
	return "RegisterKeyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterKeyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterKeyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterKeyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterKeyRequestValidationError{}

var _RegisterKeyRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on RegisterKeyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in RegisterKeyResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *RegisterKeyResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for KeyId

	if len(errors) > 0 {
		return RegisterKeyResponseMultiError(errors)
	}
	return nil
}

// RegisterKeyResponseMultiError is an error wrapping multiple validation
// errors returned by RegisterKeyResponse.Validate(true) if the designated
// constraints aren't met.
type RegisterKeyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RegisterKeyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RegisterKeyResponseMultiError) AllErrors() []error { return m }

// RegisterKeyResponseValidationError is the validation error returned by
// RegisterKeyResponse.Validate if the designated constraints aren't met.
type RegisterKeyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RegisterKeyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RegisterKeyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RegisterKeyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RegisterKeyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RegisterKeyResponseValidationError) ErrorName() string {
	return "RegisterKeyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e RegisterKeyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRegisterKeyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RegisterKeyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RegisterKeyResponseValidationError{}

// Validate checks the field values on CreateAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateAddressRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CreateAddressRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CreateAddressRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := CreateAddressRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if len(errors) > 0 {
		return CreateAddressRequestMultiError(errors)
	}
	return nil
}

// CreateAddressRequestMultiError is an error wrapping multiple validation
// errors returned by CreateAddressRequest.Validate(true) if the designated
// constraints aren't met.
type CreateAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAddressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAddressRequestMultiError) AllErrors() []error { return m }

// CreateAddressRequestValidationError is the validation error returned by
// CreateAddressRequest.Validate if the designated constraints aren't met.
type CreateAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAddressRequestValidationError) ErrorName() string {
	return "CreateAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAddressRequestValidationError{}

var _CreateAddressRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on CreateAddressResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateAddressResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CreateAddressResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AddressId

	if len(errors) > 0 {
		return CreateAddressResponseMultiError(errors)
	}
	return nil
}

// CreateAddressResponseMultiError is an error wrapping multiple validation
// errors returned by CreateAddressResponse.Validate(true) if the designated
// constraints aren't met.
type CreateAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateAddressResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateAddressResponseMultiError) AllErrors() []error { return m }

// CreateAddressResponseValidationError is the validation error returned by
// CreateAddressResponse.Validate if the designated constraints aren't met.
type CreateAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateAddressResponseValidationError) ErrorName() string {
	return "CreateAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateAddressResponseValidationError{}

// Validate checks the field values on GetAddressRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in GetAddressRequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *GetAddressRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetAddressRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := GetAddressRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetAddressRequest_AddressId_Pattern.MatchString(m.GetAddressId()) {
		err := GetAddressRequestValidationError{
			field:  "AddressId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetAddressRequestMultiError(errors)
	}
	return nil
}

// GetAddressRequestMultiError is an error wrapping multiple validation errors
// returned by GetAddressRequest.Validate(true) if the designated constraints
// aren't met.
type GetAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAddressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAddressRequestMultiError) AllErrors() []error { return m }

// GetAddressRequestValidationError is the validation error returned by
// GetAddressRequest.Validate if the designated constraints aren't met.
type GetAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAddressRequestValidationError) ErrorName() string {
	return "GetAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAddressRequestValidationError{}

var _GetAddressRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _GetAddressRequest_AddressId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on GetAddressByAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetAddressByAddressRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *GetAddressByAddressRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetAddressByAddressRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := GetAddressByAddressRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAddress()) < 25 {
		err := GetAddressByAddressRequestValidationError{
			field:  "Address",
			reason: "value length must be at least 25 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetAddressByAddressRequestMultiError(errors)
	}
	return nil
}

// GetAddressByAddressRequestMultiError is an error wrapping multiple
// validation errors returned by GetAddressByAddressRequest.Validate(true) if
// the designated constraints aren't met.
type GetAddressByAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAddressByAddressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAddressByAddressRequestMultiError) AllErrors() []error { return m }

// GetAddressByAddressRequestValidationError is the validation error returned
// by GetAddressByAddressRequest.Validate if the designated constraints aren't met.
type GetAddressByAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAddressByAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAddressByAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAddressByAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAddressByAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAddressByAddressRequestValidationError) ErrorName() string {
	return "GetAddressByAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAddressByAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAddressByAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAddressByAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAddressByAddressRequestValidationError{}

var _GetAddressByAddressRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on GetAddressByAddressCoinRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetAddressByAddressCoinRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *GetAddressByAddressCoinRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) < 25 {
		err := GetAddressByAddressCoinRequestValidationError{
			field:  "Address",
			reason: "value length must be at least 25 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _GetAddressByAddressCoinRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := GetAddressByAddressCoinRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := GetAddressByAddressCoinRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetAddressByAddressCoinRequestMultiError(errors)
	}
	return nil
}

// GetAddressByAddressCoinRequestMultiError is an error wrapping multiple
// validation errors returned by GetAddressByAddressCoinRequest.Validate(true)
// if the designated constraints aren't met.
type GetAddressByAddressCoinRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAddressByAddressCoinRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAddressByAddressCoinRequestMultiError) AllErrors() []error { return m }

// GetAddressByAddressCoinRequestValidationError is the validation error
// returned by GetAddressByAddressCoinRequest.Validate if the designated
// constraints aren't met.
type GetAddressByAddressCoinRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAddressByAddressCoinRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAddressByAddressCoinRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAddressByAddressCoinRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAddressByAddressCoinRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAddressByAddressCoinRequestValidationError) ErrorName() string {
	return "GetAddressByAddressCoinRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAddressByAddressCoinRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAddressByAddressCoinRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAddressByAddressCoinRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAddressByAddressCoinRequestValidationError{}

var _GetAddressByAddressCoinRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

// Validate checks the field values on GetAddressByIndexRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetAddressByIndexRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *GetAddressByIndexRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetAddressByIndexRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := GetAddressByIndexRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetIndex() < 0 {
		err := GetAddressByIndexRequestValidationError{
			field:  "Index",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetAddressByIndexRequestMultiError(errors)
	}
	return nil
}

// GetAddressByIndexRequestMultiError is an error wrapping multiple validation
// errors returned by GetAddressByIndexRequest.Validate(true) if the
// designated constraints aren't met.
type GetAddressByIndexRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAddressByIndexRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAddressByIndexRequestMultiError) AllErrors() []error { return m }

// GetAddressByIndexRequestValidationError is the validation error returned by
// GetAddressByIndexRequest.Validate if the designated constraints aren't met.
type GetAddressByIndexRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAddressByIndexRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAddressByIndexRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAddressByIndexRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAddressByIndexRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAddressByIndexRequestValidationError) ErrorName() string {
	return "GetAddressByIndexRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAddressByIndexRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAddressByIndexRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAddressByIndexRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAddressByIndexRequestValidationError{}

var _GetAddressByIndexRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on GetAddressWithoutBalanceByIndexRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in
// GetAddressWithoutBalanceByIndexRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *GetAddressWithoutBalanceByIndexRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetAddressWithoutBalanceByIndexRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := GetAddressWithoutBalanceByIndexRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetIndex() < 0 {
		err := GetAddressWithoutBalanceByIndexRequestValidationError{
			field:  "Index",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetAddressWithoutBalanceByIndexRequestMultiError(errors)
	}
	return nil
}

// GetAddressWithoutBalanceByIndexRequestMultiError is an error wrapping
// multiple validation errors returned by
// GetAddressWithoutBalanceByIndexRequest.Validate(true) if the designated
// constraints aren't met.
type GetAddressWithoutBalanceByIndexRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetAddressWithoutBalanceByIndexRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetAddressWithoutBalanceByIndexRequestMultiError) AllErrors() []error { return m }

// GetAddressWithoutBalanceByIndexRequestValidationError is the validation
// error returned by GetAddressWithoutBalanceByIndexRequest.Validate if the
// designated constraints aren't met.
type GetAddressWithoutBalanceByIndexRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetAddressWithoutBalanceByIndexRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetAddressWithoutBalanceByIndexRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetAddressWithoutBalanceByIndexRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetAddressWithoutBalanceByIndexRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetAddressWithoutBalanceByIndexRequestValidationError) ErrorName() string {
	return "GetAddressWithoutBalanceByIndexRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetAddressWithoutBalanceByIndexRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetAddressWithoutBalanceByIndexRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetAddressWithoutBalanceByIndexRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetAddressWithoutBalanceByIndexRequestValidationError{}

var _GetAddressWithoutBalanceByIndexRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListAddressesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListAddressesRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListAddressesRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListAddressesRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ListAddressesRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OmitChange

	if m.GetPageSize() > 100 {
		err := ListAddressesRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 100",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListAddressesRequest_PageToken_Pattern.MatchString(m.GetPageToken()) {
		err := ListAddressesRequestValidationError{
			field:  "PageToken",
			reason: "value does not match regex pattern \"^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListAddressesRequestMultiError(errors)
	}
	return nil
}

// ListAddressesRequestMultiError is an error wrapping multiple validation
// errors returned by ListAddressesRequest.Validate(true) if the designated
// constraints aren't met.
type ListAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAddressesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAddressesRequestMultiError) AllErrors() []error { return m }

// ListAddressesRequestValidationError is the validation error returned by
// ListAddressesRequest.Validate if the designated constraints aren't met.
type ListAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAddressesRequestValidationError) ErrorName() string {
	return "ListAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAddressesRequestValidationError{}

var _ListAddressesRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ListAddressesRequest_PageToken_Pattern = regexp.MustCompile("^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$")

// Validate checks the field values on ListAddressesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListAddressesResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListAddressesResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListAddressesResponseValidationError{
					field:  fmt.Sprintf("Addresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListAddressesResponseMultiError(errors)
	}
	return nil
}

// ListAddressesResponseMultiError is an error wrapping multiple validation
// errors returned by ListAddressesResponse.Validate(true) if the designated
// constraints aren't met.
type ListAddressesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAddressesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAddressesResponseMultiError) AllErrors() []error { return m }

// ListAddressesResponseValidationError is the validation error returned by
// ListAddressesResponse.Validate if the designated constraints aren't met.
type ListAddressesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAddressesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAddressesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAddressesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAddressesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAddressesResponseValidationError) ErrorName() string {
	return "ListAddressesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAddressesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAddressesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAddressesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAddressesResponseValidationError{}

// Validate checks the field values on ListAddressesWithBalanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListAddressesWithBalanceRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListAddressesWithBalanceRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListAddressesWithBalanceRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ListAddressesWithBalanceRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListAddressesWithBalanceRequestMultiError(errors)
	}
	return nil
}

// ListAddressesWithBalanceRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListAddressesWithBalanceRequest.Validate(true) if the designated
// constraints aren't met.
type ListAddressesWithBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAddressesWithBalanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAddressesWithBalanceRequestMultiError) AllErrors() []error { return m }

// ListAddressesWithBalanceRequestValidationError is the validation error
// returned by ListAddressesWithBalanceRequest.Validate if the designated
// constraints aren't met.
type ListAddressesWithBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAddressesWithBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAddressesWithBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAddressesWithBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAddressesWithBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAddressesWithBalanceRequestValidationError) ErrorName() string {
	return "ListAddressesWithBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAddressesWithBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAddressesWithBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAddressesWithBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAddressesWithBalanceRequestValidationError{}

var _ListAddressesWithBalanceRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListAddressesWithBalanceResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListAddressesWithBalanceResponseMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListAddressesWithBalanceResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListAddressesWithBalanceResponseValidationError{
					field:  fmt.Sprintf("Addresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListAddressesWithBalanceResponseMultiError(errors)
	}
	return nil
}

// ListAddressesWithBalanceResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListAddressesWithBalanceResponse.Validate(true) if the designated
// constraints aren't met.
type ListAddressesWithBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAddressesWithBalanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAddressesWithBalanceResponseMultiError) AllErrors() []error { return m }

// ListAddressesWithBalanceResponseValidationError is the validation error
// returned by ListAddressesWithBalanceResponse.Validate if the designated
// constraints aren't met.
type ListAddressesWithBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAddressesWithBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAddressesWithBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAddressesWithBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAddressesWithBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAddressesWithBalanceResponseValidationError) ErrorName() string {
	return "ListAddressesWithBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAddressesWithBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAddressesWithBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAddressesWithBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAddressesWithBalanceResponseValidationError{}

// Validate checks the field values on UpdateAddressBalanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateAddressBalanceRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UpdateAddressBalanceRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateAddressBalanceRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := UpdateAddressBalanceRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Address

	if len(errors) > 0 {
		return UpdateAddressBalanceRequestMultiError(errors)
	}
	return nil
}

// UpdateAddressBalanceRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateAddressBalanceRequest.Validate(true) if
// the designated constraints aren't met.
type UpdateAddressBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateAddressBalanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateAddressBalanceRequestMultiError) AllErrors() []error { return m }

// UpdateAddressBalanceRequestValidationError is the validation error returned
// by UpdateAddressBalanceRequest.Validate if the designated constraints
// aren't met.
type UpdateAddressBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateAddressBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateAddressBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateAddressBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateAddressBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateAddressBalanceRequestValidationError) ErrorName() string {
	return "UpdateAddressBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateAddressBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateAddressBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateAddressBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateAddressBalanceRequestValidationError{}

var _UpdateAddressBalanceRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListAddressesWithoutBalanceRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListAddressesWithoutBalanceRequestMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListAddressesWithoutBalanceRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListAddressesWithoutBalanceRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ListAddressesWithoutBalanceRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for OmitChange

	if m.GetPageSize() > 100 {
		err := ListAddressesWithoutBalanceRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 100",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListAddressesWithoutBalanceRequest_PageToken_Pattern.MatchString(m.GetPageToken()) {
		err := ListAddressesWithoutBalanceRequestValidationError{
			field:  "PageToken",
			reason: "value does not match regex pattern \"^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListAddressesWithoutBalanceRequestMultiError(errors)
	}
	return nil
}

// ListAddressesWithoutBalanceRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListAddressesWithoutBalanceRequest.Validate(true) if the designated
// constraints aren't met.
type ListAddressesWithoutBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAddressesWithoutBalanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAddressesWithoutBalanceRequestMultiError) AllErrors() []error { return m }

// ListAddressesWithoutBalanceRequestValidationError is the validation error
// returned by ListAddressesWithoutBalanceRequest.Validate if the designated
// constraints aren't met.
type ListAddressesWithoutBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAddressesWithoutBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAddressesWithoutBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAddressesWithoutBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAddressesWithoutBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAddressesWithoutBalanceRequestValidationError) ErrorName() string {
	return "ListAddressesWithoutBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAddressesWithoutBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAddressesWithoutBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAddressesWithoutBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAddressesWithoutBalanceRequestValidationError{}

var _ListAddressesWithoutBalanceRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ListAddressesWithoutBalanceRequest_PageToken_Pattern = regexp.MustCompile("^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$")

// Validate checks the field values on ListAddressesWithoutBalanceResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListAddressesWithoutBalanceResponseMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListAddressesWithoutBalanceResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListAddressesWithoutBalanceResponseValidationError{
					field:  fmt.Sprintf("Addresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListAddressesWithoutBalanceResponseMultiError(errors)
	}
	return nil
}

// ListAddressesWithoutBalanceResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListAddressesWithoutBalanceResponse.Validate(true) if the designated
// constraints aren't met.
type ListAddressesWithoutBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAddressesWithoutBalanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAddressesWithoutBalanceResponseMultiError) AllErrors() []error { return m }

// ListAddressesWithoutBalanceResponseValidationError is the validation error
// returned by ListAddressesWithoutBalanceResponse.Validate if the designated
// constraints aren't met.
type ListAddressesWithoutBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAddressesWithoutBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAddressesWithoutBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAddressesWithoutBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAddressesWithoutBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAddressesWithoutBalanceResponseValidationError) ErrorName() string {
	return "ListAddressesWithoutBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAddressesWithoutBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAddressesWithoutBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAddressesWithoutBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAddressesWithoutBalanceResponseValidationError{}

// Validate checks the field values on GetEthereumFeeAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetEthereumFeeAddressRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *GetEthereumFeeAddressRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetEthereumFeeAddressRequestMultiError(errors)
	}
	return nil
}

// GetEthereumFeeAddressRequestMultiError is an error wrapping multiple
// validation errors returned by GetEthereumFeeAddressRequest.Validate(true)
// if the designated constraints aren't met.
type GetEthereumFeeAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetEthereumFeeAddressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetEthereumFeeAddressRequestMultiError) AllErrors() []error { return m }

// GetEthereumFeeAddressRequestValidationError is the validation error returned
// by GetEthereumFeeAddressRequest.Validate if the designated constraints
// aren't met.
type GetEthereumFeeAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetEthereumFeeAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetEthereumFeeAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetEthereumFeeAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetEthereumFeeAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetEthereumFeeAddressRequestValidationError) ErrorName() string {
	return "GetEthereumFeeAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetEthereumFeeAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetEthereumFeeAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetEthereumFeeAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetEthereumFeeAddressRequestValidationError{}

// Validate checks the field values on
// DeleteAllWatchOnlyAddressesByWalletIDRequest with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// DeleteAllWatchOnlyAddressesByWalletIDRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *DeleteAllWatchOnlyAddressesByWalletIDRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_DeleteAllWatchOnlyAddressesByWalletIDRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := DeleteAllWatchOnlyAddressesByWalletIDRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteAllWatchOnlyAddressesByWalletIDRequestMultiError(errors)
	}
	return nil
}

// DeleteAllWatchOnlyAddressesByWalletIDRequestMultiError is an error wrapping
// multiple validation errors returned by
// DeleteAllWatchOnlyAddressesByWalletIDRequest.Validate(true) if the
// designated constraints aren't met.
type DeleteAllWatchOnlyAddressesByWalletIDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteAllWatchOnlyAddressesByWalletIDRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteAllWatchOnlyAddressesByWalletIDRequestMultiError) AllErrors() []error { return m }

// DeleteAllWatchOnlyAddressesByWalletIDRequestValidationError is the
// validation error returned by
// DeleteAllWatchOnlyAddressesByWalletIDRequest.Validate if the designated
// constraints aren't met.
type DeleteAllWatchOnlyAddressesByWalletIDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteAllWatchOnlyAddressesByWalletIDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteAllWatchOnlyAddressesByWalletIDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteAllWatchOnlyAddressesByWalletIDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteAllWatchOnlyAddressesByWalletIDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteAllWatchOnlyAddressesByWalletIDRequestValidationError) ErrorName() string {
	return "DeleteAllWatchOnlyAddressesByWalletIDRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteAllWatchOnlyAddressesByWalletIDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteAllWatchOnlyAddressesByWalletIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteAllWatchOnlyAddressesByWalletIDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteAllWatchOnlyAddressesByWalletIDRequestValidationError{}

var _DeleteAllWatchOnlyAddressesByWalletIDRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ImportAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ImportAddressRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ImportAddressRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ImportAddressRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ImportAddressRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Address

	// no validation rules for IsChangeAddress

	if len(errors) > 0 {
		return ImportAddressRequestMultiError(errors)
	}
	return nil
}

// ImportAddressRequestMultiError is an error wrapping multiple validation
// errors returned by ImportAddressRequest.Validate(true) if the designated
// constraints aren't met.
type ImportAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportAddressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportAddressRequestMultiError) AllErrors() []error { return m }

// ImportAddressRequestValidationError is the validation error returned by
// ImportAddressRequest.Validate if the designated constraints aren't met.
type ImportAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportAddressRequestValidationError) ErrorName() string {
	return "ImportAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ImportAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportAddressRequestValidationError{}

var _ImportAddressRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on CreateTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateTransactionRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CreateTransactionRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CreateTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := CreateTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = CreateTransactionRequestValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for Address

	// no validation rules for DestinationTag

	// no validation rules for MemoId

	// no validation rules for StringValue

	if v, ok := interface{}(m.GetSubstrateSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CreateTransactionRequestValidationError{
				field:  "SubstrateSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetWalletConnectSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CreateTransactionRequestValidationError{
				field:  "WalletConnectSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetNemSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CreateTransactionRequestValidationError{
				field:  "NemSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetIostSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CreateTransactionRequestValidationError{
				field:  "IostSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetXymSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CreateTransactionRequestValidationError{
				field:  "XymSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetEthereumSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CreateTransactionRequestValidationError{
				field:  "EthereumSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return CreateTransactionRequestMultiError(errors)
	}
	return nil
}

// CreateTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by CreateTransactionRequest.Validate(true) if the
// designated constraints aren't met.
type CreateTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionRequestMultiError) AllErrors() []error { return m }

// CreateTransactionRequestValidationError is the validation error returned by
// CreateTransactionRequest.Validate if the designated constraints aren't met.
type CreateTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionRequestValidationError) ErrorName() string {
	return "CreateTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionRequestValidationError{}

var _CreateTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on CreateTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateTransactionResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CreateTransactionResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	if len(errors) > 0 {
		return CreateTransactionResponseMultiError(errors)
	}
	return nil
}

// CreateTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by CreateTransactionResponse.Validate(true) if the
// designated constraints aren't met.
type CreateTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionResponseMultiError) AllErrors() []error { return m }

// CreateTransactionResponseValidationError is the validation error returned by
// CreateTransactionResponse.Validate if the designated constraints aren't met.
type CreateTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionResponseValidationError) ErrorName() string {
	return "CreateTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionResponseValidationError{}

// Validate checks the field values on CreateXRPInitTransactionsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in CreateXRPInitTransactionsRequestMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *CreateXRPInitTransactionsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CreateXRPInitTransactionsRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := CreateXRPInitTransactionsRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateXRPInitTransactionsRequestMultiError(errors)
	}
	return nil
}

// CreateXRPInitTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateXRPInitTransactionsRequest.Validate(true) if the designated
// constraints aren't met.
type CreateXRPInitTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateXRPInitTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateXRPInitTransactionsRequestMultiError) AllErrors() []error { return m }

// CreateXRPInitTransactionsRequestValidationError is the validation error
// returned by CreateXRPInitTransactionsRequest.Validate if the designated
// constraints aren't met.
type CreateXRPInitTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateXRPInitTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateXRPInitTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateXRPInitTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateXRPInitTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateXRPInitTransactionsRequestValidationError) ErrorName() string {
	return "CreateXRPInitTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateXRPInitTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateXRPInitTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateXRPInitTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateXRPInitTransactionsRequestValidationError{}

var _CreateXRPInitTransactionsRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on CreateInitTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateInitTransactionRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CreateInitTransactionRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CreateInitTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := CreateInitTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetIostSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CreateInitTransactionRequestValidationError{
				field:  "IostSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return CreateInitTransactionRequestMultiError(errors)
	}
	return nil
}

// CreateInitTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by CreateInitTransactionRequest.Validate(true)
// if the designated constraints aren't met.
type CreateInitTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateInitTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateInitTransactionRequestMultiError) AllErrors() []error { return m }

// CreateInitTransactionRequestValidationError is the validation error returned
// by CreateInitTransactionRequest.Validate if the designated constraints
// aren't met.
type CreateInitTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateInitTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateInitTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateInitTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateInitTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateInitTransactionRequestValidationError) ErrorName() string {
	return "CreateInitTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateInitTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateInitTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateInitTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateInitTransactionRequestValidationError{}

var _CreateInitTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on SignTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SignTransactionRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *SignTransactionRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SignTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := SignTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SignTransactionRequest_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := SignTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SignTransactionRequest_KeyId_Pattern.MatchString(m.GetKeyId()) {
		err := SignTransactionRequestValidationError{
			field:  "KeyId",
			reason: "value does not match regex pattern \"^$|^[0-9A-F]{64}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetSignedInfo() == nil {
		err := SignTransactionRequestValidationError{
			field:  "SignedInfo",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetSignedInfo()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = SignTransactionRequestValidationError{
				field:  "SignedInfo",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return SignTransactionRequestMultiError(errors)
	}
	return nil
}

// SignTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by SignTransactionRequest.Validate(true) if the designated
// constraints aren't met.
type SignTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignTransactionRequestMultiError) AllErrors() []error { return m }

// SignTransactionRequestValidationError is the validation error returned by
// SignTransactionRequest.Validate if the designated constraints aren't met.
type SignTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignTransactionRequestValidationError) ErrorName() string {
	return "SignTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SignTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignTransactionRequestValidationError{}

var _SignTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _SignTransactionRequest_TransactionId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _SignTransactionRequest_KeyId_Pattern = regexp.MustCompile("^$|^[0-9A-F]{64}$")

// Validate checks the field values on SignXRPInitTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SignXRPInitTransactionsRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *SignXRPInitTransactionsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SignXRPInitTransactionsRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := SignXRPInitTransactionsRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SignXRPInitTransactionsRequest_KeyId_Pattern.MatchString(m.GetKeyId()) {
		err := SignXRPInitTransactionsRequestValidationError{
			field:  "KeyId",
			reason: "value does not match regex pattern \"^[0-9A-F]{64}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetSignedInfo()) < 1 {
		err := SignXRPInitTransactionsRequestValidationError{
			field:  "SignedInfo",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSignedInfo() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = SignXRPInitTransactionsRequestValidationError{
					field:  fmt.Sprintf("SignedInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return SignXRPInitTransactionsRequestMultiError(errors)
	}
	return nil
}

// SignXRPInitTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by SignXRPInitTransactionsRequest.Validate(true)
// if the designated constraints aren't met.
type SignXRPInitTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignXRPInitTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignXRPInitTransactionsRequestMultiError) AllErrors() []error { return m }

// SignXRPInitTransactionsRequestValidationError is the validation error
// returned by SignXRPInitTransactionsRequest.Validate if the designated
// constraints aren't met.
type SignXRPInitTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignXRPInitTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignXRPInitTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignXRPInitTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignXRPInitTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignXRPInitTransactionsRequestValidationError) ErrorName() string {
	return "SignXRPInitTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SignXRPInitTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignXRPInitTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignXRPInitTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignXRPInitTransactionsRequestValidationError{}

var _SignXRPInitTransactionsRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _SignXRPInitTransactionsRequest_KeyId_Pattern = regexp.MustCompile("^[0-9A-F]{64}$")

// Validate checks the field values on SignInitTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SignInitTransactionRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *SignInitTransactionRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SignInitTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := SignInitTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SignInitTransactionRequest_KeyId_Pattern.MatchString(m.GetKeyId()) {
		err := SignInitTransactionRequestValidationError{
			field:  "KeyId",
			reason: "value does not match regex pattern \"^[0-9A-F]{64}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetSignedInfo()) < 1 {
		err := SignInitTransactionRequestValidationError{
			field:  "SignedInfo",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSignedInfo() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = SignInitTransactionRequestValidationError{
					field:  fmt.Sprintf("SignedInfo[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return SignInitTransactionRequestMultiError(errors)
	}
	return nil
}

// SignInitTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by SignInitTransactionRequest.Validate(true) if
// the designated constraints aren't met.
type SignInitTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignInitTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignInitTransactionRequestMultiError) AllErrors() []error { return m }

// SignInitTransactionRequestValidationError is the validation error returned
// by SignInitTransactionRequest.Validate if the designated constraints aren't met.
type SignInitTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignInitTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignInitTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignInitTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignInitTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignInitTransactionRequestValidationError) ErrorName() string {
	return "SignInitTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SignInitTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignInitTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignInitTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignInitTransactionRequestValidationError{}

var _SignInitTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _SignInitTransactionRequest_KeyId_Pattern = regexp.MustCompile("^[0-9A-F]{64}$")

// Validate checks the field values on SendTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SendTransactionRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *SendTransactionRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SendTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := SendTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SendTransactionRequest_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := SendTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ExecutorType

	if len(errors) > 0 {
		return SendTransactionRequestMultiError(errors)
	}
	return nil
}

// SendTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by SendTransactionRequest.Validate(true) if the designated
// constraints aren't met.
type SendTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendTransactionRequestMultiError) AllErrors() []error { return m }

// SendTransactionRequestValidationError is the validation error returned by
// SendTransactionRequest.Validate if the designated constraints aren't met.
type SendTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendTransactionRequestValidationError) ErrorName() string {
	return "SendTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SendTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendTransactionRequestValidationError{}

var _SendTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _SendTransactionRequest_TransactionId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on SendTransactionResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SendTransactionResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *SendTransactionResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	if len(errors) > 0 {
		return SendTransactionResponseMultiError(errors)
	}
	return nil
}

// SendTransactionResponseMultiError is an error wrapping multiple validation
// errors returned by SendTransactionResponse.Validate(true) if the designated
// constraints aren't met.
type SendTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendTransactionResponseMultiError) AllErrors() []error { return m }

// SendTransactionResponseValidationError is the validation error returned by
// SendTransactionResponse.Validate if the designated constraints aren't met.
type SendTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendTransactionResponseValidationError) ErrorName() string {
	return "SendTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SendTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendTransactionResponseValidationError{}

// Validate checks the field values on SendXRPInitTransactionsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SendXRPInitTransactionsRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *SendXRPInitTransactionsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SendXRPInitTransactionsRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := SendXRPInitTransactionsRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SendXRPInitTransactionsRequestMultiError(errors)
	}
	return nil
}

// SendXRPInitTransactionsRequestMultiError is an error wrapping multiple
// validation errors returned by SendXRPInitTransactionsRequest.Validate(true)
// if the designated constraints aren't met.
type SendXRPInitTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendXRPInitTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendXRPInitTransactionsRequestMultiError) AllErrors() []error { return m }

// SendXRPInitTransactionsRequestValidationError is the validation error
// returned by SendXRPInitTransactionsRequest.Validate if the designated
// constraints aren't met.
type SendXRPInitTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendXRPInitTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendXRPInitTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendXRPInitTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendXRPInitTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendXRPInitTransactionsRequestValidationError) ErrorName() string {
	return "SendXRPInitTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SendXRPInitTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendXRPInitTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendXRPInitTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendXRPInitTransactionsRequestValidationError{}

var _SendXRPInitTransactionsRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on SendXRPInitTransactionsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SendXRPInitTransactionsResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *SendXRPInitTransactionsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SendXRPInitTransactionsResponseMultiError(errors)
	}
	return nil
}

// SendXRPInitTransactionsResponseMultiError is an error wrapping multiple
// validation errors returned by
// SendXRPInitTransactionsResponse.Validate(true) if the designated
// constraints aren't met.
type SendXRPInitTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendXRPInitTransactionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendXRPInitTransactionsResponseMultiError) AllErrors() []error { return m }

// SendXRPInitTransactionsResponseValidationError is the validation error
// returned by SendXRPInitTransactionsResponse.Validate if the designated
// constraints aren't met.
type SendXRPInitTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendXRPInitTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendXRPInitTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendXRPInitTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendXRPInitTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendXRPInitTransactionsResponseValidationError) ErrorName() string {
	return "SendXRPInitTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SendXRPInitTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendXRPInitTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendXRPInitTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendXRPInitTransactionsResponseValidationError{}

// Validate checks the field values on SendInitTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SendInitTransactionRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *SendInitTransactionRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SendInitTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := SendInitTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for ExecutorType

	if len(errors) > 0 {
		return SendInitTransactionRequestMultiError(errors)
	}
	return nil
}

// SendInitTransactionRequestMultiError is an error wrapping multiple
// validation errors returned by SendInitTransactionRequest.Validate(true) if
// the designated constraints aren't met.
type SendInitTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendInitTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendInitTransactionRequestMultiError) AllErrors() []error { return m }

// SendInitTransactionRequestValidationError is the validation error returned
// by SendInitTransactionRequest.Validate if the designated constraints aren't met.
type SendInitTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendInitTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendInitTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendInitTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendInitTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendInitTransactionRequestValidationError) ErrorName() string {
	return "SendInitTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SendInitTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendInitTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendInitTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendInitTransactionRequestValidationError{}

var _SendInitTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on SendInitTransactionResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SendInitTransactionResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *SendInitTransactionResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SendInitTransactionResponseMultiError(errors)
	}
	return nil
}

// SendInitTransactionResponseMultiError is an error wrapping multiple
// validation errors returned by SendInitTransactionResponse.Validate(true) if
// the designated constraints aren't met.
type SendInitTransactionResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendInitTransactionResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendInitTransactionResponseMultiError) AllErrors() []error { return m }

// SendInitTransactionResponseValidationError is the validation error returned
// by SendInitTransactionResponse.Validate if the designated constraints
// aren't met.
type SendInitTransactionResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendInitTransactionResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendInitTransactionResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendInitTransactionResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendInitTransactionResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendInitTransactionResponseValidationError) ErrorName() string {
	return "SendInitTransactionResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SendInitTransactionResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendInitTransactionResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendInitTransactionResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendInitTransactionResponseValidationError{}

// Validate checks the field values on CancelTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CancelTransactionRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CancelTransactionRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CancelTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := CancelTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CancelTransactionRequest_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := CancelTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CancelTransactionRequestMultiError(errors)
	}
	return nil
}

// CancelTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by CancelTransactionRequest.Validate(true) if the
// designated constraints aren't met.
type CancelTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CancelTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CancelTransactionRequestMultiError) AllErrors() []error { return m }

// CancelTransactionRequestValidationError is the validation error returned by
// CancelTransactionRequest.Validate if the designated constraints aren't met.
type CancelTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CancelTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CancelTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CancelTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CancelTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CancelTransactionRequestValidationError) ErrorName() string {
	return "CancelTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CancelTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCancelTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CancelTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CancelTransactionRequestValidationError{}

var _CancelTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _CancelTransactionRequest_TransactionId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on GetTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetTransactionRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *GetTransactionRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := GetTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetTransactionRequest_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := GetTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTransactionRequestMultiError(errors)
	}
	return nil
}

// GetTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by GetTransactionRequest.Validate(true) if the designated
// constraints aren't met.
type GetTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionRequestMultiError) AllErrors() []error { return m }

// GetTransactionRequestValidationError is the validation error returned by
// GetTransactionRequest.Validate if the designated constraints aren't met.
type GetTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionRequestValidationError) ErrorName() string {
	return "GetTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionRequestValidationError{}

var _GetTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _GetTransactionRequest_TransactionId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on GetTransactionByTxIDRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetTransactionByTxIDRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *GetTransactionByTxIDRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetTransactionByTxIDRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := GetTransactionByTxIDRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetTransactionByTxIDRequest_TxId_Pattern.MatchString(m.GetTxId()) {
		err := GetTransactionByTxIDRequestValidationError{
			field:  "TxId",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{64}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTransactionByTxIDRequestMultiError(errors)
	}
	return nil
}

// GetTransactionByTxIDRequestMultiError is an error wrapping multiple
// validation errors returned by GetTransactionByTxIDRequest.Validate(true) if
// the designated constraints aren't met.
type GetTransactionByTxIDRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransactionByTxIDRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransactionByTxIDRequestMultiError) AllErrors() []error { return m }

// GetTransactionByTxIDRequestValidationError is the validation error returned
// by GetTransactionByTxIDRequest.Validate if the designated constraints
// aren't met.
type GetTransactionByTxIDRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransactionByTxIDRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransactionByTxIDRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransactionByTxIDRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransactionByTxIDRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransactionByTxIDRequestValidationError) ErrorName() string {
	return "GetTransactionByTxIDRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransactionByTxIDRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransactionByTxIDRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransactionByTxIDRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransactionByTxIDRequestValidationError{}

var _GetTransactionByTxIDRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _GetTransactionByTxIDRequest_TxId_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{64}$")

// Validate checks the field values on ListTransactionsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListTransactionsRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListTransactionsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListTransactionsRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ListTransactionsRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() > 100 {
		err := ListTransactionsRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 100",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListTransactionsRequest_PageToken_Pattern.MatchString(m.GetPageToken()) {
		err := ListTransactionsRequestValidationError{
			field:  "PageToken",
			reason: "value does not match regex pattern \"^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListTransactionsRequestMultiError(errors)
	}
	return nil
}

// ListTransactionsRequestMultiError is an error wrapping multiple validation
// errors returned by ListTransactionsRequest.Validate(true) if the designated
// constraints aren't met.
type ListTransactionsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionsRequestMultiError) AllErrors() []error { return m }

// ListTransactionsRequestValidationError is the validation error returned by
// ListTransactionsRequest.Validate if the designated constraints aren't met.
type ListTransactionsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionsRequestValidationError) ErrorName() string {
	return "ListTransactionsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionsRequestValidationError{}

var _ListTransactionsRequest_WalletId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ListTransactionsRequest_PageToken_Pattern = regexp.MustCompile("^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$")

// Validate checks the field values on ListTransactionsByFilterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListTransactionsByFilterRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListTransactionsByFilterRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _ListTransactionsByFilterRequest_FilterType_NotInLookup[m.GetFilterType()]; ok {
		err := ListTransactionsByFilterRequestValidationError{
			field:  "FilterType",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := ListFilterType_name[int32(m.GetFilterType())]; !ok {
		err := ListTransactionsByFilterRequestValidationError{
			field:  "FilterType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TransactionId

	// no validation rules for WalletId

	if utf8.RuneCountInString(m.GetWalletName()) > 40 {
		err := ListTransactionsByFilterRequestValidationError{
			field:  "WalletName",
			reason: "value length must be at most 40 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAddressName()) > 40 {
		err := ListTransactionsByFilterRequestValidationError{
			field:  "AddressName",
			reason: "value length must be at most 40 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Address

	// no validation rules for Txid

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := ListTransactionsByFilterRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() > 100 {
		err := ListTransactionsByFilterRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 100",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListTransactionsByFilterRequest_PageToken_Pattern.MatchString(m.GetPageToken()) {
		err := ListTransactionsByFilterRequestValidationError{
			field:  "PageToken",
			reason: "value does not match regex pattern \"^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListTransactionsByFilterRequestMultiError(errors)
	}
	return nil
}

// ListTransactionsByFilterRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListTransactionsByFilterRequest.Validate(true) if the designated
// constraints aren't met.
type ListTransactionsByFilterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionsByFilterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionsByFilterRequestMultiError) AllErrors() []error { return m }

// ListTransactionsByFilterRequestValidationError is the validation error
// returned by ListTransactionsByFilterRequest.Validate if the designated
// constraints aren't met.
type ListTransactionsByFilterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionsByFilterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionsByFilterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionsByFilterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionsByFilterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionsByFilterRequestValidationError) ErrorName() string {
	return "ListTransactionsByFilterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionsByFilterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionsByFilterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionsByFilterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionsByFilterRequestValidationError{}

var _ListTransactionsByFilterRequest_FilterType_NotInLookup = map[ListFilterType]struct{}{
	0: {},
}

var _ListTransactionsByFilterRequest_PageToken_Pattern = regexp.MustCompile("^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$")

// Validate checks the field values on ListTransactionsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListTransactionsResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListTransactionsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransactions() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListTransactionsResponseValidationError{
					field:  fmt.Sprintf("Transactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListTransactionsResponseMultiError(errors)
	}
	return nil
}

// ListTransactionsResponseMultiError is an error wrapping multiple validation
// errors returned by ListTransactionsResponse.Validate(true) if the
// designated constraints aren't met.
type ListTransactionsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransactionsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransactionsResponseMultiError) AllErrors() []error { return m }

// ListTransactionsResponseValidationError is the validation error returned by
// ListTransactionsResponse.Validate if the designated constraints aren't met.
type ListTransactionsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransactionsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransactionsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransactionsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransactionsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransactionsResponseValidationError) ErrorName() string {
	return "ListTransactionsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransactionsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransactionsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransactionsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransactionsResponseValidationError{}

// Validate checks the field values on GetSignInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetSignInfoRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *GetSignInfoRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetSignInfoRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := GetSignInfoRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_GetSignInfoRequest_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := GetSignInfoRequestValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetSignInfoRequestMultiError(errors)
	}
	return nil
}

// GetSignInfoRequestMultiError is an error wrapping multiple validation errors
// returned by GetSignInfoRequest.Validate(true) if the designated constraints
// aren't met.
type GetSignInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSignInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSignInfoRequestMultiError) AllErrors() []error { return m }

// GetSignInfoRequestValidationError is the validation error returned by
// GetSignInfoRequest.Validate if the designated constraints aren't met.
type GetSignInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSignInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSignInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSignInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSignInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSignInfoRequestValidationError) ErrorName() string {
	return "GetSignInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSignInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSignInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSignInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSignInfoRequestValidationError{}

var _GetSignInfoRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _GetSignInfoRequest_TransactionId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListSignInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListSignInfoRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListSignInfoRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListSignInfoRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ListSignInfoRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListSignInfoRequest_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := ListSignInfoRequestValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListSignInfoRequestMultiError(errors)
	}
	return nil
}

// ListSignInfoRequestMultiError is an error wrapping multiple validation
// errors returned by ListSignInfoRequest.Validate(true) if the designated
// constraints aren't met.
type ListSignInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSignInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSignInfoRequestMultiError) AllErrors() []error { return m }

// ListSignInfoRequestValidationError is the validation error returned by
// ListSignInfoRequest.Validate if the designated constraints aren't met.
type ListSignInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSignInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSignInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSignInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSignInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSignInfoRequestValidationError) ErrorName() string {
	return "ListSignInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListSignInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSignInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSignInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSignInfoRequestValidationError{}

var _ListSignInfoRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ListSignInfoRequest_TransactionId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListSignInfoResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListSignInfoResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListSignInfoResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSignInfoList() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListSignInfoResponseValidationError{
					field:  fmt.Sprintf("SignInfoList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListSignInfoResponseMultiError(errors)
	}
	return nil
}

// ListSignInfoResponseMultiError is an error wrapping multiple validation
// errors returned by ListSignInfoResponse.Validate(true) if the designated
// constraints aren't met.
type ListSignInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSignInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSignInfoResponseMultiError) AllErrors() []error { return m }

// ListSignInfoResponseValidationError is the validation error returned by
// ListSignInfoResponse.Validate if the designated constraints aren't met.
type ListSignInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSignInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSignInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSignInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSignInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSignInfoResponseValidationError) ErrorName() string {
	return "ListSignInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListSignInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSignInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSignInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSignInfoResponseValidationError{}

// Validate checks the field values on ListXRPInitSignInfoRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListXRPInitSignInfoRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListXRPInitSignInfoRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListXRPInitSignInfoRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ListXRPInitSignInfoRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListXRPInitSignInfoRequestMultiError(errors)
	}
	return nil
}

// ListXRPInitSignInfoRequestMultiError is an error wrapping multiple
// validation errors returned by ListXRPInitSignInfoRequest.Validate(true) if
// the designated constraints aren't met.
type ListXRPInitSignInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListXRPInitSignInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListXRPInitSignInfoRequestMultiError) AllErrors() []error { return m }

// ListXRPInitSignInfoRequestValidationError is the validation error returned
// by ListXRPInitSignInfoRequest.Validate if the designated constraints aren't met.
type ListXRPInitSignInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListXRPInitSignInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListXRPInitSignInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListXRPInitSignInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListXRPInitSignInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListXRPInitSignInfoRequestValidationError) ErrorName() string {
	return "ListXRPInitSignInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListXRPInitSignInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListXRPInitSignInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListXRPInitSignInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListXRPInitSignInfoRequestValidationError{}

var _ListXRPInitSignInfoRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListXRPInitSignInfoResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListXRPInitSignInfoResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListXRPInitSignInfoResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSignInfoList() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListXRPInitSignInfoResponseValidationError{
					field:  fmt.Sprintf("SignInfoList[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListXRPInitSignInfoResponseMultiError(errors)
	}
	return nil
}

// ListXRPInitSignInfoResponseMultiError is an error wrapping multiple
// validation errors returned by ListXRPInitSignInfoResponse.Validate(true) if
// the designated constraints aren't met.
type ListXRPInitSignInfoResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListXRPInitSignInfoResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListXRPInitSignInfoResponseMultiError) AllErrors() []error { return m }

// ListXRPInitSignInfoResponseValidationError is the validation error returned
// by ListXRPInitSignInfoResponse.Validate if the designated constraints
// aren't met.
type ListXRPInitSignInfoResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListXRPInitSignInfoResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListXRPInitSignInfoResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListXRPInitSignInfoResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListXRPInitSignInfoResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListXRPInitSignInfoResponseValidationError) ErrorName() string {
	return "ListXRPInitSignInfoResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListXRPInitSignInfoResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListXRPInitSignInfoResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListXRPInitSignInfoResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListXRPInitSignInfoResponseValidationError{}

// Validate checks the field values on ListInitSignInfoRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListInitSignInfoRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListInitSignInfoRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListInitSignInfoRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ListInitSignInfoRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListInitSignInfoRequestMultiError(errors)
	}
	return nil
}

// ListInitSignInfoRequestMultiError is an error wrapping multiple validation
// errors returned by ListInitSignInfoRequest.Validate(true) if the designated
// constraints aren't met.
type ListInitSignInfoRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListInitSignInfoRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListInitSignInfoRequestMultiError) AllErrors() []error { return m }

// ListInitSignInfoRequestValidationError is the validation error returned by
// ListInitSignInfoRequest.Validate if the designated constraints aren't met.
type ListInitSignInfoRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListInitSignInfoRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListInitSignInfoRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListInitSignInfoRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListInitSignInfoRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListInitSignInfoRequestValidationError) ErrorName() string {
	return "ListInitSignInfoRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListInitSignInfoRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListInitSignInfoRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListInitSignInfoRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListInitSignInfoRequestValidationError{}

var _ListInitSignInfoRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListTransfersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListTransfersRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListTransfersRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListTransfersRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ListTransfersRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() > 100 {
		err := ListTransfersRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 100",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListTransfersRequest_PageToken_Pattern.MatchString(m.GetPageToken()) {
		err := ListTransfersRequestValidationError{
			field:  "PageToken",
			reason: "value does not match regex pattern \"^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListTransfersRequestMultiError(errors)
	}
	return nil
}

// ListTransfersRequestMultiError is an error wrapping multiple validation
// errors returned by ListTransfersRequest.Validate(true) if the designated
// constraints aren't met.
type ListTransfersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransfersRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransfersRequestMultiError) AllErrors() []error { return m }

// ListTransfersRequestValidationError is the validation error returned by
// ListTransfersRequest.Validate if the designated constraints aren't met.
type ListTransfersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransfersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransfersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransfersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransfersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransfersRequestValidationError) ErrorName() string {
	return "ListTransfersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransfersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransfersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransfersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransfersRequestValidationError{}

var _ListTransfersRequest_WalletId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ListTransfersRequest_PageToken_Pattern = regexp.MustCompile("^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$")

// Validate checks the field values on ListTransfersByFilterRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListTransfersByFilterRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListTransfersByFilterRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _ListTransfersByFilterRequest_FilterType_NotInLookup[m.GetFilterType()]; ok {
		err := ListTransfersByFilterRequestValidationError{
			field:  "FilterType",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := ListFilterType_name[int32(m.GetFilterType())]; !ok {
		err := ListTransfersByFilterRequestValidationError{
			field:  "FilterType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TransferId

	// no validation rules for WalletId

	if utf8.RuneCountInString(m.GetWalletName()) > 40 {
		err := ListTransfersByFilterRequestValidationError{
			field:  "WalletName",
			reason: "value length must be at most 40 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAddressName()) > 40 {
		err := ListTransfersByFilterRequestValidationError{
			field:  "AddressName",
			reason: "value length must be at most 40 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Address

	// no validation rules for Txid

	// no validation rules for WatchOnly

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := ListTransfersByFilterRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.TransferType_name[int32(m.GetTransferType())]; !ok {
		err := ListTransfersByFilterRequestValidationError{
			field:  "TransferType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() > 100 {
		err := ListTransfersByFilterRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 100",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListTransfersByFilterRequest_PageToken_Pattern.MatchString(m.GetPageToken()) {
		err := ListTransfersByFilterRequestValidationError{
			field:  "PageToken",
			reason: "value does not match regex pattern \"^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetStartTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListTransfersByFilterRequestValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetEndTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListTransfersByFilterRequestValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ListTransfersByFilterRequestMultiError(errors)
	}
	return nil
}

// ListTransfersByFilterRequestMultiError is an error wrapping multiple
// validation errors returned by ListTransfersByFilterRequest.Validate(true)
// if the designated constraints aren't met.
type ListTransfersByFilterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransfersByFilterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransfersByFilterRequestMultiError) AllErrors() []error { return m }

// ListTransfersByFilterRequestValidationError is the validation error returned
// by ListTransfersByFilterRequest.Validate if the designated constraints
// aren't met.
type ListTransfersByFilterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransfersByFilterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransfersByFilterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransfersByFilterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransfersByFilterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransfersByFilterRequestValidationError) ErrorName() string {
	return "ListTransfersByFilterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransfersByFilterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransfersByFilterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransfersByFilterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransfersByFilterRequestValidationError{}

var _ListTransfersByFilterRequest_FilterType_NotInLookup = map[ListFilterType]struct{}{
	0: {},
}

var _ListTransfersByFilterRequest_PageToken_Pattern = regexp.MustCompile("^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$")

// Validate checks the field values on ListTransfersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListTransfersResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListTransfersResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransfers() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListTransfersResponseValidationError{
					field:  fmt.Sprintf("Transfers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListTransfersResponseMultiError(errors)
	}
	return nil
}

// ListTransfersResponseMultiError is an error wrapping multiple validation
// errors returned by ListTransfersResponse.Validate(true) if the designated
// constraints aren't met.
type ListTransfersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransfersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransfersResponseMultiError) AllErrors() []error { return m }

// ListTransfersResponseValidationError is the validation error returned by
// ListTransfersResponse.Validate if the designated constraints aren't met.
type ListTransfersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransfersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransfersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransfersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransfersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransfersResponseValidationError) ErrorName() string {
	return "ListTransfersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransfersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransfersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransfersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransfersResponseValidationError{}

// Validate checks the field values on ListUncheckedTransfersByFilterRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in
// ListUncheckedTransfersByFilterRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListUncheckedTransfersByFilterRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for HasChecked

	if m.GetPageSize() > 100 {
		err := ListUncheckedTransfersByFilterRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 100",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListUncheckedTransfersByFilterRequest_PageToken_Pattern.MatchString(m.GetPageToken()) {
		err := ListUncheckedTransfersByFilterRequestValidationError{
			field:  "PageToken",
			reason: "value does not match regex pattern \"^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _ListUncheckedTransfersByFilterRequest_FilterType_NotInLookup[m.GetFilterType()]; ok {
		err := ListUncheckedTransfersByFilterRequestValidationError{
			field:  "FilterType",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := ListFilterType_name[int32(m.GetFilterType())]; !ok {
		err := ListUncheckedTransfersByFilterRequestValidationError{
			field:  "FilterType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for TransferId

	// no validation rules for WalletId

	if utf8.RuneCountInString(m.GetWalletName()) > 40 {
		err := ListUncheckedTransfersByFilterRequestValidationError{
			field:  "WalletName",
			reason: "value length must be at most 40 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Address

	// no validation rules for Txid

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := ListUncheckedTransfersByFilterRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.TransferType_name[int32(m.GetTransferType())]; !ok {
		err := ListUncheckedTransfersByFilterRequestValidationError{
			field:  "TransferType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if v, ok := interface{}(m.GetStartTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListUncheckedTransfersByFilterRequestValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetEndTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListUncheckedTransfersByFilterRequestValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ListUncheckedTransfersByFilterRequestMultiError(errors)
	}
	return nil
}

// ListUncheckedTransfersByFilterRequestMultiError is an error wrapping
// multiple validation errors returned by
// ListUncheckedTransfersByFilterRequest.Validate(true) if the designated
// constraints aren't met.
type ListUncheckedTransfersByFilterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUncheckedTransfersByFilterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUncheckedTransfersByFilterRequestMultiError) AllErrors() []error { return m }

// ListUncheckedTransfersByFilterRequestValidationError is the validation error
// returned by ListUncheckedTransfersByFilterRequest.Validate if the
// designated constraints aren't met.
type ListUncheckedTransfersByFilterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUncheckedTransfersByFilterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUncheckedTransfersByFilterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUncheckedTransfersByFilterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUncheckedTransfersByFilterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUncheckedTransfersByFilterRequestValidationError) ErrorName() string {
	return "ListUncheckedTransfersByFilterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListUncheckedTransfersByFilterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUncheckedTransfersByFilterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUncheckedTransfersByFilterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUncheckedTransfersByFilterRequestValidationError{}

var _ListUncheckedTransfersByFilterRequest_PageToken_Pattern = regexp.MustCompile("^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$")

var _ListUncheckedTransfersByFilterRequest_FilterType_NotInLookup = map[ListFilterType]struct{}{
	0: {},
}

// Validate checks the field values on
// UpdateUncheckedTransferHasCheckedFlagRequest with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// UpdateUncheckedTransferHasCheckedFlagRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UpdateUncheckedTransferHasCheckedFlagRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateUncheckedTransferHasCheckedFlagRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := UpdateUncheckedTransferHasCheckedFlagRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdateUncheckedTransferHasCheckedFlagRequest_UncheckedTransferId_Pattern.MatchString(m.GetUncheckedTransferId()) {
		err := UpdateUncheckedTransferHasCheckedFlagRequestValidationError{
			field:  "UncheckedTransferId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateUncheckedTransferHasCheckedFlagRequestMultiError(errors)
	}
	return nil
}

// UpdateUncheckedTransferHasCheckedFlagRequestMultiError is an error wrapping
// multiple validation errors returned by
// UpdateUncheckedTransferHasCheckedFlagRequest.Validate(true) if the
// designated constraints aren't met.
type UpdateUncheckedTransferHasCheckedFlagRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateUncheckedTransferHasCheckedFlagRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateUncheckedTransferHasCheckedFlagRequestMultiError) AllErrors() []error { return m }

// UpdateUncheckedTransferHasCheckedFlagRequestValidationError is the
// validation error returned by
// UpdateUncheckedTransferHasCheckedFlagRequest.Validate if the designated
// constraints aren't met.
type UpdateUncheckedTransferHasCheckedFlagRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateUncheckedTransferHasCheckedFlagRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateUncheckedTransferHasCheckedFlagRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateUncheckedTransferHasCheckedFlagRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateUncheckedTransferHasCheckedFlagRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateUncheckedTransferHasCheckedFlagRequestValidationError) ErrorName() string {
	return "UpdateUncheckedTransferHasCheckedFlagRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateUncheckedTransferHasCheckedFlagRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateUncheckedTransferHasCheckedFlagRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateUncheckedTransferHasCheckedFlagRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateUncheckedTransferHasCheckedFlagRequestValidationError{}

var _UpdateUncheckedTransferHasCheckedFlagRequest_WalletId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _UpdateUncheckedTransferHasCheckedFlagRequest_UncheckedTransferId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListUncheckedTransfersResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListUncheckedTransfersResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListUncheckedTransfersResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetUncheckedTransfers() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListUncheckedTransfersResponseValidationError{
					field:  fmt.Sprintf("UncheckedTransfers[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListUncheckedTransfersResponseMultiError(errors)
	}
	return nil
}

// ListUncheckedTransfersResponseMultiError is an error wrapping multiple
// validation errors returned by ListUncheckedTransfersResponse.Validate(true)
// if the designated constraints aren't met.
type ListUncheckedTransfersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListUncheckedTransfersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListUncheckedTransfersResponseMultiError) AllErrors() []error { return m }

// ListUncheckedTransfersResponseValidationError is the validation error
// returned by ListUncheckedTransfersResponse.Validate if the designated
// constraints aren't met.
type ListUncheckedTransfersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListUncheckedTransfersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListUncheckedTransfersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListUncheckedTransfersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListUncheckedTransfersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListUncheckedTransfersResponseValidationError) ErrorName() string {
	return "ListUncheckedTransfersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListUncheckedTransfersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListUncheckedTransfersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListUncheckedTransfersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListUncheckedTransfersResponseValidationError{}

// Validate checks the field values on ListEventTriggeredMessagesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListEventTriggeredMessagesRequestMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListEventTriggeredMessagesRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListEventTriggeredMessagesRequestMultiError(errors)
	}
	return nil
}

// ListEventTriggeredMessagesRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListEventTriggeredMessagesRequest.Validate(true) if the designated
// constraints aren't met.
type ListEventTriggeredMessagesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListEventTriggeredMessagesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListEventTriggeredMessagesRequestMultiError) AllErrors() []error { return m }

// ListEventTriggeredMessagesRequestValidationError is the validation error
// returned by ListEventTriggeredMessagesRequest.Validate if the designated
// constraints aren't met.
type ListEventTriggeredMessagesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListEventTriggeredMessagesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListEventTriggeredMessagesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListEventTriggeredMessagesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListEventTriggeredMessagesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListEventTriggeredMessagesRequestValidationError) ErrorName() string {
	return "ListEventTriggeredMessagesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListEventTriggeredMessagesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListEventTriggeredMessagesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListEventTriggeredMessagesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListEventTriggeredMessagesRequestValidationError{}

// Validate checks the field values on ListEventTriggeredMessagesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListEventTriggeredMessagesResponseMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListEventTriggeredMessagesResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetEventTriggeredMessages() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListEventTriggeredMessagesResponseValidationError{
					field:  fmt.Sprintf("EventTriggeredMessages[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListEventTriggeredMessagesResponseMultiError(errors)
	}
	return nil
}

// ListEventTriggeredMessagesResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListEventTriggeredMessagesResponse.Validate(true) if the designated
// constraints aren't met.
type ListEventTriggeredMessagesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListEventTriggeredMessagesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListEventTriggeredMessagesResponseMultiError) AllErrors() []error { return m }

// ListEventTriggeredMessagesResponseValidationError is the validation error
// returned by ListEventTriggeredMessagesResponse.Validate if the designated
// constraints aren't met.
type ListEventTriggeredMessagesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListEventTriggeredMessagesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListEventTriggeredMessagesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListEventTriggeredMessagesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListEventTriggeredMessagesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListEventTriggeredMessagesResponseValidationError) ErrorName() string {
	return "ListEventTriggeredMessagesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListEventTriggeredMessagesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListEventTriggeredMessagesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListEventTriggeredMessagesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListEventTriggeredMessagesResponseValidationError{}

// Validate checks the field values on CreateEventTriggeredMessageRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in CreateEventTriggeredMessageRequestMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *CreateEventTriggeredMessageRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventTriggeredMessageType

	// no validation rules for Destination

	if len(errors) > 0 {
		return CreateEventTriggeredMessageRequestMultiError(errors)
	}
	return nil
}

// CreateEventTriggeredMessageRequestMultiError is an error wrapping multiple
// validation errors returned by
// CreateEventTriggeredMessageRequest.Validate(true) if the designated
// constraints aren't met.
type CreateEventTriggeredMessageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateEventTriggeredMessageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateEventTriggeredMessageRequestMultiError) AllErrors() []error { return m }

// CreateEventTriggeredMessageRequestValidationError is the validation error
// returned by CreateEventTriggeredMessageRequest.Validate if the designated
// constraints aren't met.
type CreateEventTriggeredMessageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateEventTriggeredMessageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateEventTriggeredMessageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateEventTriggeredMessageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateEventTriggeredMessageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateEventTriggeredMessageRequestValidationError) ErrorName() string {
	return "CreateEventTriggeredMessageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateEventTriggeredMessageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateEventTriggeredMessageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateEventTriggeredMessageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateEventTriggeredMessageRequestValidationError{}

// Validate checks the field values on CreateEventTriggeredMessageResponce with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in CreateEventTriggeredMessageResponceMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *CreateEventTriggeredMessageResponce) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventTriggeredMessageId

	if len(errors) > 0 {
		return CreateEventTriggeredMessageResponceMultiError(errors)
	}
	return nil
}

// CreateEventTriggeredMessageResponceMultiError is an error wrapping multiple
// validation errors returned by
// CreateEventTriggeredMessageResponce.Validate(true) if the designated
// constraints aren't met.
type CreateEventTriggeredMessageResponceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateEventTriggeredMessageResponceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateEventTriggeredMessageResponceMultiError) AllErrors() []error { return m }

// CreateEventTriggeredMessageResponceValidationError is the validation error
// returned by CreateEventTriggeredMessageResponce.Validate if the designated
// constraints aren't met.
type CreateEventTriggeredMessageResponceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateEventTriggeredMessageResponceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateEventTriggeredMessageResponceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateEventTriggeredMessageResponceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateEventTriggeredMessageResponceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateEventTriggeredMessageResponceValidationError) ErrorName() string {
	return "CreateEventTriggeredMessageResponceValidationError"
}

// Error satisfies the builtin error interface
func (e CreateEventTriggeredMessageResponceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateEventTriggeredMessageResponce.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateEventTriggeredMessageResponceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateEventTriggeredMessageResponceValidationError{}

// Validate checks the field values on UpdateEventTriggeredMessageRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in UpdateEventTriggeredMessageRequestMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *UpdateEventTriggeredMessageRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateEventTriggeredMessageRequest_EventTriggeredMessageId_Pattern.MatchString(m.GetEventTriggeredMessageId()) {
		err := UpdateEventTriggeredMessageRequestValidationError{
			field:  "EventTriggeredMessageId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Destination

	if len(errors) > 0 {
		return UpdateEventTriggeredMessageRequestMultiError(errors)
	}
	return nil
}

// UpdateEventTriggeredMessageRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateEventTriggeredMessageRequest.Validate(true) if the designated
// constraints aren't met.
type UpdateEventTriggeredMessageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateEventTriggeredMessageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateEventTriggeredMessageRequestMultiError) AllErrors() []error { return m }

// UpdateEventTriggeredMessageRequestValidationError is the validation error
// returned by UpdateEventTriggeredMessageRequest.Validate if the designated
// constraints aren't met.
type UpdateEventTriggeredMessageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateEventTriggeredMessageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateEventTriggeredMessageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateEventTriggeredMessageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateEventTriggeredMessageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateEventTriggeredMessageRequestValidationError) ErrorName() string {
	return "UpdateEventTriggeredMessageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateEventTriggeredMessageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateEventTriggeredMessageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateEventTriggeredMessageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateEventTriggeredMessageRequestValidationError{}

var _UpdateEventTriggeredMessageRequest_EventTriggeredMessageId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on DeleteEventTriggeredMessageRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in DeleteEventTriggeredMessageRequestMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *DeleteEventTriggeredMessageRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_DeleteEventTriggeredMessageRequest_EventTriggeredMessageId_Pattern.MatchString(m.GetEventTriggeredMessageId()) {
		err := DeleteEventTriggeredMessageRequestValidationError{
			field:  "EventTriggeredMessageId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteEventTriggeredMessageRequestMultiError(errors)
	}
	return nil
}

// DeleteEventTriggeredMessageRequestMultiError is an error wrapping multiple
// validation errors returned by
// DeleteEventTriggeredMessageRequest.Validate(true) if the designated
// constraints aren't met.
type DeleteEventTriggeredMessageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteEventTriggeredMessageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteEventTriggeredMessageRequestMultiError) AllErrors() []error { return m }

// DeleteEventTriggeredMessageRequestValidationError is the validation error
// returned by DeleteEventTriggeredMessageRequest.Validate if the designated
// constraints aren't met.
type DeleteEventTriggeredMessageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteEventTriggeredMessageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteEventTriggeredMessageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteEventTriggeredMessageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteEventTriggeredMessageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteEventTriggeredMessageRequestValidationError) ErrorName() string {
	return "DeleteEventTriggeredMessageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteEventTriggeredMessageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteEventTriggeredMessageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteEventTriggeredMessageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteEventTriggeredMessageRequestValidationError{}

var _DeleteEventTriggeredMessageRequest_EventTriggeredMessageId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on GetRateSnapshotRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetRateSnapshotRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *GetRateSnapshotRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetRateSnapshotRequest_RateSnapshotId_Pattern.MatchString(m.GetRateSnapshotId()) {
		err := GetRateSnapshotRequestValidationError{
			field:  "RateSnapshotId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRateSnapshotRequestMultiError(errors)
	}
	return nil
}

// GetRateSnapshotRequestMultiError is an error wrapping multiple validation
// errors returned by GetRateSnapshotRequest.Validate(true) if the designated
// constraints aren't met.
type GetRateSnapshotRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRateSnapshotRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRateSnapshotRequestMultiError) AllErrors() []error { return m }

// GetRateSnapshotRequestValidationError is the validation error returned by
// GetRateSnapshotRequest.Validate if the designated constraints aren't met.
type GetRateSnapshotRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRateSnapshotRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRateSnapshotRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRateSnapshotRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRateSnapshotRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRateSnapshotRequestValidationError) ErrorName() string {
	return "GetRateSnapshotRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetRateSnapshotRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRateSnapshotRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRateSnapshotRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRateSnapshotRequestValidationError{}

var _GetRateSnapshotRequest_RateSnapshotId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on GetLatestRateSnapshotRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetLatestRateSnapshotRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *GetLatestRateSnapshotRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetLatestRateSnapshotRequestMultiError(errors)
	}
	return nil
}

// GetLatestRateSnapshotRequestMultiError is an error wrapping multiple
// validation errors returned by GetLatestRateSnapshotRequest.Validate(true)
// if the designated constraints aren't met.
type GetLatestRateSnapshotRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLatestRateSnapshotRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLatestRateSnapshotRequestMultiError) AllErrors() []error { return m }

// GetLatestRateSnapshotRequestValidationError is the validation error returned
// by GetLatestRateSnapshotRequest.Validate if the designated constraints
// aren't met.
type GetLatestRateSnapshotRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLatestRateSnapshotRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLatestRateSnapshotRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLatestRateSnapshotRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLatestRateSnapshotRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLatestRateSnapshotRequestValidationError) ErrorName() string {
	return "GetLatestRateSnapshotRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetLatestRateSnapshotRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLatestRateSnapshotRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLatestRateSnapshotRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLatestRateSnapshotRequestValidationError{}

// Validate checks the field values on SetRatesRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in SetRatesRequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *SetRatesRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetRates() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = SetRatesRequestValidationError{
					field:  fmt.Sprintf("Rates[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return SetRatesRequestMultiError(errors)
	}
	return nil
}

// SetRatesRequestMultiError is an error wrapping multiple validation errors
// returned by SetRatesRequest.Validate(true) if the designated constraints
// aren't met.
type SetRatesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetRatesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetRatesRequestMultiError) AllErrors() []error { return m }

// SetRatesRequestValidationError is the validation error returned by
// SetRatesRequest.Validate if the designated constraints aren't met.
type SetRatesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetRatesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetRatesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetRatesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetRatesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetRatesRequestValidationError) ErrorName() string { return "SetRatesRequestValidationError" }

// Error satisfies the builtin error interface
func (e SetRatesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetRatesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetRatesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetRatesRequestValidationError{}

// Validate checks the field values on SetDefaultRatesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SetDefaultRatesRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *SetDefaultRatesRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetDefaultRatesRequestMultiError(errors)
	}
	return nil
}

// SetDefaultRatesRequestMultiError is an error wrapping multiple validation
// errors returned by SetDefaultRatesRequest.Validate(true) if the designated
// constraints aren't met.
type SetDefaultRatesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetDefaultRatesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetDefaultRatesRequestMultiError) AllErrors() []error { return m }

// SetDefaultRatesRequestValidationError is the validation error returned by
// SetDefaultRatesRequest.Validate if the designated constraints aren't met.
type SetDefaultRatesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetDefaultRatesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetDefaultRatesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetDefaultRatesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetDefaultRatesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetDefaultRatesRequestValidationError) ErrorName() string {
	return "SetDefaultRatesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SetDefaultRatesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetDefaultRatesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetDefaultRatesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetDefaultRatesRequestValidationError{}

// Validate checks the field values on SetRatesResponse with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in SetRatesResponseMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *SetRatesResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RateSnapshotId

	if len(errors) > 0 {
		return SetRatesResponseMultiError(errors)
	}
	return nil
}

// SetRatesResponseMultiError is an error wrapping multiple validation errors
// returned by SetRatesResponse.Validate(true) if the designated constraints
// aren't met.
type SetRatesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetRatesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetRatesResponseMultiError) AllErrors() []error { return m }

// SetRatesResponseValidationError is the validation error returned by
// SetRatesResponse.Validate if the designated constraints aren't met.
type SetRatesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetRatesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetRatesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetRatesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetRatesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetRatesResponseValidationError) ErrorName() string { return "SetRatesResponseValidationError" }

// Error satisfies the builtin error interface
func (e SetRatesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetRatesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetRatesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetRatesResponseValidationError{}

// Validate checks the field values on SetDefaultRatesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SetDefaultRatesResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *SetDefaultRatesResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return SetDefaultRatesResponseMultiError(errors)
	}
	return nil
}

// SetDefaultRatesResponseMultiError is an error wrapping multiple validation
// errors returned by SetDefaultRatesResponse.Validate(true) if the designated
// constraints aren't met.
type SetDefaultRatesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SetDefaultRatesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SetDefaultRatesResponseMultiError) AllErrors() []error { return m }

// SetDefaultRatesResponseValidationError is the validation error returned by
// SetDefaultRatesResponse.Validate if the designated constraints aren't met.
type SetDefaultRatesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SetDefaultRatesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SetDefaultRatesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SetDefaultRatesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SetDefaultRatesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SetDefaultRatesResponseValidationError) ErrorName() string {
	return "SetDefaultRatesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SetDefaultRatesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSetDefaultRatesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SetDefaultRatesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SetDefaultRatesResponseValidationError{}

// Validate checks the field values on GetSpendableBalanceRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetSpendableBalanceRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *GetSpendableBalanceRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetSpendableBalanceRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := GetSpendableBalanceRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetSpendableBalanceRequestMultiError(errors)
	}
	return nil
}

// GetSpendableBalanceRequestMultiError is an error wrapping multiple
// validation errors returned by GetSpendableBalanceRequest.Validate(true) if
// the designated constraints aren't met.
type GetSpendableBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSpendableBalanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSpendableBalanceRequestMultiError) AllErrors() []error { return m }

// GetSpendableBalanceRequestValidationError is the validation error returned
// by GetSpendableBalanceRequest.Validate if the designated constraints aren't met.
type GetSpendableBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSpendableBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSpendableBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSpendableBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSpendableBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSpendableBalanceRequestValidationError) ErrorName() string {
	return "GetSpendableBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetSpendableBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSpendableBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSpendableBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSpendableBalanceRequestValidationError{}

var _GetSpendableBalanceRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on GetSpendableBalanceResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetSpendableBalanceResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *GetSpendableBalanceResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TotalSpendableBalance

	// no validation rules for StringTotalSpendableBalance

	// no validation rules for DailySpendableBalance

	// no validation rules for StringDailySpendableBalance

	// no validation rules for HourlySpendableBalance

	// no validation rules for StringHourlySpendableBalance

	// no validation rules for OneTimeSpendableBalance

	// no validation rules for StringOneTimeSpendableBalance

	if len(errors) > 0 {
		return GetSpendableBalanceResponseMultiError(errors)
	}
	return nil
}

// GetSpendableBalanceResponseMultiError is an error wrapping multiple
// validation errors returned by GetSpendableBalanceResponse.Validate(true) if
// the designated constraints aren't met.
type GetSpendableBalanceResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetSpendableBalanceResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetSpendableBalanceResponseMultiError) AllErrors() []error { return m }

// GetSpendableBalanceResponseValidationError is the validation error returned
// by GetSpendableBalanceResponse.Validate if the designated constraints
// aren't met.
type GetSpendableBalanceResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetSpendableBalanceResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetSpendableBalanceResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetSpendableBalanceResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetSpendableBalanceResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetSpendableBalanceResponseValidationError) ErrorName() string {
	return "GetSpendableBalanceResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetSpendableBalanceResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetSpendableBalanceResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetSpendableBalanceResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetSpendableBalanceResponseValidationError{}

// Validate checks the field values on GetTotalBalanceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetTotalBalanceRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *GetTotalBalanceRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WatchOnly

	if len(errors) > 0 {
		return GetTotalBalanceRequestMultiError(errors)
	}
	return nil
}

// GetTotalBalanceRequestMultiError is an error wrapping multiple validation
// errors returned by GetTotalBalanceRequest.Validate(true) if the designated
// constraints aren't met.
type GetTotalBalanceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTotalBalanceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTotalBalanceRequestMultiError) AllErrors() []error { return m }

// GetTotalBalanceRequestValidationError is the validation error returned by
// GetTotalBalanceRequest.Validate if the designated constraints aren't met.
type GetTotalBalanceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTotalBalanceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTotalBalanceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTotalBalanceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTotalBalanceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTotalBalanceRequestValidationError) ErrorName() string {
	return "GetTotalBalanceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTotalBalanceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTotalBalanceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTotalBalanceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTotalBalanceRequestValidationError{}

// Validate checks the field values on ListBalanceSnapshotsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListBalanceSnapshotsRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListBalanceSnapshotsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WatchOnly

	if v, ok := interface{}(m.GetStartTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListBalanceSnapshotsRequestValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetEndTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListBalanceSnapshotsRequestValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ListBalanceSnapshotsRequestMultiError(errors)
	}
	return nil
}

// ListBalanceSnapshotsRequestMultiError is an error wrapping multiple
// validation errors returned by ListBalanceSnapshotsRequest.Validate(true) if
// the designated constraints aren't met.
type ListBalanceSnapshotsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBalanceSnapshotsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBalanceSnapshotsRequestMultiError) AllErrors() []error { return m }

// ListBalanceSnapshotsRequestValidationError is the validation error returned
// by ListBalanceSnapshotsRequest.Validate if the designated constraints
// aren't met.
type ListBalanceSnapshotsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBalanceSnapshotsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBalanceSnapshotsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBalanceSnapshotsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBalanceSnapshotsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBalanceSnapshotsRequestValidationError) ErrorName() string {
	return "ListBalanceSnapshotsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListBalanceSnapshotsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBalanceSnapshotsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBalanceSnapshotsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBalanceSnapshotsRequestValidationError{}

// Validate checks the field values on ListBalanceSnapshotsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListBalanceSnapshotsResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListBalanceSnapshotsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetBalanceSnapshots() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListBalanceSnapshotsResponseValidationError{
					field:  fmt.Sprintf("BalanceSnapshots[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListBalanceSnapshotsResponseMultiError(errors)
	}
	return nil
}

// ListBalanceSnapshotsResponseMultiError is an error wrapping multiple
// validation errors returned by ListBalanceSnapshotsResponse.Validate(true)
// if the designated constraints aren't met.
type ListBalanceSnapshotsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListBalanceSnapshotsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListBalanceSnapshotsResponseMultiError) AllErrors() []error { return m }

// ListBalanceSnapshotsResponseValidationError is the validation error returned
// by ListBalanceSnapshotsResponse.Validate if the designated constraints
// aren't met.
type ListBalanceSnapshotsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListBalanceSnapshotsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListBalanceSnapshotsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListBalanceSnapshotsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListBalanceSnapshotsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListBalanceSnapshotsResponseValidationError) ErrorName() string {
	return "ListBalanceSnapshotsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListBalanceSnapshotsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListBalanceSnapshotsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListBalanceSnapshotsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListBalanceSnapshotsResponseValidationError{}

// Validate checks the field values on ListWalletBalanceSnapshotsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListWalletBalanceSnapshotsRequestMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListWalletBalanceSnapshotsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWalletIds() {
		_, _ = idx, item

		if !_ListWalletBalanceSnapshotsRequest_WalletIds_Pattern.MatchString(item) {
			err := ListWalletBalanceSnapshotsRequestValidationError{
				field:  fmt.Sprintf("WalletIds[%v]", idx),
				reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if v, ok := interface{}(m.GetStartTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListWalletBalanceSnapshotsRequestValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetEndTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListWalletBalanceSnapshotsRequestValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ListWalletBalanceSnapshotsRequestMultiError(errors)
	}
	return nil
}

// ListWalletBalanceSnapshotsRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListWalletBalanceSnapshotsRequest.Validate(true) if the designated
// constraints aren't met.
type ListWalletBalanceSnapshotsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletBalanceSnapshotsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletBalanceSnapshotsRequestMultiError) AllErrors() []error { return m }

// ListWalletBalanceSnapshotsRequestValidationError is the validation error
// returned by ListWalletBalanceSnapshotsRequest.Validate if the designated
// constraints aren't met.
type ListWalletBalanceSnapshotsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletBalanceSnapshotsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletBalanceSnapshotsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletBalanceSnapshotsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletBalanceSnapshotsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletBalanceSnapshotsRequestValidationError) ErrorName() string {
	return "ListWalletBalanceSnapshotsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletBalanceSnapshotsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletBalanceSnapshotsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletBalanceSnapshotsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletBalanceSnapshotsRequestValidationError{}

var _ListWalletBalanceSnapshotsRequest_WalletIds_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListWalletBalanceSnapshotsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListWalletBalanceSnapshotsResponseMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListWalletBalanceSnapshotsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetWalletBalanceSnapshotMap()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListWalletBalanceSnapshotsResponseValidationError{
				field:  "WalletBalanceSnapshotMap",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ListWalletBalanceSnapshotsResponseMultiError(errors)
	}
	return nil
}

// ListWalletBalanceSnapshotsResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListWalletBalanceSnapshotsResponse.Validate(true) if the designated
// constraints aren't met.
type ListWalletBalanceSnapshotsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletBalanceSnapshotsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletBalanceSnapshotsResponseMultiError) AllErrors() []error { return m }

// ListWalletBalanceSnapshotsResponseValidationError is the validation error
// returned by ListWalletBalanceSnapshotsResponse.Validate if the designated
// constraints aren't met.
type ListWalletBalanceSnapshotsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletBalanceSnapshotsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletBalanceSnapshotsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletBalanceSnapshotsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletBalanceSnapshotsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletBalanceSnapshotsResponseValidationError) ErrorName() string {
	return "ListWalletBalanceSnapshotsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletBalanceSnapshotsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletBalanceSnapshotsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletBalanceSnapshotsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletBalanceSnapshotsResponseValidationError{}

// Validate checks the field values on ListTransferVolumeSnapshotsRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListTransferVolumeSnapshotsRequestMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListTransferVolumeSnapshotsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WatchOnly

	if m.GetStartTime() == nil {
		err := ListTransferVolumeSnapshotsRequestValidationError{
			field:  "StartTime",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetEndTime() == nil {
		err := ListTransferVolumeSnapshotsRequestValidationError{
			field:  "EndTime",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListTransferVolumeSnapshotsRequestMultiError(errors)
	}
	return nil
}

// ListTransferVolumeSnapshotsRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListTransferVolumeSnapshotsRequest.Validate(true) if the designated
// constraints aren't met.
type ListTransferVolumeSnapshotsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransferVolumeSnapshotsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransferVolumeSnapshotsRequestMultiError) AllErrors() []error { return m }

// ListTransferVolumeSnapshotsRequestValidationError is the validation error
// returned by ListTransferVolumeSnapshotsRequest.Validate if the designated
// constraints aren't met.
type ListTransferVolumeSnapshotsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransferVolumeSnapshotsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransferVolumeSnapshotsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransferVolumeSnapshotsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransferVolumeSnapshotsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransferVolumeSnapshotsRequestValidationError) ErrorName() string {
	return "ListTransferVolumeSnapshotsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransferVolumeSnapshotsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransferVolumeSnapshotsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransferVolumeSnapshotsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransferVolumeSnapshotsRequestValidationError{}

// Validate checks the field values on ListTransferVolumeSnapshotsResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListTransferVolumeSnapshotsResponseMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListTransferVolumeSnapshotsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetTransferVolumeSnapshots()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListTransferVolumeSnapshotsResponseValidationError{
				field:  "TransferVolumeSnapshots",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ListTransferVolumeSnapshotsResponseMultiError(errors)
	}
	return nil
}

// ListTransferVolumeSnapshotsResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListTransferVolumeSnapshotsResponse.Validate(true) if the designated
// constraints aren't met.
type ListTransferVolumeSnapshotsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransferVolumeSnapshotsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransferVolumeSnapshotsResponseMultiError) AllErrors() []error { return m }

// ListTransferVolumeSnapshotsResponseValidationError is the validation error
// returned by ListTransferVolumeSnapshotsResponse.Validate if the designated
// constraints aren't met.
type ListTransferVolumeSnapshotsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransferVolumeSnapshotsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransferVolumeSnapshotsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransferVolumeSnapshotsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransferVolumeSnapshotsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransferVolumeSnapshotsResponseValidationError) ErrorName() string {
	return "ListTransferVolumeSnapshotsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransferVolumeSnapshotsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransferVolumeSnapshotsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransferVolumeSnapshotsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransferVolumeSnapshotsResponseValidationError{}

// Validate checks the field values on ListWalletTransferVolumeSnapshotsRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in
// ListWalletTransferVolumeSnapshotsRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListWalletTransferVolumeSnapshotsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWalletIds() {
		_, _ = idx, item

		if !_ListWalletTransferVolumeSnapshotsRequest_WalletIds_Pattern.MatchString(item) {
			err := ListWalletTransferVolumeSnapshotsRequestValidationError{
				field:  fmt.Sprintf("WalletIds[%v]", idx),
				reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.GetStartTime() == nil {
		err := ListWalletTransferVolumeSnapshotsRequestValidationError{
			field:  "StartTime",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetEndTime() == nil {
		err := ListWalletTransferVolumeSnapshotsRequestValidationError{
			field:  "EndTime",
			reason: "value is required",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListWalletTransferVolumeSnapshotsRequestMultiError(errors)
	}
	return nil
}

// ListWalletTransferVolumeSnapshotsRequestMultiError is an error wrapping
// multiple validation errors returned by
// ListWalletTransferVolumeSnapshotsRequest.Validate(true) if the designated
// constraints aren't met.
type ListWalletTransferVolumeSnapshotsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletTransferVolumeSnapshotsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletTransferVolumeSnapshotsRequestMultiError) AllErrors() []error { return m }

// ListWalletTransferVolumeSnapshotsRequestValidationError is the validation
// error returned by ListWalletTransferVolumeSnapshotsRequest.Validate if the
// designated constraints aren't met.
type ListWalletTransferVolumeSnapshotsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletTransferVolumeSnapshotsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletTransferVolumeSnapshotsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletTransferVolumeSnapshotsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletTransferVolumeSnapshotsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletTransferVolumeSnapshotsRequestValidationError) ErrorName() string {
	return "ListWalletTransferVolumeSnapshotsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletTransferVolumeSnapshotsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletTransferVolumeSnapshotsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletTransferVolumeSnapshotsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletTransferVolumeSnapshotsRequestValidationError{}

var _ListWalletTransferVolumeSnapshotsRequest_WalletIds_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on
// ListWalletTransferVolumeSnapshotsResponse with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// ListWalletTransferVolumeSnapshotsResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListWalletTransferVolumeSnapshotsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetWalletTransferVolumeSnapshots()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = ListWalletTransferVolumeSnapshotsResponseValidationError{
				field:  "WalletTransferVolumeSnapshots",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return ListWalletTransferVolumeSnapshotsResponseMultiError(errors)
	}
	return nil
}

// ListWalletTransferVolumeSnapshotsResponseMultiError is an error wrapping
// multiple validation errors returned by
// ListWalletTransferVolumeSnapshotsResponse.Validate(true) if the designated
// constraints aren't met.
type ListWalletTransferVolumeSnapshotsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletTransferVolumeSnapshotsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletTransferVolumeSnapshotsResponseMultiError) AllErrors() []error { return m }

// ListWalletTransferVolumeSnapshotsResponseValidationError is the validation
// error returned by ListWalletTransferVolumeSnapshotsResponse.Validate if the
// designated constraints aren't met.
type ListWalletTransferVolumeSnapshotsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletTransferVolumeSnapshotsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletTransferVolumeSnapshotsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletTransferVolumeSnapshotsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletTransferVolumeSnapshotsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletTransferVolumeSnapshotsResponseValidationError) ErrorName() string {
	return "ListWalletTransferVolumeSnapshotsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletTransferVolumeSnapshotsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletTransferVolumeSnapshotsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletTransferVolumeSnapshotsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletTransferVolumeSnapshotsResponseValidationError{}

// Validate checks the field values on CalculateFeeRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CalculateFeeRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CalculateFeeRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CalculateFeeRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := CalculateFeeRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = CalculateFeeRequestValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for Address

	// no validation rules for DestinationTag

	// no validation rules for StringValue

	if v, ok := interface{}(m.GetSubstrateSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CalculateFeeRequestValidationError{
				field:  "SubstrateSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetNemSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CalculateFeeRequestValidationError{
				field:  "NemSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetSymbolSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CalculateFeeRequestValidationError{
				field:  "SymbolSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetEthereumSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CalculateFeeRequestValidationError{
				field:  "EthereumSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return CalculateFeeRequestMultiError(errors)
	}
	return nil
}

// CalculateFeeRequestMultiError is an error wrapping multiple validation
// errors returned by CalculateFeeRequest.Validate(true) if the designated
// constraints aren't met.
type CalculateFeeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CalculateFeeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CalculateFeeRequestMultiError) AllErrors() []error { return m }

// CalculateFeeRequestValidationError is the validation error returned by
// CalculateFeeRequest.Validate if the designated constraints aren't met.
type CalculateFeeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CalculateFeeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CalculateFeeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CalculateFeeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CalculateFeeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CalculateFeeRequestValidationError) ErrorName() string {
	return "CalculateFeeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CalculateFeeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCalculateFeeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CalculateFeeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CalculateFeeRequestValidationError{}

var _CalculateFeeRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on CalculateFeeSubstrateSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CalculateFeeSubstrateSpecificMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CalculateFeeSubstrateSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CallType

	// no validation rules for MultisigCallType

	if len(errors) > 0 {
		return CalculateFeeSubstrateSpecificMultiError(errors)
	}
	return nil
}

// CalculateFeeSubstrateSpecificMultiError is an error wrapping multiple
// validation errors returned by CalculateFeeSubstrateSpecific.Validate(true)
// if the designated constraints aren't met.
type CalculateFeeSubstrateSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CalculateFeeSubstrateSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CalculateFeeSubstrateSpecificMultiError) AllErrors() []error { return m }

// CalculateFeeSubstrateSpecificValidationError is the validation error
// returned by CalculateFeeSubstrateSpecific.Validate if the designated
// constraints aren't met.
type CalculateFeeSubstrateSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CalculateFeeSubstrateSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CalculateFeeSubstrateSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CalculateFeeSubstrateSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CalculateFeeSubstrateSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CalculateFeeSubstrateSpecificValidationError) ErrorName() string {
	return "CalculateFeeSubstrateSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CalculateFeeSubstrateSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCalculateFeeSubstrateSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CalculateFeeSubstrateSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CalculateFeeSubstrateSpecificValidationError{}

// Validate checks the field values on CalculateFeeNemSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CalculateFeeNemSpecificMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CalculateFeeNemSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return CalculateFeeNemSpecificMultiError(errors)
	}
	return nil
}

// CalculateFeeNemSpecificMultiError is an error wrapping multiple validation
// errors returned by CalculateFeeNemSpecific.Validate(true) if the designated
// constraints aren't met.
type CalculateFeeNemSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CalculateFeeNemSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CalculateFeeNemSpecificMultiError) AllErrors() []error { return m }

// CalculateFeeNemSpecificValidationError is the validation error returned by
// CalculateFeeNemSpecific.Validate if the designated constraints aren't met.
type CalculateFeeNemSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CalculateFeeNemSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CalculateFeeNemSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CalculateFeeNemSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CalculateFeeNemSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CalculateFeeNemSpecificValidationError) ErrorName() string {
	return "CalculateFeeNemSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CalculateFeeNemSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCalculateFeeNemSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CalculateFeeNemSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CalculateFeeNemSpecificValidationError{}

// Validate checks the field values on CalculateFeeSymbolSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CalculateFeeSymbolSpecificMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CalculateFeeSymbolSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	if len(errors) > 0 {
		return CalculateFeeSymbolSpecificMultiError(errors)
	}
	return nil
}

// CalculateFeeSymbolSpecificMultiError is an error wrapping multiple
// validation errors returned by CalculateFeeSymbolSpecific.Validate(true) if
// the designated constraints aren't met.
type CalculateFeeSymbolSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CalculateFeeSymbolSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CalculateFeeSymbolSpecificMultiError) AllErrors() []error { return m }

// CalculateFeeSymbolSpecificValidationError is the validation error returned
// by CalculateFeeSymbolSpecific.Validate if the designated constraints aren't met.
type CalculateFeeSymbolSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CalculateFeeSymbolSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CalculateFeeSymbolSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CalculateFeeSymbolSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CalculateFeeSymbolSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CalculateFeeSymbolSpecificValidationError) ErrorName() string {
	return "CalculateFeeSymbolSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CalculateFeeSymbolSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCalculateFeeSymbolSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CalculateFeeSymbolSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CalculateFeeSymbolSpecificValidationError{}

// Validate checks the field values on CalculateFeeEthereumSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CalculateFeeEthereumSpecificMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CalculateFeeEthereumSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CalculateFeeEthereumSpecific_Data_Pattern.MatchString(m.GetData()) {
		err := CalculateFeeEthereumSpecificValidationError{
			field:  "Data",
			reason: "value does not match regex pattern \"^0x[0-9a-fA-F]*$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CalculateFeeEthereumSpecificMultiError(errors)
	}
	return nil
}

// CalculateFeeEthereumSpecificMultiError is an error wrapping multiple
// validation errors returned by CalculateFeeEthereumSpecific.Validate(true)
// if the designated constraints aren't met.
type CalculateFeeEthereumSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CalculateFeeEthereumSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CalculateFeeEthereumSpecificMultiError) AllErrors() []error { return m }

// CalculateFeeEthereumSpecificValidationError is the validation error returned
// by CalculateFeeEthereumSpecific.Validate if the designated constraints
// aren't met.
type CalculateFeeEthereumSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CalculateFeeEthereumSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CalculateFeeEthereumSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CalculateFeeEthereumSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CalculateFeeEthereumSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CalculateFeeEthereumSpecificValidationError) ErrorName() string {
	return "CalculateFeeEthereumSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CalculateFeeEthereumSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCalculateFeeEthereumSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CalculateFeeEthereumSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CalculateFeeEthereumSpecificValidationError{}

var _CalculateFeeEthereumSpecific_Data_Pattern = regexp.MustCompile("^0x[0-9a-fA-F]*$")

// Validate checks the field values on CalculateFeeResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CalculateFeeResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CalculateFeeResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Fee

	// no validation rules for StringFee

	if len(errors) > 0 {
		return CalculateFeeResponseMultiError(errors)
	}
	return nil
}

// CalculateFeeResponseMultiError is an error wrapping multiple validation
// errors returned by CalculateFeeResponse.Validate(true) if the designated
// constraints aren't met.
type CalculateFeeResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CalculateFeeResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CalculateFeeResponseMultiError) AllErrors() []error { return m }

// CalculateFeeResponseValidationError is the validation error returned by
// CalculateFeeResponse.Validate if the designated constraints aren't met.
type CalculateFeeResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CalculateFeeResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CalculateFeeResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CalculateFeeResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CalculateFeeResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CalculateFeeResponseValidationError) ErrorName() string {
	return "CalculateFeeResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CalculateFeeResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCalculateFeeResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CalculateFeeResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CalculateFeeResponseValidationError{}

// Validate checks the field values on GetMembersDeactivatabilitiesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in GetMembersDeactivatabilitiesRequestMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *GetMembersDeactivatabilitiesRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetMembersDeactivatabilitiesRequestMultiError(errors)
	}
	return nil
}

// GetMembersDeactivatabilitiesRequestMultiError is an error wrapping multiple
// validation errors returned by
// GetMembersDeactivatabilitiesRequest.Validate(true) if the designated
// constraints aren't met.
type GetMembersDeactivatabilitiesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMembersDeactivatabilitiesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMembersDeactivatabilitiesRequestMultiError) AllErrors() []error { return m }

// GetMembersDeactivatabilitiesRequestValidationError is the validation error
// returned by GetMembersDeactivatabilitiesRequest.Validate if the designated
// constraints aren't met.
type GetMembersDeactivatabilitiesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMembersDeactivatabilitiesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMembersDeactivatabilitiesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMembersDeactivatabilitiesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMembersDeactivatabilitiesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMembersDeactivatabilitiesRequestValidationError) ErrorName() string {
	return "GetMembersDeactivatabilitiesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetMembersDeactivatabilitiesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMembersDeactivatabilitiesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMembersDeactivatabilitiesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMembersDeactivatabilitiesRequestValidationError{}

// Validate checks the field values on GetMembersDeactivatabilitiesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in GetMembersDeactivatabilitiesResponseMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *GetMembersDeactivatabilitiesResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetDeactivatabilities() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = GetMembersDeactivatabilitiesResponseValidationError{
					field:  fmt.Sprintf("Deactivatabilities[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return GetMembersDeactivatabilitiesResponseMultiError(errors)
	}
	return nil
}

// GetMembersDeactivatabilitiesResponseMultiError is an error wrapping multiple
// validation errors returned by
// GetMembersDeactivatabilitiesResponse.Validate(true) if the designated
// constraints aren't met.
type GetMembersDeactivatabilitiesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetMembersDeactivatabilitiesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetMembersDeactivatabilitiesResponseMultiError) AllErrors() []error { return m }

// GetMembersDeactivatabilitiesResponseValidationError is the validation error
// returned by GetMembersDeactivatabilitiesResponse.Validate if the designated
// constraints aren't met.
type GetMembersDeactivatabilitiesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetMembersDeactivatabilitiesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetMembersDeactivatabilitiesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetMembersDeactivatabilitiesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetMembersDeactivatabilitiesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetMembersDeactivatabilitiesResponseValidationError) ErrorName() string {
	return "GetMembersDeactivatabilitiesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetMembersDeactivatabilitiesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetMembersDeactivatabilitiesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetMembersDeactivatabilitiesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetMembersDeactivatabilitiesResponseValidationError{}

// Validate checks the field values on GetRecommendedFeeRateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetRecommendedFeeRateRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *GetRecommendedFeeRateRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _GetRecommendedFeeRateRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := GetRecommendedFeeRateRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := GetRecommendedFeeRateRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetRecommendedFeeRateRequestMultiError(errors)
	}
	return nil
}

// GetRecommendedFeeRateRequestMultiError is an error wrapping multiple
// validation errors returned by GetRecommendedFeeRateRequest.Validate(true)
// if the designated constraints aren't met.
type GetRecommendedFeeRateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRecommendedFeeRateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRecommendedFeeRateRequestMultiError) AllErrors() []error { return m }

// GetRecommendedFeeRateRequestValidationError is the validation error returned
// by GetRecommendedFeeRateRequest.Validate if the designated constraints
// aren't met.
type GetRecommendedFeeRateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRecommendedFeeRateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRecommendedFeeRateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRecommendedFeeRateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRecommendedFeeRateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRecommendedFeeRateRequestValidationError) ErrorName() string {
	return "GetRecommendedFeeRateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetRecommendedFeeRateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRecommendedFeeRateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRecommendedFeeRateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRecommendedFeeRateRequestValidationError{}

var _GetRecommendedFeeRateRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

// Validate checks the field values on GetRecommendedFeeRateResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetRecommendedFeeRateResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *GetRecommendedFeeRateResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Fastest

	// no validation rules for Fast

	// no validation rules for Average

	// no validation rules for SafeLow

	if len(errors) > 0 {
		return GetRecommendedFeeRateResponseMultiError(errors)
	}
	return nil
}

// GetRecommendedFeeRateResponseMultiError is an error wrapping multiple
// validation errors returned by GetRecommendedFeeRateResponse.Validate(true)
// if the designated constraints aren't met.
type GetRecommendedFeeRateResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetRecommendedFeeRateResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetRecommendedFeeRateResponseMultiError) AllErrors() []error { return m }

// GetRecommendedFeeRateResponseValidationError is the validation error
// returned by GetRecommendedFeeRateResponse.Validate if the designated
// constraints aren't met.
type GetRecommendedFeeRateResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetRecommendedFeeRateResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetRecommendedFeeRateResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetRecommendedFeeRateResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetRecommendedFeeRateResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetRecommendedFeeRateResponseValidationError) ErrorName() string {
	return "GetRecommendedFeeRateResponseValidationError"
}

// Error satisfies the builtin error interface
func (e GetRecommendedFeeRateResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetRecommendedFeeRateResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetRecommendedFeeRateResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetRecommendedFeeRateResponseValidationError{}

// Validate checks the field values on ValidateAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ValidateAddressRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ValidateAddressRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _ValidateAddressRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := ValidateAddressRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := ValidateAddressRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAddress()) < 25 {
		err := ValidateAddressRequestValidationError{
			field:  "Address",
			reason: "value length must be at least 25 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ValidateAddressRequestMultiError(errors)
	}
	return nil
}

// ValidateAddressRequestMultiError is an error wrapping multiple validation
// errors returned by ValidateAddressRequest.Validate(true) if the designated
// constraints aren't met.
type ValidateAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidateAddressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidateAddressRequestMultiError) AllErrors() []error { return m }

// ValidateAddressRequestValidationError is the validation error returned by
// ValidateAddressRequest.Validate if the designated constraints aren't met.
type ValidateAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidateAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidateAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidateAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidateAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidateAddressRequestValidationError) ErrorName() string {
	return "ValidateAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ValidateAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidateAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidateAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidateAddressRequestValidationError{}

var _ValidateAddressRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

// Validate checks the field values on ValidateAddressResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ValidateAddressResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ValidateAddressResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Valid

	if len(errors) > 0 {
		return ValidateAddressResponseMultiError(errors)
	}
	return nil
}

// ValidateAddressResponseMultiError is an error wrapping multiple validation
// errors returned by ValidateAddressResponse.Validate(true) if the designated
// constraints aren't met.
type ValidateAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ValidateAddressResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ValidateAddressResponseMultiError) AllErrors() []error { return m }

// ValidateAddressResponseValidationError is the validation error returned by
// ValidateAddressResponse.Validate if the designated constraints aren't met.
type ValidateAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ValidateAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ValidateAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ValidateAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ValidateAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ValidateAddressResponseValidationError) ErrorName() string {
	return "ValidateAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ValidateAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sValidateAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ValidateAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ValidateAddressResponseValidationError{}

// Validate checks the field values on ListConfirmationsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListConfirmationsRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListConfirmationsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListConfirmationsRequestMultiError(errors)
	}
	return nil
}

// ListConfirmationsRequestMultiError is an error wrapping multiple validation
// errors returned by ListConfirmationsRequest.Validate(true) if the
// designated constraints aren't met.
type ListConfirmationsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListConfirmationsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListConfirmationsRequestMultiError) AllErrors() []error { return m }

// ListConfirmationsRequestValidationError is the validation error returned by
// ListConfirmationsRequest.Validate if the designated constraints aren't met.
type ListConfirmationsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListConfirmationsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListConfirmationsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListConfirmationsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListConfirmationsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListConfirmationsRequestValidationError) ErrorName() string {
	return "ListConfirmationsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListConfirmationsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListConfirmationsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListConfirmationsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListConfirmationsRequestValidationError{}

// Validate checks the field values on ListConfirmationsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListConfirmationsResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListConfirmationsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetConfirmations() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListConfirmationsResponseValidationError{
					field:  fmt.Sprintf("Confirmations[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListConfirmationsResponseMultiError(errors)
	}
	return nil
}

// ListConfirmationsResponseMultiError is an error wrapping multiple validation
// errors returned by ListConfirmationsResponse.Validate(true) if the
// designated constraints aren't met.
type ListConfirmationsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListConfirmationsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListConfirmationsResponseMultiError) AllErrors() []error { return m }

// ListConfirmationsResponseValidationError is the validation error returned by
// ListConfirmationsResponse.Validate if the designated constraints aren't met.
type ListConfirmationsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListConfirmationsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListConfirmationsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListConfirmationsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListConfirmationsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListConfirmationsResponseValidationError) ErrorName() string {
	return "ListConfirmationsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListConfirmationsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListConfirmationsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListConfirmationsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListConfirmationsResponseValidationError{}

// Validate checks the field values on ListAuditLogsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListAuditLogsRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListAuditLogsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AuditLogGroup

	if !_ListAuditLogsRequest_AccountId_Pattern.MatchString(m.GetAccountId()) {
		err := ListAuditLogsRequestValidationError{
			field:  "AccountId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetPageSize() > 100 {
		err := ListAuditLogsRequestValidationError{
			field:  "PageSize",
			reason: "value must be less than or equal to 100",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ListAuditLogsRequest_PageToken_Pattern.MatchString(m.GetPageToken()) {
		err := ListAuditLogsRequestValidationError{
			field:  "PageToken",
			reason: "value does not match regex pattern \"^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListAuditLogsRequestMultiError(errors)
	}
	return nil
}

// ListAuditLogsRequestMultiError is an error wrapping multiple validation
// errors returned by ListAuditLogsRequest.Validate(true) if the designated
// constraints aren't met.
type ListAuditLogsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAuditLogsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAuditLogsRequestMultiError) AllErrors() []error { return m }

// ListAuditLogsRequestValidationError is the validation error returned by
// ListAuditLogsRequest.Validate if the designated constraints aren't met.
type ListAuditLogsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAuditLogsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAuditLogsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAuditLogsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAuditLogsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAuditLogsRequestValidationError) ErrorName() string {
	return "ListAuditLogsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListAuditLogsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAuditLogsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAuditLogsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAuditLogsRequestValidationError{}

var _ListAuditLogsRequest_AccountId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ListAuditLogsRequest_PageToken_Pattern = regexp.MustCompile("^$|^[ABCDEFGHIJKLMNOPQRSTUVWXYZ234567]{16}$")

// Validate checks the field values on ListAuditLogsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListAuditLogsResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListAuditLogsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAuditLogs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListAuditLogsResponseValidationError{
					field:  fmt.Sprintf("AuditLogs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for NextPageToken

	if len(errors) > 0 {
		return ListAuditLogsResponseMultiError(errors)
	}
	return nil
}

// ListAuditLogsResponseMultiError is an error wrapping multiple validation
// errors returned by ListAuditLogsResponse.Validate(true) if the designated
// constraints aren't met.
type ListAuditLogsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListAuditLogsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListAuditLogsResponseMultiError) AllErrors() []error { return m }

// ListAuditLogsResponseValidationError is the validation error returned by
// ListAuditLogsResponse.Validate if the designated constraints aren't met.
type ListAuditLogsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListAuditLogsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListAuditLogsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListAuditLogsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListAuditLogsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListAuditLogsResponseValidationError) ErrorName() string {
	return "ListAuditLogsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListAuditLogsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListAuditLogsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListAuditLogsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListAuditLogsResponseValidationError{}

// Validate checks the field values on CreateLabeledAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateLabeledAddressRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CreateLabeledAddressRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := CreateLabeledAddressRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateLabeledAddressRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := CreateLabeledAddressRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := CreateLabeledAddressRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAddress()) < 25 {
		err := CreateLabeledAddressRequestValidationError{
			field:  "Address",
			reason: "value length must be at least 25 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreateLabeledAddressRequestMultiError(errors)
	}
	return nil
}

// CreateLabeledAddressRequestMultiError is an error wrapping multiple
// validation errors returned by CreateLabeledAddressRequest.Validate(true) if
// the designated constraints aren't met.
type CreateLabeledAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLabeledAddressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLabeledAddressRequestMultiError) AllErrors() []error { return m }

// CreateLabeledAddressRequestValidationError is the validation error returned
// by CreateLabeledAddressRequest.Validate if the designated constraints
// aren't met.
type CreateLabeledAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLabeledAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLabeledAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLabeledAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLabeledAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLabeledAddressRequestValidationError) ErrorName() string {
	return "CreateLabeledAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLabeledAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLabeledAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLabeledAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLabeledAddressRequestValidationError{}

var _CreateLabeledAddressRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

// Validate checks the field values on CreateLabeledAddressResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateLabeledAddressResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CreateLabeledAddressResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LabeledAddressId

	if len(errors) > 0 {
		return CreateLabeledAddressResponseMultiError(errors)
	}
	return nil
}

// CreateLabeledAddressResponseMultiError is an error wrapping multiple
// validation errors returned by CreateLabeledAddressResponse.Validate(true)
// if the designated constraints aren't met.
type CreateLabeledAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateLabeledAddressResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateLabeledAddressResponseMultiError) AllErrors() []error { return m }

// CreateLabeledAddressResponseValidationError is the validation error returned
// by CreateLabeledAddressResponse.Validate if the designated constraints
// aren't met.
type CreateLabeledAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateLabeledAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateLabeledAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateLabeledAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateLabeledAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateLabeledAddressResponseValidationError) ErrorName() string {
	return "CreateLabeledAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateLabeledAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateLabeledAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateLabeledAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateLabeledAddressResponseValidationError{}

// Validate checks the field values on UpdateLabeledAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateLabeledAddressRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UpdateLabeledAddressRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateLabeledAddressRequest_LabeledAddressId_Pattern.MatchString(m.GetLabeledAddressId()) {
		err := UpdateLabeledAddressRequestValidationError{
			field:  "LabeledAddressId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := UpdateLabeledAddressRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateLabeledAddressRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := UpdateLabeledAddressRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := UpdateLabeledAddressRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetAddress()) < 25 {
		err := UpdateLabeledAddressRequestValidationError{
			field:  "Address",
			reason: "value length must be at least 25 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateLabeledAddressRequestMultiError(errors)
	}
	return nil
}

// UpdateLabeledAddressRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateLabeledAddressRequest.Validate(true) if
// the designated constraints aren't met.
type UpdateLabeledAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateLabeledAddressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateLabeledAddressRequestMultiError) AllErrors() []error { return m }

// UpdateLabeledAddressRequestValidationError is the validation error returned
// by UpdateLabeledAddressRequest.Validate if the designated constraints
// aren't met.
type UpdateLabeledAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateLabeledAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateLabeledAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateLabeledAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateLabeledAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateLabeledAddressRequestValidationError) ErrorName() string {
	return "UpdateLabeledAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateLabeledAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateLabeledAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateLabeledAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateLabeledAddressRequestValidationError{}

var _UpdateLabeledAddressRequest_LabeledAddressId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _UpdateLabeledAddressRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

// Validate checks the field values on GetLabeledAddressRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetLabeledAddressRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *GetLabeledAddressRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetLabeledAddressRequest_LabeledAddressId_Pattern.MatchString(m.GetLabeledAddressId()) {
		err := GetLabeledAddressRequestValidationError{
			field:  "LabeledAddressId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetLabeledAddressRequestMultiError(errors)
	}
	return nil
}

// GetLabeledAddressRequestMultiError is an error wrapping multiple validation
// errors returned by GetLabeledAddressRequest.Validate(true) if the
// designated constraints aren't met.
type GetLabeledAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetLabeledAddressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetLabeledAddressRequestMultiError) AllErrors() []error { return m }

// GetLabeledAddressRequestValidationError is the validation error returned by
// GetLabeledAddressRequest.Validate if the designated constraints aren't met.
type GetLabeledAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetLabeledAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetLabeledAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetLabeledAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetLabeledAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetLabeledAddressRequestValidationError) ErrorName() string {
	return "GetLabeledAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetLabeledAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetLabeledAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetLabeledAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetLabeledAddressRequestValidationError{}

var _GetLabeledAddressRequest_LabeledAddressId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListLabeledAddressesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListLabeledAddressesRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListLabeledAddressesRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListLabeledAddressesRequestMultiError(errors)
	}
	return nil
}

// ListLabeledAddressesRequestMultiError is an error wrapping multiple
// validation errors returned by ListLabeledAddressesRequest.Validate(true) if
// the designated constraints aren't met.
type ListLabeledAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLabeledAddressesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLabeledAddressesRequestMultiError) AllErrors() []error { return m }

// ListLabeledAddressesRequestValidationError is the validation error returned
// by ListLabeledAddressesRequest.Validate if the designated constraints
// aren't met.
type ListLabeledAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLabeledAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLabeledAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLabeledAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLabeledAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLabeledAddressesRequestValidationError) ErrorName() string {
	return "ListLabeledAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListLabeledAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLabeledAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLabeledAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLabeledAddressesRequestValidationError{}

// Validate checks the field values on ListLabeledAddressesResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListLabeledAddressesResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListLabeledAddressesResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListLabeledAddressesResponseValidationError{
					field:  fmt.Sprintf("Addresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListLabeledAddressesResponseMultiError(errors)
	}
	return nil
}

// ListLabeledAddressesResponseMultiError is an error wrapping multiple
// validation errors returned by ListLabeledAddressesResponse.Validate(true)
// if the designated constraints aren't met.
type ListLabeledAddressesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListLabeledAddressesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListLabeledAddressesResponseMultiError) AllErrors() []error { return m }

// ListLabeledAddressesResponseValidationError is the validation error returned
// by ListLabeledAddressesResponse.Validate if the designated constraints
// aren't met.
type ListLabeledAddressesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListLabeledAddressesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListLabeledAddressesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListLabeledAddressesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListLabeledAddressesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListLabeledAddressesResponseValidationError) ErrorName() string {
	return "ListLabeledAddressesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListLabeledAddressesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListLabeledAddressesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListLabeledAddressesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListLabeledAddressesResponseValidationError{}

// Validate checks the field values on DeleteLabeledAddressRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeleteLabeledAddressRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *DeleteLabeledAddressRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_DeleteLabeledAddressRequest_LabeledAddressId_Pattern.MatchString(m.GetLabeledAddressId()) {
		err := DeleteLabeledAddressRequestValidationError{
			field:  "LabeledAddressId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteLabeledAddressRequestMultiError(errors)
	}
	return nil
}

// DeleteLabeledAddressRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteLabeledAddressRequest.Validate(true) if
// the designated constraints aren't met.
type DeleteLabeledAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteLabeledAddressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteLabeledAddressRequestMultiError) AllErrors() []error { return m }

// DeleteLabeledAddressRequestValidationError is the validation error returned
// by DeleteLabeledAddressRequest.Validate if the designated constraints
// aren't met.
type DeleteLabeledAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteLabeledAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteLabeledAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteLabeledAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteLabeledAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteLabeledAddressRequestValidationError) ErrorName() string {
	return "DeleteLabeledAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteLabeledAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteLabeledAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteLabeledAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteLabeledAddressRequestValidationError{}

var _DeleteLabeledAddressRequest_LabeledAddressId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ReviewLabeledAddressProposalRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ReviewLabeledAddressProposalRequestMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ReviewLabeledAddressProposalRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ReviewLabeledAddressProposalRequest_LabeledAddressId_Pattern.MatchString(m.GetLabeledAddressId()) {
		err := ReviewLabeledAddressProposalRequestValidationError{
			field:  "LabeledAddressId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Approve

	if len(errors) > 0 {
		return ReviewLabeledAddressProposalRequestMultiError(errors)
	}
	return nil
}

// ReviewLabeledAddressProposalRequestMultiError is an error wrapping multiple
// validation errors returned by
// ReviewLabeledAddressProposalRequest.Validate(true) if the designated
// constraints aren't met.
type ReviewLabeledAddressProposalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReviewLabeledAddressProposalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReviewLabeledAddressProposalRequestMultiError) AllErrors() []error { return m }

// ReviewLabeledAddressProposalRequestValidationError is the validation error
// returned by ReviewLabeledAddressProposalRequest.Validate if the designated
// constraints aren't met.
type ReviewLabeledAddressProposalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReviewLabeledAddressProposalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReviewLabeledAddressProposalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReviewLabeledAddressProposalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReviewLabeledAddressProposalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReviewLabeledAddressProposalRequestValidationError) ErrorName() string {
	return "ReviewLabeledAddressProposalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReviewLabeledAddressProposalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReviewLabeledAddressProposalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReviewLabeledAddressProposalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReviewLabeledAddressProposalRequestValidationError{}

var _ReviewLabeledAddressProposalRequest_LabeledAddressId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on CreateWhitelistRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateWhitelistRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CreateWhitelistRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := CreateWhitelistRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateWhitelistRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := CreateWhitelistRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := CreateWhitelistRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_CreateWhitelistRequest_AddressIds_Unique := make(map[string]struct{}, len(m.GetAddressIds()))

	for idx, item := range m.GetAddressIds() {
		_, _ = idx, item

		if _, exists := _CreateWhitelistRequest_AddressIds_Unique[item]; exists {
			err := CreateWhitelistRequestValidationError{
				field:  fmt.Sprintf("AddressIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_CreateWhitelistRequest_AddressIds_Unique[item] = struct{}{}
		}

		// no validation rules for AddressIds[idx]
	}

	if len(errors) > 0 {
		return CreateWhitelistRequestMultiError(errors)
	}
	return nil
}

// CreateWhitelistRequestMultiError is an error wrapping multiple validation
// errors returned by CreateWhitelistRequest.Validate(true) if the designated
// constraints aren't met.
type CreateWhitelistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWhitelistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWhitelistRequestMultiError) AllErrors() []error { return m }

// CreateWhitelistRequestValidationError is the validation error returned by
// CreateWhitelistRequest.Validate if the designated constraints aren't met.
type CreateWhitelistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWhitelistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWhitelistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWhitelistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWhitelistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWhitelistRequestValidationError) ErrorName() string {
	return "CreateWhitelistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWhitelistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWhitelistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWhitelistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWhitelistRequestValidationError{}

var _CreateWhitelistRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

// Validate checks the field values on CreateWhitelistResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateWhitelistResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CreateWhitelistResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WhitelistId

	if len(errors) > 0 {
		return CreateWhitelistResponseMultiError(errors)
	}
	return nil
}

// CreateWhitelistResponseMultiError is an error wrapping multiple validation
// errors returned by CreateWhitelistResponse.Validate(true) if the designated
// constraints aren't met.
type CreateWhitelistResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWhitelistResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWhitelistResponseMultiError) AllErrors() []error { return m }

// CreateWhitelistResponseValidationError is the validation error returned by
// CreateWhitelistResponse.Validate if the designated constraints aren't met.
type CreateWhitelistResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWhitelistResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWhitelistResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWhitelistResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWhitelistResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWhitelistResponseValidationError) ErrorName() string {
	return "CreateWhitelistResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWhitelistResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWhitelistResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWhitelistResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWhitelistResponseValidationError{}

// Validate checks the field values on GetWhitelistRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetWhitelistRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *GetWhitelistRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetWhitelistRequest_WhitelistId_Pattern.MatchString(m.GetWhitelistId()) {
		err := GetWhitelistRequestValidationError{
			field:  "WhitelistId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetWhitelistRequestMultiError(errors)
	}
	return nil
}

// GetWhitelistRequestMultiError is an error wrapping multiple validation
// errors returned by GetWhitelistRequest.Validate(true) if the designated
// constraints aren't met.
type GetWhitelistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetWhitelistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetWhitelistRequestMultiError) AllErrors() []error { return m }

// GetWhitelistRequestValidationError is the validation error returned by
// GetWhitelistRequest.Validate if the designated constraints aren't met.
type GetWhitelistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetWhitelistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetWhitelistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetWhitelistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetWhitelistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetWhitelistRequestValidationError) ErrorName() string {
	return "GetWhitelistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetWhitelistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetWhitelistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetWhitelistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetWhitelistRequestValidationError{}

var _GetWhitelistRequest_WhitelistId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListWhitelistsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListWhitelistsRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListWhitelistsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListWhitelistsRequestMultiError(errors)
	}
	return nil
}

// ListWhitelistsRequestMultiError is an error wrapping multiple validation
// errors returned by ListWhitelistsRequest.Validate(true) if the designated
// constraints aren't met.
type ListWhitelistsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWhitelistsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWhitelistsRequestMultiError) AllErrors() []error { return m }

// ListWhitelistsRequestValidationError is the validation error returned by
// ListWhitelistsRequest.Validate if the designated constraints aren't met.
type ListWhitelistsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWhitelistsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWhitelistsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWhitelistsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWhitelistsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWhitelistsRequestValidationError) ErrorName() string {
	return "ListWhitelistsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListWhitelistsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWhitelistsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWhitelistsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWhitelistsRequestValidationError{}

// Validate checks the field values on ListWhitelistsResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListWhitelistsResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListWhitelistsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWhitelists() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListWhitelistsResponseValidationError{
					field:  fmt.Sprintf("Whitelists[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListWhitelistsResponseMultiError(errors)
	}
	return nil
}

// ListWhitelistsResponseMultiError is an error wrapping multiple validation
// errors returned by ListWhitelistsResponse.Validate(true) if the designated
// constraints aren't met.
type ListWhitelistsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWhitelistsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWhitelistsResponseMultiError) AllErrors() []error { return m }

// ListWhitelistsResponseValidationError is the validation error returned by
// ListWhitelistsResponse.Validate if the designated constraints aren't met.
type ListWhitelistsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWhitelistsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWhitelistsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWhitelistsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWhitelistsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWhitelistsResponseValidationError) ErrorName() string {
	return "ListWhitelistsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListWhitelistsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWhitelistsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWhitelistsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWhitelistsResponseValidationError{}

// Validate checks the field values on UpdateWhitelistRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateWhitelistRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UpdateWhitelistRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateWhitelistRequest_WhitelistId_Pattern.MatchString(m.GetWhitelistId()) {
		err := UpdateWhitelistRequestValidationError{
			field:  "WhitelistId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := UpdateWhitelistRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _UpdateWhitelistRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := UpdateWhitelistRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := UpdateWhitelistRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_UpdateWhitelistRequest_AddressIds_Unique := make(map[string]struct{}, len(m.GetAddressIds()))

	for idx, item := range m.GetAddressIds() {
		_, _ = idx, item

		if _, exists := _UpdateWhitelistRequest_AddressIds_Unique[item]; exists {
			err := UpdateWhitelistRequestValidationError{
				field:  fmt.Sprintf("AddressIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_UpdateWhitelistRequest_AddressIds_Unique[item] = struct{}{}
		}

		// no validation rules for AddressIds[idx]
	}

	if len(errors) > 0 {
		return UpdateWhitelistRequestMultiError(errors)
	}
	return nil
}

// UpdateWhitelistRequestMultiError is an error wrapping multiple validation
// errors returned by UpdateWhitelistRequest.Validate(true) if the designated
// constraints aren't met.
type UpdateWhitelistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWhitelistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWhitelistRequestMultiError) AllErrors() []error { return m }

// UpdateWhitelistRequestValidationError is the validation error returned by
// UpdateWhitelistRequest.Validate if the designated constraints aren't met.
type UpdateWhitelistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWhitelistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWhitelistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWhitelistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWhitelistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWhitelistRequestValidationError) ErrorName() string {
	return "UpdateWhitelistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWhitelistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWhitelistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWhitelistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWhitelistRequestValidationError{}

var _UpdateWhitelistRequest_WhitelistId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _UpdateWhitelistRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

// Validate checks the field values on UpdateWhitelistAddressesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateWhitelistAddressesRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UpdateWhitelistAddressesRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateWhitelistAddressesRequest_WhitelistId_Pattern.MatchString(m.GetWhitelistId()) {
		err := UpdateWhitelistAddressesRequestValidationError{
			field:  "WhitelistId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	_UpdateWhitelistAddressesRequest_AddressIds_Unique := make(map[string]struct{}, len(m.GetAddressIds()))

	for idx, item := range m.GetAddressIds() {
		_, _ = idx, item

		if _, exists := _UpdateWhitelistAddressesRequest_AddressIds_Unique[item]; exists {
			err := UpdateWhitelistAddressesRequestValidationError{
				field:  fmt.Sprintf("AddressIds[%v]", idx),
				reason: "repeated value must contain unique items",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		} else {
			_UpdateWhitelistAddressesRequest_AddressIds_Unique[item] = struct{}{}
		}

		// no validation rules for AddressIds[idx]
	}

	if len(errors) > 0 {
		return UpdateWhitelistAddressesRequestMultiError(errors)
	}
	return nil
}

// UpdateWhitelistAddressesRequestMultiError is an error wrapping multiple
// validation errors returned by
// UpdateWhitelistAddressesRequest.Validate(true) if the designated
// constraints aren't met.
type UpdateWhitelistAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateWhitelistAddressesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateWhitelistAddressesRequestMultiError) AllErrors() []error { return m }

// UpdateWhitelistAddressesRequestValidationError is the validation error
// returned by UpdateWhitelistAddressesRequest.Validate if the designated
// constraints aren't met.
type UpdateWhitelistAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateWhitelistAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateWhitelistAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateWhitelistAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateWhitelistAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateWhitelistAddressesRequestValidationError) ErrorName() string {
	return "UpdateWhitelistAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateWhitelistAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateWhitelistAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateWhitelistAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateWhitelistAddressesRequestValidationError{}

var _UpdateWhitelistAddressesRequest_WhitelistId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on DeleteWhitelistRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeleteWhitelistRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DeleteWhitelistRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_DeleteWhitelistRequest_WhitelistId_Pattern.MatchString(m.GetWhitelistId()) {
		err := DeleteWhitelistRequestValidationError{
			field:  "WhitelistId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteWhitelistRequestMultiError(errors)
	}
	return nil
}

// DeleteWhitelistRequestMultiError is an error wrapping multiple validation
// errors returned by DeleteWhitelistRequest.Validate(true) if the designated
// constraints aren't met.
type DeleteWhitelistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteWhitelistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteWhitelistRequestMultiError) AllErrors() []error { return m }

// DeleteWhitelistRequestValidationError is the validation error returned by
// DeleteWhitelistRequest.Validate if the designated constraints aren't met.
type DeleteWhitelistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteWhitelistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteWhitelistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteWhitelistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteWhitelistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteWhitelistRequestValidationError) ErrorName() string {
	return "DeleteWhitelistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteWhitelistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteWhitelistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteWhitelistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteWhitelistRequestValidationError{}

var _DeleteWhitelistRequest_WhitelistId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on CreateTransferLimitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateTransferLimitRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CreateTransferLimitRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := CreateTransferLimitRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateTransferLimitRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := CreateTransferLimitRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := CreateTransferLimitRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTransferLimits()) < 1 {
		err := CreateTransferLimitRequestValidationError{
			field:  "TransferLimits",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTransferLimits() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = CreateTransferLimitRequestValidationError{
					field:  fmt.Sprintf("TransferLimits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return CreateTransferLimitRequestMultiError(errors)
	}
	return nil
}

// CreateTransferLimitRequestMultiError is an error wrapping multiple
// validation errors returned by CreateTransferLimitRequest.Validate(true) if
// the designated constraints aren't met.
type CreateTransferLimitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransferLimitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransferLimitRequestMultiError) AllErrors() []error { return m }

// CreateTransferLimitRequestValidationError is the validation error returned
// by CreateTransferLimitRequest.Validate if the designated constraints aren't met.
type CreateTransferLimitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransferLimitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransferLimitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransferLimitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransferLimitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransferLimitRequestValidationError) ErrorName() string {
	return "CreateTransferLimitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransferLimitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransferLimitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransferLimitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransferLimitRequestValidationError{}

var _CreateTransferLimitRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

// Validate checks the field values on CreateTransferLimitResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateTransferLimitResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CreateTransferLimitResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferLimitId

	if len(errors) > 0 {
		return CreateTransferLimitResponseMultiError(errors)
	}
	return nil
}

// CreateTransferLimitResponseMultiError is an error wrapping multiple
// validation errors returned by CreateTransferLimitResponse.Validate(true) if
// the designated constraints aren't met.
type CreateTransferLimitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransferLimitResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransferLimitResponseMultiError) AllErrors() []error { return m }

// CreateTransferLimitResponseValidationError is the validation error returned
// by CreateTransferLimitResponse.Validate if the designated constraints
// aren't met.
type CreateTransferLimitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransferLimitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransferLimitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransferLimitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransferLimitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransferLimitResponseValidationError) ErrorName() string {
	return "CreateTransferLimitResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransferLimitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransferLimitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransferLimitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransferLimitResponseValidationError{}

// Validate checks the field values on GetTransferLimitRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetTransferLimitRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *GetTransferLimitRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetTransferLimitRequest_TransferLimitId_Pattern.MatchString(m.GetTransferLimitId()) {
		err := GetTransferLimitRequestValidationError{
			field:  "TransferLimitId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetTransferLimitRequestMultiError(errors)
	}
	return nil
}

// GetTransferLimitRequestMultiError is an error wrapping multiple validation
// errors returned by GetTransferLimitRequest.Validate(true) if the designated
// constraints aren't met.
type GetTransferLimitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetTransferLimitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetTransferLimitRequestMultiError) AllErrors() []error { return m }

// GetTransferLimitRequestValidationError is the validation error returned by
// GetTransferLimitRequest.Validate if the designated constraints aren't met.
type GetTransferLimitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetTransferLimitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetTransferLimitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetTransferLimitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetTransferLimitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetTransferLimitRequestValidationError) ErrorName() string {
	return "GetTransferLimitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetTransferLimitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetTransferLimitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetTransferLimitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetTransferLimitRequestValidationError{}

var _GetTransferLimitRequest_TransferLimitId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListTransferLimitsRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListTransferLimitsRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListTransferLimitsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListTransferLimitsRequestMultiError(errors)
	}
	return nil
}

// ListTransferLimitsRequestMultiError is an error wrapping multiple validation
// errors returned by ListTransferLimitsRequest.Validate(true) if the
// designated constraints aren't met.
type ListTransferLimitsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransferLimitsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransferLimitsRequestMultiError) AllErrors() []error { return m }

// ListTransferLimitsRequestValidationError is the validation error returned by
// ListTransferLimitsRequest.Validate if the designated constraints aren't met.
type ListTransferLimitsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransferLimitsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransferLimitsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransferLimitsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransferLimitsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransferLimitsRequestValidationError) ErrorName() string {
	return "ListTransferLimitsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransferLimitsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransferLimitsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransferLimitsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransferLimitsRequestValidationError{}

// Validate checks the field values on ListTransferLimitsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListTransferLimitsResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListTransferLimitsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransferLimits() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListTransferLimitsResponseValidationError{
					field:  fmt.Sprintf("TransferLimits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListTransferLimitsResponseMultiError(errors)
	}
	return nil
}

// ListTransferLimitsResponseMultiError is an error wrapping multiple
// validation errors returned by ListTransferLimitsResponse.Validate(true) if
// the designated constraints aren't met.
type ListTransferLimitsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransferLimitsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransferLimitsResponseMultiError) AllErrors() []error { return m }

// ListTransferLimitsResponseValidationError is the validation error returned
// by ListTransferLimitsResponse.Validate if the designated constraints aren't met.
type ListTransferLimitsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransferLimitsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransferLimitsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransferLimitsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransferLimitsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransferLimitsResponseValidationError) ErrorName() string {
	return "ListTransferLimitsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransferLimitsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransferLimitsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransferLimitsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransferLimitsResponseValidationError{}

// Validate checks the field values on UpdateTransferLimitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateTransferLimitRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UpdateTransferLimitRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateTransferLimitRequest_TransferLimitId_Pattern.MatchString(m.GetTransferLimitId()) {
		err := UpdateTransferLimitRequestValidationError{
			field:  "TransferLimitId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetTransferLimits()) < 1 {
		err := UpdateTransferLimitRequestValidationError{
			field:  "TransferLimits",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetTransferLimits() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = UpdateTransferLimitRequestValidationError{
					field:  fmt.Sprintf("TransferLimits[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return UpdateTransferLimitRequestMultiError(errors)
	}
	return nil
}

// UpdateTransferLimitRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateTransferLimitRequest.Validate(true) if
// the designated constraints aren't met.
type UpdateTransferLimitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTransferLimitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTransferLimitRequestMultiError) AllErrors() []error { return m }

// UpdateTransferLimitRequestValidationError is the validation error returned
// by UpdateTransferLimitRequest.Validate if the designated constraints aren't met.
type UpdateTransferLimitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTransferLimitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTransferLimitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTransferLimitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTransferLimitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTransferLimitRequestValidationError) ErrorName() string {
	return "UpdateTransferLimitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTransferLimitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTransferLimitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTransferLimitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTransferLimitRequestValidationError{}

var _UpdateTransferLimitRequest_TransferLimitId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on UpdateTransferLimitNameRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdateTransferLimitNameRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *UpdateTransferLimitNameRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdateTransferLimitNameRequest_TransferLimitId_Pattern.MatchString(m.GetTransferLimitId()) {
		err := UpdateTransferLimitNameRequestValidationError{
			field:  "TransferLimitId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := UpdateTransferLimitNameRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdateTransferLimitNameRequestMultiError(errors)
	}
	return nil
}

// UpdateTransferLimitNameRequestMultiError is an error wrapping multiple
// validation errors returned by UpdateTransferLimitNameRequest.Validate(true)
// if the designated constraints aren't met.
type UpdateTransferLimitNameRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdateTransferLimitNameRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdateTransferLimitNameRequestMultiError) AllErrors() []error { return m }

// UpdateTransferLimitNameRequestValidationError is the validation error
// returned by UpdateTransferLimitNameRequest.Validate if the designated
// constraints aren't met.
type UpdateTransferLimitNameRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdateTransferLimitNameRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdateTransferLimitNameRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdateTransferLimitNameRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdateTransferLimitNameRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdateTransferLimitNameRequestValidationError) ErrorName() string {
	return "UpdateTransferLimitNameRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdateTransferLimitNameRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdateTransferLimitNameRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdateTransferLimitNameRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdateTransferLimitNameRequestValidationError{}

var _UpdateTransferLimitNameRequest_TransferLimitId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on DeleteTransferLimitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeleteTransferLimitRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *DeleteTransferLimitRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_DeleteTransferLimitRequest_TransferLimitId_Pattern.MatchString(m.GetTransferLimitId()) {
		err := DeleteTransferLimitRequestValidationError{
			field:  "TransferLimitId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeleteTransferLimitRequestMultiError(errors)
	}
	return nil
}

// DeleteTransferLimitRequestMultiError is an error wrapping multiple
// validation errors returned by DeleteTransferLimitRequest.Validate(true) if
// the designated constraints aren't met.
type DeleteTransferLimitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeleteTransferLimitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeleteTransferLimitRequestMultiError) AllErrors() []error { return m }

// DeleteTransferLimitRequestValidationError is the validation error returned
// by DeleteTransferLimitRequest.Validate if the designated constraints aren't met.
type DeleteTransferLimitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeleteTransferLimitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeleteTransferLimitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeleteTransferLimitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeleteTransferLimitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeleteTransferLimitRequestValidationError) ErrorName() string {
	return "DeleteTransferLimitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeleteTransferLimitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeleteTransferLimitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeleteTransferLimitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeleteTransferLimitRequestValidationError{}

var _DeleteTransferLimitRequest_TransferLimitId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ReviewTransferLimitProposalRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ReviewTransferLimitProposalRequestMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ReviewTransferLimitProposalRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ReviewTransferLimitProposalRequest_TransferLimitId_Pattern.MatchString(m.GetTransferLimitId()) {
		err := ReviewTransferLimitProposalRequestValidationError{
			field:  "TransferLimitId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Approve

	if len(errors) > 0 {
		return ReviewTransferLimitProposalRequestMultiError(errors)
	}
	return nil
}

// ReviewTransferLimitProposalRequestMultiError is an error wrapping multiple
// validation errors returned by
// ReviewTransferLimitProposalRequest.Validate(true) if the designated
// constraints aren't met.
type ReviewTransferLimitProposalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReviewTransferLimitProposalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReviewTransferLimitProposalRequestMultiError) AllErrors() []error { return m }

// ReviewTransferLimitProposalRequestValidationError is the validation error
// returned by ReviewTransferLimitProposalRequest.Validate if the designated
// constraints aren't met.
type ReviewTransferLimitProposalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReviewTransferLimitProposalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReviewTransferLimitProposalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReviewTransferLimitProposalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReviewTransferLimitProposalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReviewTransferLimitProposalRequestValidationError) ErrorName() string {
	return "ReviewTransferLimitProposalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReviewTransferLimitProposalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReviewTransferLimitProposalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReviewTransferLimitProposalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReviewTransferLimitProposalRequestValidationError{}

var _ReviewTransferLimitProposalRequest_TransferLimitId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on CreatePolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreatePolicyRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CreatePolicyRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := CreatePolicyRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreatePolicyRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := CreatePolicyRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := CreatePolicyRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreatePolicyRequest_Type_NotInLookup[m.GetType()]; ok {
		err := CreatePolicyRequestValidationError{
			field:  "Type",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := PolicyType_name[int32(m.GetType())]; !ok {
		err := CreatePolicyRequestValidationError{
			field:  "Type",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreatePolicyRequest_WhitelistId_Pattern.MatchString(m.GetWhitelistId()) {
		err := CreatePolicyRequestValidationError{
			field:  "WhitelistId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreatePolicyRequest_TransferLimitId_Pattern.MatchString(m.GetTransferLimitId()) {
		err := CreatePolicyRequestValidationError{
			field:  "TransferLimitId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return CreatePolicyRequestMultiError(errors)
	}
	return nil
}

// CreatePolicyRequestMultiError is an error wrapping multiple validation
// errors returned by CreatePolicyRequest.Validate(true) if the designated
// constraints aren't met.
type CreatePolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePolicyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePolicyRequestMultiError) AllErrors() []error { return m }

// CreatePolicyRequestValidationError is the validation error returned by
// CreatePolicyRequest.Validate if the designated constraints aren't met.
type CreatePolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePolicyRequestValidationError) ErrorName() string {
	return "CreatePolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePolicyRequestValidationError{}

var _CreatePolicyRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

var _CreatePolicyRequest_Type_NotInLookup = map[PolicyType]struct{}{
	0: {},
}

var _CreatePolicyRequest_WhitelistId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _CreatePolicyRequest_TransferLimitId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on CreatePolicyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreatePolicyResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CreatePolicyResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PolicyId

	if len(errors) > 0 {
		return CreatePolicyResponseMultiError(errors)
	}
	return nil
}

// CreatePolicyResponseMultiError is an error wrapping multiple validation
// errors returned by CreatePolicyResponse.Validate(true) if the designated
// constraints aren't met.
type CreatePolicyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreatePolicyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreatePolicyResponseMultiError) AllErrors() []error { return m }

// CreatePolicyResponseValidationError is the validation error returned by
// CreatePolicyResponse.Validate if the designated constraints aren't met.
type CreatePolicyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreatePolicyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreatePolicyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreatePolicyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreatePolicyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreatePolicyResponseValidationError) ErrorName() string {
	return "CreatePolicyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreatePolicyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreatePolicyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreatePolicyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreatePolicyResponseValidationError{}

// Validate checks the field values on GetPolicyRequest with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in GetPolicyRequestMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *GetPolicyRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_GetPolicyRequest_PolicyId_Pattern.MatchString(m.GetPolicyId()) {
		err := GetPolicyRequestValidationError{
			field:  "PolicyId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return GetPolicyRequestMultiError(errors)
	}
	return nil
}

// GetPolicyRequestMultiError is an error wrapping multiple validation errors
// returned by GetPolicyRequest.Validate(true) if the designated constraints
// aren't met.
type GetPolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetPolicyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetPolicyRequestMultiError) AllErrors() []error { return m }

// GetPolicyRequestValidationError is the validation error returned by
// GetPolicyRequest.Validate if the designated constraints aren't met.
type GetPolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetPolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetPolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetPolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetPolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetPolicyRequestValidationError) ErrorName() string { return "GetPolicyRequestValidationError" }

// Error satisfies the builtin error interface
func (e GetPolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetPolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetPolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetPolicyRequestValidationError{}

var _GetPolicyRequest_PolicyId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListPoliciesRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListPoliciesRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListPoliciesRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListPoliciesRequestMultiError(errors)
	}
	return nil
}

// ListPoliciesRequestMultiError is an error wrapping multiple validation
// errors returned by ListPoliciesRequest.Validate(true) if the designated
// constraints aren't met.
type ListPoliciesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPoliciesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPoliciesRequestMultiError) AllErrors() []error { return m }

// ListPoliciesRequestValidationError is the validation error returned by
// ListPoliciesRequest.Validate if the designated constraints aren't met.
type ListPoliciesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPoliciesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPoliciesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPoliciesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPoliciesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPoliciesRequestValidationError) ErrorName() string {
	return "ListPoliciesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListPoliciesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPoliciesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPoliciesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPoliciesRequestValidationError{}

// Validate checks the field values on IsDeletablePolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in IsDeletablePolicyRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *IsDeletablePolicyRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_IsDeletablePolicyRequest_PolicyId_Pattern.MatchString(m.GetPolicyId()) {
		err := IsDeletablePolicyRequestValidationError{
			field:  "PolicyId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IsDeletablePolicyRequestMultiError(errors)
	}
	return nil
}

// IsDeletablePolicyRequestMultiError is an error wrapping multiple validation
// errors returned by IsDeletablePolicyRequest.Validate(true) if the
// designated constraints aren't met.
type IsDeletablePolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsDeletablePolicyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsDeletablePolicyRequestMultiError) AllErrors() []error { return m }

// IsDeletablePolicyRequestValidationError is the validation error returned by
// IsDeletablePolicyRequest.Validate if the designated constraints aren't met.
type IsDeletablePolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsDeletablePolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsDeletablePolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsDeletablePolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsDeletablePolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsDeletablePolicyRequestValidationError) ErrorName() string {
	return "IsDeletablePolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IsDeletablePolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsDeletablePolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsDeletablePolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsDeletablePolicyRequestValidationError{}

var _IsDeletablePolicyRequest_PolicyId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on IsDeletablePolicyResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in IsDeletablePolicyResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *IsDeletablePolicyResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsDeletable

	if len(errors) > 0 {
		return IsDeletablePolicyResponseMultiError(errors)
	}
	return nil
}

// IsDeletablePolicyResponseMultiError is an error wrapping multiple validation
// errors returned by IsDeletablePolicyResponse.Validate(true) if the
// designated constraints aren't met.
type IsDeletablePolicyResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsDeletablePolicyResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsDeletablePolicyResponseMultiError) AllErrors() []error { return m }

// IsDeletablePolicyResponseValidationError is the validation error returned by
// IsDeletablePolicyResponse.Validate if the designated constraints aren't met.
type IsDeletablePolicyResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsDeletablePolicyResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsDeletablePolicyResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsDeletablePolicyResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsDeletablePolicyResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsDeletablePolicyResponseValidationError) ErrorName() string {
	return "IsDeletablePolicyResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IsDeletablePolicyResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsDeletablePolicyResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsDeletablePolicyResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsDeletablePolicyResponseValidationError{}

// Validate checks the field values on IsDeletableLabeledAddressRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in IsDeletableLabeledAddressRequestMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *IsDeletableLabeledAddressRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_IsDeletableLabeledAddressRequest_LabeledAddressId_Pattern.MatchString(m.GetLabeledAddressId()) {
		err := IsDeletableLabeledAddressRequestValidationError{
			field:  "LabeledAddressId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IsDeletableLabeledAddressRequestMultiError(errors)
	}
	return nil
}

// IsDeletableLabeledAddressRequestMultiError is an error wrapping multiple
// validation errors returned by
// IsDeletableLabeledAddressRequest.Validate(true) if the designated
// constraints aren't met.
type IsDeletableLabeledAddressRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsDeletableLabeledAddressRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsDeletableLabeledAddressRequestMultiError) AllErrors() []error { return m }

// IsDeletableLabeledAddressRequestValidationError is the validation error
// returned by IsDeletableLabeledAddressRequest.Validate if the designated
// constraints aren't met.
type IsDeletableLabeledAddressRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsDeletableLabeledAddressRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsDeletableLabeledAddressRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsDeletableLabeledAddressRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsDeletableLabeledAddressRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsDeletableLabeledAddressRequestValidationError) ErrorName() string {
	return "IsDeletableLabeledAddressRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IsDeletableLabeledAddressRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsDeletableLabeledAddressRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsDeletableLabeledAddressRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsDeletableLabeledAddressRequestValidationError{}

var _IsDeletableLabeledAddressRequest_LabeledAddressId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on IsDeletableLabeledAddressResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in IsDeletableLabeledAddressResponseMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *IsDeletableLabeledAddressResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsDeletable

	if len(errors) > 0 {
		return IsDeletableLabeledAddressResponseMultiError(errors)
	}
	return nil
}

// IsDeletableLabeledAddressResponseMultiError is an error wrapping multiple
// validation errors returned by
// IsDeletableLabeledAddressResponse.Validate(true) if the designated
// constraints aren't met.
type IsDeletableLabeledAddressResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsDeletableLabeledAddressResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsDeletableLabeledAddressResponseMultiError) AllErrors() []error { return m }

// IsDeletableLabeledAddressResponseValidationError is the validation error
// returned by IsDeletableLabeledAddressResponse.Validate if the designated
// constraints aren't met.
type IsDeletableLabeledAddressResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsDeletableLabeledAddressResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsDeletableLabeledAddressResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsDeletableLabeledAddressResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsDeletableLabeledAddressResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsDeletableLabeledAddressResponseValidationError) ErrorName() string {
	return "IsDeletableLabeledAddressResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IsDeletableLabeledAddressResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsDeletableLabeledAddressResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsDeletableLabeledAddressResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsDeletableLabeledAddressResponseValidationError{}

// Validate checks the field values on IsDeletableWhitelistRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in IsDeletableWhitelistRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *IsDeletableWhitelistRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_IsDeletableWhitelistRequest_WhitelistId_Pattern.MatchString(m.GetWhitelistId()) {
		err := IsDeletableWhitelistRequestValidationError{
			field:  "WhitelistId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IsDeletableWhitelistRequestMultiError(errors)
	}
	return nil
}

// IsDeletableWhitelistRequestMultiError is an error wrapping multiple
// validation errors returned by IsDeletableWhitelistRequest.Validate(true) if
// the designated constraints aren't met.
type IsDeletableWhitelistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsDeletableWhitelistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsDeletableWhitelistRequestMultiError) AllErrors() []error { return m }

// IsDeletableWhitelistRequestValidationError is the validation error returned
// by IsDeletableWhitelistRequest.Validate if the designated constraints
// aren't met.
type IsDeletableWhitelistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsDeletableWhitelistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsDeletableWhitelistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsDeletableWhitelistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsDeletableWhitelistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsDeletableWhitelistRequestValidationError) ErrorName() string {
	return "IsDeletableWhitelistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IsDeletableWhitelistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsDeletableWhitelistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsDeletableWhitelistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsDeletableWhitelistRequestValidationError{}

var _IsDeletableWhitelistRequest_WhitelistId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on IsDeletableWhitelistResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in IsDeletableWhitelistResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *IsDeletableWhitelistResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsDeletable

	if len(errors) > 0 {
		return IsDeletableWhitelistResponseMultiError(errors)
	}
	return nil
}

// IsDeletableWhitelistResponseMultiError is an error wrapping multiple
// validation errors returned by IsDeletableWhitelistResponse.Validate(true)
// if the designated constraints aren't met.
type IsDeletableWhitelistResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsDeletableWhitelistResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsDeletableWhitelistResponseMultiError) AllErrors() []error { return m }

// IsDeletableWhitelistResponseValidationError is the validation error returned
// by IsDeletableWhitelistResponse.Validate if the designated constraints
// aren't met.
type IsDeletableWhitelistResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsDeletableWhitelistResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsDeletableWhitelistResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsDeletableWhitelistResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsDeletableWhitelistResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsDeletableWhitelistResponseValidationError) ErrorName() string {
	return "IsDeletableWhitelistResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IsDeletableWhitelistResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsDeletableWhitelistResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsDeletableWhitelistResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsDeletableWhitelistResponseValidationError{}

// Validate checks the field values on IsDeletableTransferLimitRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in IsDeletableTransferLimitRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *IsDeletableTransferLimitRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_IsDeletableTransferLimitRequest_TransferLimitId_Pattern.MatchString(m.GetTransferLimitId()) {
		err := IsDeletableTransferLimitRequestValidationError{
			field:  "TransferLimitId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return IsDeletableTransferLimitRequestMultiError(errors)
	}
	return nil
}

// IsDeletableTransferLimitRequestMultiError is an error wrapping multiple
// validation errors returned by
// IsDeletableTransferLimitRequest.Validate(true) if the designated
// constraints aren't met.
type IsDeletableTransferLimitRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsDeletableTransferLimitRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsDeletableTransferLimitRequestMultiError) AllErrors() []error { return m }

// IsDeletableTransferLimitRequestValidationError is the validation error
// returned by IsDeletableTransferLimitRequest.Validate if the designated
// constraints aren't met.
type IsDeletableTransferLimitRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsDeletableTransferLimitRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsDeletableTransferLimitRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsDeletableTransferLimitRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsDeletableTransferLimitRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsDeletableTransferLimitRequestValidationError) ErrorName() string {
	return "IsDeletableTransferLimitRequestValidationError"
}

// Error satisfies the builtin error interface
func (e IsDeletableTransferLimitRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsDeletableTransferLimitRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsDeletableTransferLimitRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsDeletableTransferLimitRequestValidationError{}

var _IsDeletableTransferLimitRequest_TransferLimitId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on IsDeletableTransferLimitResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in IsDeletableTransferLimitResponseMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *IsDeletableTransferLimitResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for IsDeletable

	if len(errors) > 0 {
		return IsDeletableTransferLimitResponseMultiError(errors)
	}
	return nil
}

// IsDeletableTransferLimitResponseMultiError is an error wrapping multiple
// validation errors returned by
// IsDeletableTransferLimitResponse.Validate(true) if the designated
// constraints aren't met.
type IsDeletableTransferLimitResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IsDeletableTransferLimitResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IsDeletableTransferLimitResponseMultiError) AllErrors() []error { return m }

// IsDeletableTransferLimitResponseValidationError is the validation error
// returned by IsDeletableTransferLimitResponse.Validate if the designated
// constraints aren't met.
type IsDeletableTransferLimitResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IsDeletableTransferLimitResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IsDeletableTransferLimitResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IsDeletableTransferLimitResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IsDeletableTransferLimitResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IsDeletableTransferLimitResponseValidationError) ErrorName() string {
	return "IsDeletableTransferLimitResponseValidationError"
}

// Error satisfies the builtin error interface
func (e IsDeletableTransferLimitResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIsDeletableTransferLimitResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IsDeletableTransferLimitResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IsDeletableTransferLimitResponseValidationError{}

// Validate checks the field values on ListPoliciesResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListPoliciesResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListPoliciesResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetPolicies() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListPoliciesResponseValidationError{
					field:  fmt.Sprintf("Policies[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListPoliciesResponseMultiError(errors)
	}
	return nil
}

// ListPoliciesResponseMultiError is an error wrapping multiple validation
// errors returned by ListPoliciesResponse.Validate(true) if the designated
// constraints aren't met.
type ListPoliciesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListPoliciesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListPoliciesResponseMultiError) AllErrors() []error { return m }

// ListPoliciesResponseValidationError is the validation error returned by
// ListPoliciesResponse.Validate if the designated constraints aren't met.
type ListPoliciesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListPoliciesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListPoliciesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListPoliciesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListPoliciesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListPoliciesResponseValidationError) ErrorName() string {
	return "ListPoliciesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListPoliciesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListPoliciesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListPoliciesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListPoliciesResponseValidationError{}

// Validate checks the field values on UpdatePolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in UpdatePolicyRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *UpdatePolicyRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_UpdatePolicyRequest_PolicyId_Pattern.MatchString(m.GetPolicyId()) {
		err := UpdatePolicyRequestValidationError{
			field:  "PolicyId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetName()); l < 1 || l > 40 {
		err := UpdatePolicyRequestValidationError{
			field:  "Name",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdatePolicyRequest_WhitelistId_Pattern.MatchString(m.GetWhitelistId()) {
		err := UpdatePolicyRequestValidationError{
			field:  "WhitelistId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_UpdatePolicyRequest_TransferLimitId_Pattern.MatchString(m.GetTransferLimitId()) {
		err := UpdatePolicyRequestValidationError{
			field:  "TransferLimitId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UpdatePolicyRequestMultiError(errors)
	}
	return nil
}

// UpdatePolicyRequestMultiError is an error wrapping multiple validation
// errors returned by UpdatePolicyRequest.Validate(true) if the designated
// constraints aren't met.
type UpdatePolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UpdatePolicyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UpdatePolicyRequestMultiError) AllErrors() []error { return m }

// UpdatePolicyRequestValidationError is the validation error returned by
// UpdatePolicyRequest.Validate if the designated constraints aren't met.
type UpdatePolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UpdatePolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UpdatePolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UpdatePolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UpdatePolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UpdatePolicyRequestValidationError) ErrorName() string {
	return "UpdatePolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e UpdatePolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUpdatePolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UpdatePolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UpdatePolicyRequestValidationError{}

var _UpdatePolicyRequest_PolicyId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _UpdatePolicyRequest_WhitelistId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _UpdatePolicyRequest_TransferLimitId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on DeletePolicyRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DeletePolicyRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DeletePolicyRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_DeletePolicyRequest_PolicyId_Pattern.MatchString(m.GetPolicyId()) {
		err := DeletePolicyRequestValidationError{
			field:  "PolicyId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return DeletePolicyRequestMultiError(errors)
	}
	return nil
}

// DeletePolicyRequestMultiError is an error wrapping multiple validation
// errors returned by DeletePolicyRequest.Validate(true) if the designated
// constraints aren't met.
type DeletePolicyRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeletePolicyRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeletePolicyRequestMultiError) AllErrors() []error { return m }

// DeletePolicyRequestValidationError is the validation error returned by
// DeletePolicyRequest.Validate if the designated constraints aren't met.
type DeletePolicyRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeletePolicyRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeletePolicyRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeletePolicyRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeletePolicyRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeletePolicyRequestValidationError) ErrorName() string {
	return "DeletePolicyRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DeletePolicyRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeletePolicyRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeletePolicyRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeletePolicyRequestValidationError{}

var _DeletePolicyRequest_PolicyId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ReviewPolicyProposalRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ReviewPolicyProposalRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ReviewPolicyProposalRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ReviewPolicyProposalRequest_PolicyId_Pattern.MatchString(m.GetPolicyId()) {
		err := ReviewPolicyProposalRequestValidationError{
			field:  "PolicyId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Approve

	if len(errors) > 0 {
		return ReviewPolicyProposalRequestMultiError(errors)
	}
	return nil
}

// ReviewPolicyProposalRequestMultiError is an error wrapping multiple
// validation errors returned by ReviewPolicyProposalRequest.Validate(true) if
// the designated constraints aren't met.
type ReviewPolicyProposalRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ReviewPolicyProposalRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ReviewPolicyProposalRequestMultiError) AllErrors() []error { return m }

// ReviewPolicyProposalRequestValidationError is the validation error returned
// by ReviewPolicyProposalRequest.Validate if the designated constraints
// aren't met.
type ReviewPolicyProposalRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ReviewPolicyProposalRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ReviewPolicyProposalRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ReviewPolicyProposalRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ReviewPolicyProposalRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ReviewPolicyProposalRequestValidationError) ErrorName() string {
	return "ReviewPolicyProposalRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ReviewPolicyProposalRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sReviewPolicyProposalRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ReviewPolicyProposalRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ReviewPolicyProposalRequestValidationError{}

var _ReviewPolicyProposalRequest_PolicyId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListSubstrateChildAddressesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListSubstrateChildAddressesRequestMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListSubstrateChildAddressesRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListSubstrateChildAddressesRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ListSubstrateChildAddressesRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListSubstrateChildAddressesRequestMultiError(errors)
	}
	return nil
}

// ListSubstrateChildAddressesRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListSubstrateChildAddressesRequest.Validate(true) if the designated
// constraints aren't met.
type ListSubstrateChildAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSubstrateChildAddressesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSubstrateChildAddressesRequestMultiError) AllErrors() []error { return m }

// ListSubstrateChildAddressesRequestValidationError is the validation error
// returned by ListSubstrateChildAddressesRequest.Validate if the designated
// constraints aren't met.
type ListSubstrateChildAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSubstrateChildAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSubstrateChildAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSubstrateChildAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSubstrateChildAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSubstrateChildAddressesRequestValidationError) ErrorName() string {
	return "ListSubstrateChildAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListSubstrateChildAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSubstrateChildAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSubstrateChildAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSubstrateChildAddressesRequestValidationError{}

var _ListSubstrateChildAddressesRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListSubstrateChildAddressesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListSubstrateChildAddressesResponseMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListSubstrateChildAddressesResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSubstrateChildAddresses() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListSubstrateChildAddressesResponseValidationError{
					field:  fmt.Sprintf("SubstrateChildAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListSubstrateChildAddressesResponseMultiError(errors)
	}
	return nil
}

// ListSubstrateChildAddressesResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListSubstrateChildAddressesResponse.Validate(true) if the designated
// constraints aren't met.
type ListSubstrateChildAddressesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSubstrateChildAddressesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSubstrateChildAddressesResponseMultiError) AllErrors() []error { return m }

// ListSubstrateChildAddressesResponseValidationError is the validation error
// returned by ListSubstrateChildAddressesResponse.Validate if the designated
// constraints aren't met.
type ListSubstrateChildAddressesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSubstrateChildAddressesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSubstrateChildAddressesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSubstrateChildAddressesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSubstrateChildAddressesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSubstrateChildAddressesResponseValidationError) ErrorName() string {
	return "ListSubstrateChildAddressesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListSubstrateChildAddressesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSubstrateChildAddressesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSubstrateChildAddressesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSubstrateChildAddressesResponseValidationError{}

// Validate checks the field values on ListSymbolChildAddressesRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListSymbolChildAddressesRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListSymbolChildAddressesRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListSymbolChildAddressesRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ListSymbolChildAddressesRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListSymbolChildAddressesRequestMultiError(errors)
	}
	return nil
}

// ListSymbolChildAddressesRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListSymbolChildAddressesRequest.Validate(true) if the designated
// constraints aren't met.
type ListSymbolChildAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSymbolChildAddressesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSymbolChildAddressesRequestMultiError) AllErrors() []error { return m }

// ListSymbolChildAddressesRequestValidationError is the validation error
// returned by ListSymbolChildAddressesRequest.Validate if the designated
// constraints aren't met.
type ListSymbolChildAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSymbolChildAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSymbolChildAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSymbolChildAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSymbolChildAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSymbolChildAddressesRequestValidationError) ErrorName() string {
	return "ListSymbolChildAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListSymbolChildAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSymbolChildAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSymbolChildAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSymbolChildAddressesRequestValidationError{}

var _ListSymbolChildAddressesRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListSymbolChildAddressesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListSymbolChildAddressesResponseMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListSymbolChildAddressesResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetSymbolChildAddresses() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListSymbolChildAddressesResponseValidationError{
					field:  fmt.Sprintf("SymbolChildAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListSymbolChildAddressesResponseMultiError(errors)
	}
	return nil
}

// ListSymbolChildAddressesResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListSymbolChildAddressesResponse.Validate(true) if the designated
// constraints aren't met.
type ListSymbolChildAddressesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListSymbolChildAddressesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListSymbolChildAddressesResponseMultiError) AllErrors() []error { return m }

// ListSymbolChildAddressesResponseValidationError is the validation error
// returned by ListSymbolChildAddressesResponse.Validate if the designated
// constraints aren't met.
type ListSymbolChildAddressesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListSymbolChildAddressesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListSymbolChildAddressesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListSymbolChildAddressesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListSymbolChildAddressesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListSymbolChildAddressesResponseValidationError) ErrorName() string {
	return "ListSymbolChildAddressesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListSymbolChildAddressesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListSymbolChildAddressesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListSymbolChildAddressesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListSymbolChildAddressesResponseValidationError{}

// Validate checks the field values on ListIOSTChildAccountsRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListIOSTChildAccountsRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListIOSTChildAccountsRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ListIOSTChildAccountsRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ListIOSTChildAccountsRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ListIOSTChildAccountsRequestMultiError(errors)
	}
	return nil
}

// ListIOSTChildAccountsRequestMultiError is an error wrapping multiple
// validation errors returned by ListIOSTChildAccountsRequest.Validate(true)
// if the designated constraints aren't met.
type ListIOSTChildAccountsRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListIOSTChildAccountsRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListIOSTChildAccountsRequestMultiError) AllErrors() []error { return m }

// ListIOSTChildAccountsRequestValidationError is the validation error returned
// by ListIOSTChildAccountsRequest.Validate if the designated constraints
// aren't met.
type ListIOSTChildAccountsRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListIOSTChildAccountsRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListIOSTChildAccountsRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListIOSTChildAccountsRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListIOSTChildAccountsRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListIOSTChildAccountsRequestValidationError) ErrorName() string {
	return "ListIOSTChildAccountsRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListIOSTChildAccountsRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListIOSTChildAccountsRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListIOSTChildAccountsRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListIOSTChildAccountsRequestValidationError{}

var _ListIOSTChildAccountsRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ListIOSTChildAccountsResponse with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListIOSTChildAccountsResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListIOSTChildAccountsResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetIostChildAccounts() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListIOSTChildAccountsResponseValidationError{
					field:  fmt.Sprintf("IostChildAccounts[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListIOSTChildAccountsResponseMultiError(errors)
	}
	return nil
}

// ListIOSTChildAccountsResponseMultiError is an error wrapping multiple
// validation errors returned by ListIOSTChildAccountsResponse.Validate(true)
// if the designated constraints aren't met.
type ListIOSTChildAccountsResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListIOSTChildAccountsResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListIOSTChildAccountsResponseMultiError) AllErrors() []error { return m }

// ListIOSTChildAccountsResponseValidationError is the validation error
// returned by ListIOSTChildAccountsResponse.Validate if the designated
// constraints aren't met.
type ListIOSTChildAccountsResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListIOSTChildAccountsResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListIOSTChildAccountsResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListIOSTChildAccountsResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListIOSTChildAccountsResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListIOSTChildAccountsResponseValidationError) ErrorName() string {
	return "ListIOSTChildAccountsResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListIOSTChildAccountsResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListIOSTChildAccountsResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListIOSTChildAccountsResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListIOSTChildAccountsResponseValidationError{}

// Validate checks the field values on DownloadResourceRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in DownloadResourceRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *DownloadResourceRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for DownloadResourceType

	// no validation rules for WatchOnly

	// no validation rules for WalletId

	if v, ok := interface{}(m.GetStartTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = DownloadResourceRequestValidationError{
				field:  "StartTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetEndTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = DownloadResourceRequestValidationError{
				field:  "EndTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return DownloadResourceRequestMultiError(errors)
	}
	return nil
}

// DownloadResourceRequestMultiError is an error wrapping multiple validation
// errors returned by DownloadResourceRequest.Validate(true) if the designated
// constraints aren't met.
type DownloadResourceRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DownloadResourceRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DownloadResourceRequestMultiError) AllErrors() []error { return m }

// DownloadResourceRequestValidationError is the validation error returned by
// DownloadResourceRequest.Validate if the designated constraints aren't met.
type DownloadResourceRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DownloadResourceRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DownloadResourceRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DownloadResourceRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DownloadResourceRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DownloadResourceRequestValidationError) ErrorName() string {
	return "DownloadResourceRequestValidationError"
}

// Error satisfies the builtin error interface
func (e DownloadResourceRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDownloadResourceRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DownloadResourceRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DownloadResourceRequestValidationError{}

// Validate checks the field values on CreateIOSTAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateIOSTAccountRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CreateIOSTAccountRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_CreateIOSTAccountRequest_AccountName_Pattern.MatchString(m.GetAccountName()) {
		err := CreateIOSTAccountRequestValidationError{
			field:  "AccountName",
			reason: "value does not match regex pattern \"^([a-z0-9_]{5,11})$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for WalletId

	// no validation rules for AccountId

	if len(errors) > 0 {
		return CreateIOSTAccountRequestMultiError(errors)
	}
	return nil
}

// CreateIOSTAccountRequestMultiError is an error wrapping multiple validation
// errors returned by CreateIOSTAccountRequest.Validate(true) if the
// designated constraints aren't met.
type CreateIOSTAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateIOSTAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateIOSTAccountRequestMultiError) AllErrors() []error { return m }

// CreateIOSTAccountRequestValidationError is the validation error returned by
// CreateIOSTAccountRequest.Validate if the designated constraints aren't met.
type CreateIOSTAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateIOSTAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateIOSTAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateIOSTAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateIOSTAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateIOSTAccountRequestValidationError) ErrorName() string {
	return "CreateIOSTAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateIOSTAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateIOSTAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateIOSTAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateIOSTAccountRequestValidationError{}

var _CreateIOSTAccountRequest_AccountName_Pattern = regexp.MustCompile("^([a-z0-9_]{5,11})$")

// Validate checks the field values on CreateIOSTAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateIOSTAccountResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CreateIOSTAccountResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AddressId

	if len(errors) > 0 {
		return CreateIOSTAccountResponseMultiError(errors)
	}
	return nil
}

// CreateIOSTAccountResponseMultiError is an error wrapping multiple validation
// errors returned by CreateIOSTAccountResponse.Validate(true) if the
// designated constraints aren't met.
type CreateIOSTAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateIOSTAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateIOSTAccountResponseMultiError) AllErrors() []error { return m }

// CreateIOSTAccountResponseValidationError is the validation error returned by
// CreateIOSTAccountResponse.Validate if the designated constraints aren't met.
type CreateIOSTAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateIOSTAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateIOSTAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateIOSTAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateIOSTAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateIOSTAccountResponseValidationError) ErrorName() string {
	return "CreateIOSTAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e CreateIOSTAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateIOSTAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateIOSTAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateIOSTAccountResponseValidationError{}

// Validate checks the field values on ExistsIOSTAccountRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ExistsIOSTAccountRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ExistsIOSTAccountRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ExistsIOSTAccountRequest_AccountName_Pattern.MatchString(m.GetAccountName()) {
		err := ExistsIOSTAccountRequestValidationError{
			field:  "AccountName",
			reason: "value does not match regex pattern \"^([a-z0-9_]{5,11})$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ExistsIOSTAccountRequestMultiError(errors)
	}
	return nil
}

// ExistsIOSTAccountRequestMultiError is an error wrapping multiple validation
// errors returned by ExistsIOSTAccountRequest.Validate(true) if the
// designated constraints aren't met.
type ExistsIOSTAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistsIOSTAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistsIOSTAccountRequestMultiError) AllErrors() []error { return m }

// ExistsIOSTAccountRequestValidationError is the validation error returned by
// ExistsIOSTAccountRequest.Validate if the designated constraints aren't met.
type ExistsIOSTAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistsIOSTAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistsIOSTAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistsIOSTAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistsIOSTAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistsIOSTAccountRequestValidationError) ErrorName() string {
	return "ExistsIOSTAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ExistsIOSTAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistsIOSTAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistsIOSTAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistsIOSTAccountRequestValidationError{}

var _ExistsIOSTAccountRequest_AccountName_Pattern = regexp.MustCompile("^([a-z0-9_]{5,11})$")

// Validate checks the field values on ExistsIOSTAccountResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ExistsIOSTAccountResponseMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ExistsIOSTAccountResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Exists

	if len(errors) > 0 {
		return ExistsIOSTAccountResponseMultiError(errors)
	}
	return nil
}

// ExistsIOSTAccountResponseMultiError is an error wrapping multiple validation
// errors returned by ExistsIOSTAccountResponse.Validate(true) if the
// designated constraints aren't met.
type ExistsIOSTAccountResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ExistsIOSTAccountResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ExistsIOSTAccountResponseMultiError) AllErrors() []error { return m }

// ExistsIOSTAccountResponseValidationError is the validation error returned by
// ExistsIOSTAccountResponse.Validate if the designated constraints aren't met.
type ExistsIOSTAccountResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ExistsIOSTAccountResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ExistsIOSTAccountResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ExistsIOSTAccountResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ExistsIOSTAccountResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ExistsIOSTAccountResponseValidationError) ErrorName() string {
	return "ExistsIOSTAccountResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ExistsIOSTAccountResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sExistsIOSTAccountResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ExistsIOSTAccountResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ExistsIOSTAccountResponseValidationError{}

// Validate checks the field values on GetIOSTCallerAccountRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in GetIOSTCallerAccountRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *GetIOSTCallerAccountRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return GetIOSTCallerAccountRequestMultiError(errors)
	}
	return nil
}

// GetIOSTCallerAccountRequestMultiError is an error wrapping multiple
// validation errors returned by GetIOSTCallerAccountRequest.Validate(true) if
// the designated constraints aren't met.
type GetIOSTCallerAccountRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m GetIOSTCallerAccountRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m GetIOSTCallerAccountRequestMultiError) AllErrors() []error { return m }

// GetIOSTCallerAccountRequestValidationError is the validation error returned
// by GetIOSTCallerAccountRequest.Validate if the designated constraints
// aren't met.
type GetIOSTCallerAccountRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e GetIOSTCallerAccountRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e GetIOSTCallerAccountRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e GetIOSTCallerAccountRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e GetIOSTCallerAccountRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e GetIOSTCallerAccountRequestValidationError) ErrorName() string {
	return "GetIOSTCallerAccountRequestValidationError"
}

// Error satisfies the builtin error interface
func (e GetIOSTCallerAccountRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sGetIOSTCallerAccountRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = GetIOSTCallerAccountRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = GetIOSTCallerAccountRequestValidationError{}

// Validate checks the field values on ListCallersRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListCallersRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListCallersRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListCallersRequestMultiError(errors)
	}
	return nil
}

// ListCallersRequestMultiError is an error wrapping multiple validation errors
// returned by ListCallersRequest.Validate(true) if the designated constraints
// aren't met.
type ListCallersRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCallersRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCallersRequestMultiError) AllErrors() []error { return m }

// ListCallersRequestValidationError is the validation error returned by
// ListCallersRequest.Validate if the designated constraints aren't met.
type ListCallersRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCallersRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCallersRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCallersRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCallersRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCallersRequestValidationError) ErrorName() string {
	return "ListCallersRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListCallersRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCallersRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCallersRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCallersRequestValidationError{}

// Validate checks the field values on ListCallersResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListCallersResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ListCallersResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCallerAddresses() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListCallersResponseValidationError{
					field:  fmt.Sprintf("CallerAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListCallersResponseMultiError(errors)
	}
	return nil
}

// ListCallersResponseMultiError is an error wrapping multiple validation
// errors returned by ListCallersResponse.Validate(true) if the designated
// constraints aren't met.
type ListCallersResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListCallersResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListCallersResponseMultiError) AllErrors() []error { return m }

// ListCallersResponseValidationError is the validation error returned by
// ListCallersResponse.Validate if the designated constraints aren't met.
type ListCallersResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListCallersResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListCallersResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListCallersResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListCallersResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListCallersResponseValidationError) ErrorName() string {
	return "ListCallersResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListCallersResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListCallersResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListCallersResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListCallersResponseValidationError{}
