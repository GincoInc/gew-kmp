// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: gincoinc/adamant/global/v1/adamantglobalv1/model.proto

package adamantglobalv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	gincoincglobalv1 "github.com/GincoInc/gew-kmp/gen/gincoinc/global/v1/gincoincglobalv1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.AddressType(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.AddressType(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.AddressType(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.AddressType(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.AddressType(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.XRPTransactionType(0)

	_ = gincoincglobalv1.NemTransactionType(0)

	_ = gincoincglobalv1.NemTransactionType(0)

	_ = gincoincglobalv1.NemTransactionType(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.TransferType(0)

	_ = gincoincglobalv1.TransactionState(0)

	_ = gincoincglobalv1.TransactionResult(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.TransferType(0)

	_ = gincoincglobalv1.TransactionState(0)

	_ = gincoincglobalv1.TransactionResult(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.TransferType(0)

	_ = gincoincglobalv1.TransferType(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Coin(0)
)

// Validate checks the field values on Wallet with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// WalletMultiError, or nil if none found. Otherwise, only the first error is
// returned, if any.
func (m *Wallet) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for HdAccount

	// no validation rules for WalletType

	// no validation rules for AddressType

	// no validation rules for M

	// no validation rules for N

	// no validation rules for State

	for idx, item := range m.GetKeys() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = WalletValidationError{
					field:  fmt.Sprintf("Keys[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	for idx, item := range m.GetMembers() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = WalletValidationError{
					field:  fmt.Sprintf("Members[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for RequiredApprovalCount

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for Address

	// no validation rules for PolicyId

	if v, ok := interface{}(m.GetProposal()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WalletValidationError{
				field:  "Proposal",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	// no validation rules for DestinationWalletId

	// no validation rules for WatchOnly

	// no validation rules for AddressNumber

	// no validation rules for ShouldCheckRemittance

	// no validation rules for InheritWalletId

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WalletValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WalletValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return WalletMultiError(errors)
	}
	return nil
}

// WalletMultiError is an error wrapping multiple validation errors returned by
// Wallet.Validate(true) if the designated constraints aren't met.
type WalletMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletMultiError) AllErrors() []error { return m }

// WalletValidationError is the validation error returned by Wallet.Validate if
// the designated constraints aren't met.
type WalletValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletValidationError) ErrorName() string { return "WalletValidationError" }

// Error satisfies the builtin error interface
func (e WalletValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWallet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletValidationError{}

// Validate checks the field values on WalletWithoutBalance with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in WalletWithoutBalanceMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *WalletWithoutBalance) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for HdAccount

	// no validation rules for WalletType

	// no validation rules for AddressType

	// no validation rules for M

	// no validation rules for N

	// no validation rules for State

	for idx, item := range m.GetKeys() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = WalletWithoutBalanceValidationError{
					field:  fmt.Sprintf("Keys[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	for idx, item := range m.GetMembers() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = WalletWithoutBalanceValidationError{
					field:  fmt.Sprintf("Members[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for RequiredApprovalCount

	// no validation rules for Address

	// no validation rules for PolicyId

	if v, ok := interface{}(m.GetProposal()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WalletWithoutBalanceValidationError{
				field:  "Proposal",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	// no validation rules for DestinationWalletId

	// no validation rules for WatchOnly

	// no validation rules for ShouldCheckRemittance

	// no validation rules for InheritWalletId

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WalletWithoutBalanceValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WalletWithoutBalanceValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return WalletWithoutBalanceMultiError(errors)
	}
	return nil
}

// WalletWithoutBalanceMultiError is an error wrapping multiple validation
// errors returned by WalletWithoutBalance.Validate(true) if the designated
// constraints aren't met.
type WalletWithoutBalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletWithoutBalanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletWithoutBalanceMultiError) AllErrors() []error { return m }

// WalletWithoutBalanceValidationError is the validation error returned by
// WalletWithoutBalance.Validate if the designated constraints aren't met.
type WalletWithoutBalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletWithoutBalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletWithoutBalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletWithoutBalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletWithoutBalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletWithoutBalanceValidationError) ErrorName() string {
	return "WalletWithoutBalanceValidationError"
}

// Error satisfies the builtin error interface
func (e WalletWithoutBalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletWithoutBalance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletWithoutBalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletWithoutBalanceValidationError{}

// Validate checks the field values on WalletProposal with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// WalletProposalMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *WalletProposal) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProposalType

	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	// no validation rules for ProposedPolicy

	// no validation rules for ProposedRequiredApprovalCount

	// no validation rules for IsReviewed

	if len(errors) > 0 {
		return WalletProposalMultiError(errors)
	}
	return nil
}

// WalletProposalMultiError is an error wrapping multiple validation errors
// returned by WalletProposal.Validate(true) if the designated constraints
// aren't met.
type WalletProposalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletProposalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletProposalMultiError) AllErrors() []error { return m }

// WalletProposalValidationError is the validation error returned by
// WalletProposal.Validate if the designated constraints aren't met.
type WalletProposalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletProposalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletProposalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletProposalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletProposalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletProposalValidationError) ErrorName() string { return "WalletProposalValidationError" }

// Error satisfies the builtin error interface
func (e WalletProposalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletProposal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletProposalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletProposalValidationError{}

// Validate checks the field values on WalletMember with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// WalletMemberMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *WalletMember) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for Name

	// no validation rules for Email

	// no validation rules for Role

	// no validation rules for IsKeyRegistered

	// no validation rules for IsMaster

	// no validation rules for IsValidatedToCreateWallet

	if len(errors) > 0 {
		return WalletMemberMultiError(errors)
	}
	return nil
}

// WalletMemberMultiError is an error wrapping multiple validation errors
// returned by WalletMember.Validate(true) if the designated constraints
// aren't met.
type WalletMemberMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletMemberMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletMemberMultiError) AllErrors() []error { return m }

// WalletMemberValidationError is the validation error returned by
// WalletMember.Validate if the designated constraints aren't met.
type WalletMemberValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletMemberValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletMemberValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletMemberValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletMemberValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletMemberValidationError) ErrorName() string { return "WalletMemberValidationError" }

// Error satisfies the builtin error interface
func (e WalletMemberValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletMember.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletMemberValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletMemberValidationError{}

// Validate checks the field values on Key with the rules defined in the proto
// definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// KeyMultiError, or nil if none found. Otherwise, only the first error is
// returned, if any.
func (m *Key) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for KeyId

	// no validation rules for KeyIndex

	if len(errors) > 0 {
		return KeyMultiError(errors)
	}
	return nil
}

// KeyMultiError is an error wrapping multiple validation errors returned by
// Key.Validate(true) if the designated constraints aren't met.
type KeyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyMultiError) AllErrors() []error { return m }

// KeyValidationError is the validation error returned by Key.Validate if the
// designated constraints aren't met.
type KeyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyValidationError) ErrorName() string { return "KeyValidationError" }

// Error satisfies the builtin error interface
func (e KeyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKey.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyValidationError{}

// Validate checks the field values on Address with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// AddressMultiError, or nil if none found. Otherwise, only the first error is
// returned, if any.
func (m *Address) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for AddressId

	// no validation rules for Coin

	// no validation rules for Address

	// no validation rules for Index

	// no validation rules for HdChange

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for State

	// no validation rules for AddressType

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = AddressValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = AddressValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return AddressMultiError(errors)
	}
	return nil
}

// AddressMultiError is an error wrapping multiple validation errors returned
// by Address.Validate(true) if the designated constraints aren't met.
type AddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressMultiError) AllErrors() []error { return m }

// AddressValidationError is the validation error returned by Address.Validate
// if the designated constraints aren't met.
type AddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressValidationError) ErrorName() string { return "AddressValidationError" }

// Error satisfies the builtin error interface
func (e AddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressValidationError{}

// Validate checks the field values on AddressWithoutBalance with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in AddressWithoutBalanceMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *AddressWithoutBalance) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for AddressId

	// no validation rules for Coin

	// no validation rules for Address

	// no validation rules for Index

	// no validation rules for HdChange

	// no validation rules for State

	// no validation rules for AddressType

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = AddressWithoutBalanceValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = AddressWithoutBalanceValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return AddressWithoutBalanceMultiError(errors)
	}
	return nil
}

// AddressWithoutBalanceMultiError is an error wrapping multiple validation
// errors returned by AddressWithoutBalance.Validate(true) if the designated
// constraints aren't met.
type AddressWithoutBalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressWithoutBalanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressWithoutBalanceMultiError) AllErrors() []error { return m }

// AddressWithoutBalanceValidationError is the validation error returned by
// AddressWithoutBalance.Validate if the designated constraints aren't met.
type AddressWithoutBalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressWithoutBalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressWithoutBalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressWithoutBalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressWithoutBalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressWithoutBalanceValidationError) ErrorName() string {
	return "AddressWithoutBalanceValidationError"
}

// Error satisfies the builtin error interface
func (e AddressWithoutBalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressWithoutBalance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressWithoutBalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressWithoutBalanceValidationError{}

// Validate checks the field values on FlushedAddress with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// FlushedAddressMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *FlushedAddress) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for AddressId

	// no validation rules for Coin

	// no validation rules for Address

	// no validation rules for Index

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for State

	// no validation rules for AddressType

	if len(errors) > 0 {
		return FlushedAddressMultiError(errors)
	}
	return nil
}

// FlushedAddressMultiError is an error wrapping multiple validation errors
// returned by FlushedAddress.Validate(true) if the designated constraints
// aren't met.
type FlushedAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlushedAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlushedAddressMultiError) AllErrors() []error { return m }

// FlushedAddressValidationError is the validation error returned by
// FlushedAddress.Validate if the designated constraints aren't met.
type FlushedAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlushedAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlushedAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlushedAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlushedAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlushedAddressValidationError) ErrorName() string { return "FlushedAddressValidationError" }

// Error satisfies the builtin error interface
func (e FlushedAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlushedAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlushedAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlushedAddressValidationError{}

// Validate checks the field values on EthereumFeeAddress with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in EthereumFeeAddressMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *EthereumFeeAddress) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	if len(errors) > 0 {
		return EthereumFeeAddressMultiError(errors)
	}
	return nil
}

// EthereumFeeAddressMultiError is an error wrapping multiple validation errors
// returned by EthereumFeeAddress.Validate(true) if the designated constraints
// aren't met.
type EthereumFeeAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EthereumFeeAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EthereumFeeAddressMultiError) AllErrors() []error { return m }

// EthereumFeeAddressValidationError is the validation error returned by
// EthereumFeeAddress.Validate if the designated constraints aren't met.
type EthereumFeeAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EthereumFeeAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EthereumFeeAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EthereumFeeAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EthereumFeeAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EthereumFeeAddressValidationError) ErrorName() string {
	return "EthereumFeeAddressValidationError"
}

// Error satisfies the builtin error interface
func (e EthereumFeeAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEthereumFeeAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EthereumFeeAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EthereumFeeAddressValidationError{}

// Validate checks the field values on AddressWithBalance with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in AddressWithBalanceMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *AddressWithBalance) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for FeeBalance

	// no validation rules for StringFeeBalance

	if len(errors) > 0 {
		return AddressWithBalanceMultiError(errors)
	}
	return nil
}

// AddressWithBalanceMultiError is an error wrapping multiple validation errors
// returned by AddressWithBalance.Validate(true) if the designated constraints
// aren't met.
type AddressWithBalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressWithBalanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressWithBalanceMultiError) AllErrors() []error { return m }

// AddressWithBalanceValidationError is the validation error returned by
// AddressWithBalance.Validate if the designated constraints aren't met.
type AddressWithBalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressWithBalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressWithBalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressWithBalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressWithBalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressWithBalanceValidationError) ErrorName() string {
	return "AddressWithBalanceValidationError"
}

// Error satisfies the builtin error interface
func (e AddressWithBalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressWithBalance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressWithBalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressWithBalanceValidationError{}

// Validate checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// TransactionMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *Transaction) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for Coin

	// no validation rules for TxId

	// no validation rules for Address

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for JpyRate

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for FeeRate

	// no validation rules for State

	for idx, item := range m.GetSignedKeys() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = TransactionValidationError{
					field:  fmt.Sprintf("SignedKeys[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	for idx, item := range m.GetMembers() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = TransactionValidationError{
					field:  fmt.Sprintf("Members[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if v, ok := interface{}(m.GetBitcoinSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "BitcoinSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetEthereumSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "EthereumSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetLitecoinSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "LitecoinSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetBitcoincashSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "BitcoincashSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetXrpSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "XrpSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetTronSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "TronSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetC0BanSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "C0BanSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetStellarSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "StellarSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetCardanoSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "CardanoSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetSubstrateSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "SubstrateSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetMonacoinSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "MonacoinSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetNemSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "NemSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetIostSpecific()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "IostSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransactionValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return TransactionMultiError(errors)
	}
	return nil
}

// TransactionMultiError is an error wrapping multiple validation errors
// returned by Transaction.Validate(true) if the designated constraints aren't met.
type TransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionMultiError) AllErrors() []error { return m }

// TransactionValidationError is the validation error returned by
// Transaction.Validate if the designated constraints aren't met.
type TransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionValidationError) ErrorName() string { return "TransactionValidationError" }

// Error satisfies the builtin error interface
func (e TransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionValidationError{}

// Validate checks the field values on TransactionMember with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in TransactionMemberMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *TransactionMember) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for Name

	// no validation rules for Email

	// no validation rules for Role

	// no validation rules for Signed

	// no validation rules for Validated

	if len(errors) > 0 {
		return TransactionMemberMultiError(errors)
	}
	return nil
}

// TransactionMemberMultiError is an error wrapping multiple validation errors
// returned by TransactionMember.Validate(true) if the designated constraints
// aren't met.
type TransactionMemberMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionMemberMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionMemberMultiError) AllErrors() []error { return m }

// TransactionMemberValidationError is the validation error returned by
// TransactionMember.Validate if the designated constraints aren't met.
type TransactionMemberValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionMemberValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionMemberValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionMemberValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionMemberValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionMemberValidationError) ErrorName() string {
	return "TransactionMemberValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionMemberValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionMember.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionMemberValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionMemberValidationError{}

// Validate checks the field values on TxInput with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// TxInputMultiError, or nil if none found. Otherwise, only the first error is
// returned, if any.
func (m *TxInput) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	// no validation rules for TxIndex

	// no validation rules for Value

	// no validation rules for StringValue

	if len(errors) > 0 {
		return TxInputMultiError(errors)
	}
	return nil
}

// TxInputMultiError is an error wrapping multiple validation errors returned
// by TxInput.Validate(true) if the designated constraints aren't met.
type TxInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TxInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TxInputMultiError) AllErrors() []error { return m }

// TxInputValidationError is the validation error returned by TxInput.Validate
// if the designated constraints aren't met.
type TxInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxInputValidationError) ErrorName() string { return "TxInputValidationError" }

// Error satisfies the builtin error interface
func (e TxInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxInputValidationError{}

// Validate checks the field values on TxOutput with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// TxOutputMultiError, or nil if none found. Otherwise, only the first error
// is returned, if any.
func (m *TxOutput) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for IsChange

	if len(errors) > 0 {
		return TxOutputMultiError(errors)
	}
	return nil
}

// TxOutputMultiError is an error wrapping multiple validation errors returned
// by TxOutput.Validate(true) if the designated constraints aren't met.
type TxOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TxOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TxOutputMultiError) AllErrors() []error { return m }

// TxOutputValidationError is the validation error returned by
// TxOutput.Validate if the designated constraints aren't met.
type TxOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxOutputValidationError) ErrorName() string { return "TxOutputValidationError" }

// Error satisfies the builtin error interface
func (e TxOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxOutputValidationError{}

// Validate checks the field values on UTXO with the rules defined in the proto
// definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// UTXOMultiError, or nil if none found. Otherwise, only the first error is
// returned, if any.
func (m *UTXO) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	// no validation rules for Vout

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for Address

	if !_UTXO_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := UTXOValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return UTXOMultiError(errors)
	}
	return nil
}

// UTXOMultiError is an error wrapping multiple validation errors returned by
// UTXO.Validate(true) if the designated constraints aren't met.
type UTXOMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UTXOMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UTXOMultiError) AllErrors() []error { return m }

// UTXOValidationError is the validation error returned by UTXO.Validate if the
// designated constraints aren't met.
type UTXOValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UTXOValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UTXOValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UTXOValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UTXOValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UTXOValidationError) ErrorName() string { return "UTXOValidationError" }

// Error satisfies the builtin error interface
func (e UTXOValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUTXO.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UTXOValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UTXOValidationError{}

var _UTXO_TransactionId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on BitcoinSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in BitcoinSpecificMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *BitcoinSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = BitcoinSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = BitcoinSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return BitcoinSpecificMultiError(errors)
	}
	return nil
}

// BitcoinSpecificMultiError is an error wrapping multiple validation errors
// returned by BitcoinSpecific.Validate(true) if the designated constraints
// aren't met.
type BitcoinSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BitcoinSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BitcoinSpecificMultiError) AllErrors() []error { return m }

// BitcoinSpecificValidationError is the validation error returned by
// BitcoinSpecific.Validate if the designated constraints aren't met.
type BitcoinSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BitcoinSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BitcoinSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BitcoinSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BitcoinSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BitcoinSpecificValidationError) ErrorName() string { return "BitcoinSpecificValidationError" }

// Error satisfies the builtin error interface
func (e BitcoinSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBitcoinSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BitcoinSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BitcoinSpecificValidationError{}

// Validate checks the field values on LitecoinSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in LitecoinSpecificMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *LitecoinSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = LitecoinSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = LitecoinSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return LitecoinSpecificMultiError(errors)
	}
	return nil
}

// LitecoinSpecificMultiError is an error wrapping multiple validation errors
// returned by LitecoinSpecific.Validate(true) if the designated constraints
// aren't met.
type LitecoinSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LitecoinSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LitecoinSpecificMultiError) AllErrors() []error { return m }

// LitecoinSpecificValidationError is the validation error returned by
// LitecoinSpecific.Validate if the designated constraints aren't met.
type LitecoinSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LitecoinSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LitecoinSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LitecoinSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LitecoinSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LitecoinSpecificValidationError) ErrorName() string { return "LitecoinSpecificValidationError" }

// Error satisfies the builtin error interface
func (e LitecoinSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLitecoinSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LitecoinSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LitecoinSpecificValidationError{}

// Validate checks the field values on BitcoincashSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in BitcoincashSpecificMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *BitcoincashSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = BitcoincashSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = BitcoincashSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return BitcoincashSpecificMultiError(errors)
	}
	return nil
}

// BitcoincashSpecificMultiError is an error wrapping multiple validation
// errors returned by BitcoincashSpecific.Validate(true) if the designated
// constraints aren't met.
type BitcoincashSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BitcoincashSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BitcoincashSpecificMultiError) AllErrors() []error { return m }

// BitcoincashSpecificValidationError is the validation error returned by
// BitcoincashSpecific.Validate if the designated constraints aren't met.
type BitcoincashSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BitcoincashSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BitcoincashSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BitcoincashSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BitcoincashSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BitcoincashSpecificValidationError) ErrorName() string {
	return "BitcoincashSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e BitcoincashSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBitcoincashSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BitcoincashSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BitcoincashSpecificValidationError{}

// Validate checks the field values on EthereumSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in EthereumSpecificMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *EthereumSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	// no validation rules for MethodIdType

	// no validation rules for Expiration

	if len(errors) > 0 {
		return EthereumSpecificMultiError(errors)
	}
	return nil
}

// EthereumSpecificMultiError is an error wrapping multiple validation errors
// returned by EthereumSpecific.Validate(true) if the designated constraints
// aren't met.
type EthereumSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EthereumSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EthereumSpecificMultiError) AllErrors() []error { return m }

// EthereumSpecificValidationError is the validation error returned by
// EthereumSpecific.Validate if the designated constraints aren't met.
type EthereumSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EthereumSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EthereumSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EthereumSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EthereumSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EthereumSpecificValidationError) ErrorName() string { return "EthereumSpecificValidationError" }

// Error satisfies the builtin error interface
func (e EthereumSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEthereumSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EthereumSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EthereumSpecificValidationError{}

// Validate checks the field values on XrpSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// XrpSpecificMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *XrpSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SequenceNumber

	// no validation rules for DestinationTag

	// no validation rules for TxType

	// no validation rules for IsNextSequenceNumber

	if len(errors) > 0 {
		return XrpSpecificMultiError(errors)
	}
	return nil
}

// XrpSpecificMultiError is an error wrapping multiple validation errors
// returned by XrpSpecific.Validate(true) if the designated constraints aren't met.
type XrpSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m XrpSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m XrpSpecificMultiError) AllErrors() []error { return m }

// XrpSpecificValidationError is the validation error returned by
// XrpSpecific.Validate if the designated constraints aren't met.
type XrpSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e XrpSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e XrpSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e XrpSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e XrpSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e XrpSpecificValidationError) ErrorName() string { return "XrpSpecificValidationError" }

// Error satisfies the builtin error interface
func (e XrpSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sXrpSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = XrpSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = XrpSpecificValidationError{}

// Validate checks the field values on TronSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// TronSpecificMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *TronSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Expiration

	if len(errors) > 0 {
		return TronSpecificMultiError(errors)
	}
	return nil
}

// TronSpecificMultiError is an error wrapping multiple validation errors
// returned by TronSpecific.Validate(true) if the designated constraints
// aren't met.
type TronSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TronSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TronSpecificMultiError) AllErrors() []error { return m }

// TronSpecificValidationError is the validation error returned by
// TronSpecific.Validate if the designated constraints aren't met.
type TronSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TronSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TronSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TronSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TronSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TronSpecificValidationError) ErrorName() string { return "TronSpecificValidationError" }

// Error satisfies the builtin error interface
func (e TronSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTronSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TronSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TronSpecificValidationError{}

// Validate checks the field values on C0BanSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// C0BanSpecificMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *C0BanSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = C0BanSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = C0BanSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return C0BanSpecificMultiError(errors)
	}
	return nil
}

// C0BanSpecificMultiError is an error wrapping multiple validation errors
// returned by C0BanSpecific.Validate(true) if the designated constraints
// aren't met.
type C0BanSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m C0BanSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m C0BanSpecificMultiError) AllErrors() []error { return m }

// C0BanSpecificValidationError is the validation error returned by
// C0BanSpecific.Validate if the designated constraints aren't met.
type C0BanSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e C0BanSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e C0BanSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e C0BanSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e C0BanSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e C0BanSpecificValidationError) ErrorName() string { return "C0BanSpecificValidationError" }

// Error satisfies the builtin error interface
func (e C0BanSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sC0BanSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = C0BanSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = C0BanSpecificValidationError{}

// Validate checks the field values on StellarSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in StellarSpecificMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *StellarSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SequenceNumber

	// no validation rules for MemoId

	// no validation rules for IsNextSequenceNumber

	if len(errors) > 0 {
		return StellarSpecificMultiError(errors)
	}
	return nil
}

// StellarSpecificMultiError is an error wrapping multiple validation errors
// returned by StellarSpecific.Validate(true) if the designated constraints
// aren't met.
type StellarSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StellarSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StellarSpecificMultiError) AllErrors() []error { return m }

// StellarSpecificValidationError is the validation error returned by
// StellarSpecific.Validate if the designated constraints aren't met.
type StellarSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StellarSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StellarSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StellarSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StellarSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StellarSpecificValidationError) ErrorName() string { return "StellarSpecificValidationError" }

// Error satisfies the builtin error interface
func (e StellarSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStellarSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StellarSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StellarSpecificValidationError{}

// Validate checks the field values on CardanoSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in CardanoSpecificMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *CardanoSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = CardanoSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = CardanoSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return CardanoSpecificMultiError(errors)
	}
	return nil
}

// CardanoSpecificMultiError is an error wrapping multiple validation errors
// returned by CardanoSpecific.Validate(true) if the designated constraints
// aren't met.
type CardanoSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardanoSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardanoSpecificMultiError) AllErrors() []error { return m }

// CardanoSpecificValidationError is the validation error returned by
// CardanoSpecific.Validate if the designated constraints aren't met.
type CardanoSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardanoSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardanoSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardanoSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardanoSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardanoSpecificValidationError) ErrorName() string { return "CardanoSpecificValidationError" }

// Error satisfies the builtin error interface
func (e CardanoSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCardanoSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardanoSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardanoSpecificValidationError{}

// Validate checks the field values on SubstrateSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in SubstrateSpecificMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *SubstrateSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	for idx, item := range m.GetSubstrateMultisigTransactions() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = SubstrateSpecificValidationError{
					field:  fmt.Sprintf("SubstrateMultisigTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return SubstrateSpecificMultiError(errors)
	}
	return nil
}

// SubstrateSpecificMultiError is an error wrapping multiple validation errors
// returned by SubstrateSpecific.Validate(true) if the designated constraints
// aren't met.
type SubstrateSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubstrateSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubstrateSpecificMultiError) AllErrors() []error { return m }

// SubstrateSpecificValidationError is the validation error returned by
// SubstrateSpecific.Validate if the designated constraints aren't met.
type SubstrateSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubstrateSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubstrateSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubstrateSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubstrateSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubstrateSpecificValidationError) ErrorName() string {
	return "SubstrateSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e SubstrateSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubstrateSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubstrateSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubstrateSpecificValidationError{}

// Validate checks the field values on MonacoinSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in MonacoinSpecificMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *MonacoinSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = MonacoinSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = MonacoinSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return MonacoinSpecificMultiError(errors)
	}
	return nil
}

// MonacoinSpecificMultiError is an error wrapping multiple validation errors
// returned by MonacoinSpecific.Validate(true) if the designated constraints
// aren't met.
type MonacoinSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MonacoinSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MonacoinSpecificMultiError) AllErrors() []error { return m }

// MonacoinSpecificValidationError is the validation error returned by
// MonacoinSpecific.Validate if the designated constraints aren't met.
type MonacoinSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MonacoinSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MonacoinSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MonacoinSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MonacoinSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MonacoinSpecificValidationError) ErrorName() string { return "MonacoinSpecificValidationError" }

// Error satisfies the builtin error interface
func (e MonacoinSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMonacoinSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MonacoinSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MonacoinSpecificValidationError{}

// Validate checks the field values on NemSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// NemSpecificMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *NemSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	// no validation rules for TxType

	for idx, item := range m.GetNemMultisigTransactions() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = NemSpecificValidationError{
					field:  fmt.Sprintf("NemMultisigTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for Expiration

	if len(errors) > 0 {
		return NemSpecificMultiError(errors)
	}
	return nil
}

// NemSpecificMultiError is an error wrapping multiple validation errors
// returned by NemSpecific.Validate(true) if the designated constraints aren't met.
type NemSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NemSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NemSpecificMultiError) AllErrors() []error { return m }

// NemSpecificValidationError is the validation error returned by
// NemSpecific.Validate if the designated constraints aren't met.
type NemSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NemSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NemSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NemSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NemSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NemSpecificValidationError) ErrorName() string { return "NemSpecificValidationError" }

// Error satisfies the builtin error interface
func (e NemSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNemSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NemSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NemSpecificValidationError{}

// Validate checks the field values on IOSTSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// IOSTSpecificMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *IOSTSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Memo

	// no validation rules for Timestamp

	// no validation rules for Expiration

	if len(errors) > 0 {
		return IOSTSpecificMultiError(errors)
	}
	return nil
}

// IOSTSpecificMultiError is an error wrapping multiple validation errors
// returned by IOSTSpecific.Validate(true) if the designated constraints
// aren't met.
type IOSTSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IOSTSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IOSTSpecificMultiError) AllErrors() []error { return m }

// IOSTSpecificValidationError is the validation error returned by
// IOSTSpecific.Validate if the designated constraints aren't met.
type IOSTSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IOSTSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IOSTSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IOSTSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IOSTSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IOSTSpecificValidationError) ErrorName() string { return "IOSTSpecificValidationError" }

// Error satisfies the builtin error interface
func (e IOSTSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIOSTSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IOSTSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IOSTSpecificValidationError{}

// Validate checks the field values on CreateTransactionSubstrateSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in CreateTransactionSubstrateSpecificMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *CreateTransactionSubstrateSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for CallType

	// no validation rules for MultisigCallType

	if len(errors) > 0 {
		return CreateTransactionSubstrateSpecificMultiError(errors)
	}
	return nil
}

// CreateTransactionSubstrateSpecificMultiError is an error wrapping multiple
// validation errors returned by
// CreateTransactionSubstrateSpecific.Validate(true) if the designated
// constraints aren't met.
type CreateTransactionSubstrateSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionSubstrateSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionSubstrateSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionSubstrateSpecificValidationError is the validation error
// returned by CreateTransactionSubstrateSpecific.Validate if the designated
// constraints aren't met.
type CreateTransactionSubstrateSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionSubstrateSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionSubstrateSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionSubstrateSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionSubstrateSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionSubstrateSpecificValidationError) ErrorName() string {
	return "CreateTransactionSubstrateSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionSubstrateSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionSubstrateSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionSubstrateSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionSubstrateSpecificValidationError{}

// Validate checks the field values on CreateTransactionWalletConnectSpecific
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in
// CreateTransactionWalletConnectSpecificMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CreateTransactionWalletConnectSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CallRequestType

	// no validation rules for CallRequestParams

	if len(errors) > 0 {
		return CreateTransactionWalletConnectSpecificMultiError(errors)
	}
	return nil
}

// CreateTransactionWalletConnectSpecificMultiError is an error wrapping
// multiple validation errors returned by
// CreateTransactionWalletConnectSpecific.Validate(true) if the designated
// constraints aren't met.
type CreateTransactionWalletConnectSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionWalletConnectSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionWalletConnectSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionWalletConnectSpecificValidationError is the validation
// error returned by CreateTransactionWalletConnectSpecific.Validate if the
// designated constraints aren't met.
type CreateTransactionWalletConnectSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionWalletConnectSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionWalletConnectSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionWalletConnectSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionWalletConnectSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionWalletConnectSpecificValidationError) ErrorName() string {
	return "CreateTransactionWalletConnectSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionWalletConnectSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionWalletConnectSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionWalletConnectSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionWalletConnectSpecificValidationError{}

// Validate checks the field values on CreateTransactionNemSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateTransactionNemSpecificMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CreateTransactionNemSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for TxType

	// no validation rules for Message

	if len(errors) > 0 {
		return CreateTransactionNemSpecificMultiError(errors)
	}
	return nil
}

// CreateTransactionNemSpecificMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionNemSpecific.Validate(true)
// if the designated constraints aren't met.
type CreateTransactionNemSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionNemSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionNemSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionNemSpecificValidationError is the validation error returned
// by CreateTransactionNemSpecific.Validate if the designated constraints
// aren't met.
type CreateTransactionNemSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionNemSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionNemSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionNemSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionNemSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionNemSpecificValidationError) ErrorName() string {
	return "CreateTransactionNemSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionNemSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionNemSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionNemSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionNemSpecificValidationError{}

// Validate checks the field values on CreateTransactionIOSTSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateTransactionIOSTSpecificMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *CreateTransactionIOSTSpecific) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Memo

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return CreateTransactionIOSTSpecificMultiError(errors)
	}
	return nil
}

// CreateTransactionIOSTSpecificMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionIOSTSpecific.Validate(true)
// if the designated constraints aren't met.
type CreateTransactionIOSTSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionIOSTSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionIOSTSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionIOSTSpecificValidationError is the validation error
// returned by CreateTransactionIOSTSpecific.Validate if the designated
// constraints aren't met.
type CreateTransactionIOSTSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionIOSTSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionIOSTSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionIOSTSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionIOSTSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionIOSTSpecificValidationError) ErrorName() string {
	return "CreateTransactionIOSTSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionIOSTSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionIOSTSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionIOSTSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionIOSTSpecificValidationError{}

// Validate checks the field values on SubstrateMultisigTransaction with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SubstrateMultisigTransactionMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *SubstrateMultisigTransaction) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for SubstrateMultisigTransactionId

	// no validation rules for AccountId

	// no validation rules for TxId

	// no validation rules for ExtrinsicId

	// no validation rules for JpyRate

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for Nonce

	// no validation rules for MultisigCallType

	// no validation rules for State

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = SubstrateMultisigTransactionValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = SubstrateMultisigTransactionValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return SubstrateMultisigTransactionMultiError(errors)
	}
	return nil
}

// SubstrateMultisigTransactionMultiError is an error wrapping multiple
// validation errors returned by SubstrateMultisigTransaction.Validate(true)
// if the designated constraints aren't met.
type SubstrateMultisigTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubstrateMultisigTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubstrateMultisigTransactionMultiError) AllErrors() []error { return m }

// SubstrateMultisigTransactionValidationError is the validation error returned
// by SubstrateMultisigTransaction.Validate if the designated constraints
// aren't met.
type SubstrateMultisigTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubstrateMultisigTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubstrateMultisigTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubstrateMultisigTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubstrateMultisigTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubstrateMultisigTransactionValidationError) ErrorName() string {
	return "SubstrateMultisigTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e SubstrateMultisigTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubstrateMultisigTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubstrateMultisigTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubstrateMultisigTransactionValidationError{}

// Validate checks the field values on NemMultisigTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in NemMultisigTransactionMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *NemMultisigTransaction) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for NemMultisigTransactionId

	// no validation rules for AccountId

	// no validation rules for TxType

	// no validation rules for Data

	// no validation rules for Signature

	// no validation rules for State

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = NemMultisigTransactionValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = NemMultisigTransactionValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return NemMultisigTransactionMultiError(errors)
	}
	return nil
}

// NemMultisigTransactionMultiError is an error wrapping multiple validation
// errors returned by NemMultisigTransaction.Validate(true) if the designated
// constraints aren't met.
type NemMultisigTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NemMultisigTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NemMultisigTransactionMultiError) AllErrors() []error { return m }

// NemMultisigTransactionValidationError is the validation error returned by
// NemMultisigTransaction.Validate if the designated constraints aren't met.
type NemMultisigTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NemMultisigTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NemMultisigTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NemMultisigTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NemMultisigTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NemMultisigTransactionValidationError) ErrorName() string {
	return "NemMultisigTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e NemMultisigTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNemMultisigTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NemMultisigTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NemMultisigTransactionValidationError{}

// Validate checks the field values on SignInfo with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// SignInfoMultiError, or nil if none found. Otherwise, only the first error
// is returned, if any.
func (m *SignInfo) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for KeyId

	// no validation rules for HdAccount

	// no validation rules for Coin

	// no validation rules for TxId

	// no validation rules for SignIndex

	// no validation rules for SignMessage

	// no validation rules for HdChange

	// no validation rules for HdIndex

	for idx, item := range m.GetSignTxInputs() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = SignInfoValidationError{
					field:  fmt.Sprintf("SignTxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return SignInfoMultiError(errors)
	}
	return nil
}

// SignInfoMultiError is an error wrapping multiple validation errors returned
// by SignInfo.Validate(true) if the designated constraints aren't met.
type SignInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignInfoMultiError) AllErrors() []error { return m }

// SignInfoValidationError is the validation error returned by
// SignInfo.Validate if the designated constraints aren't met.
type SignInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignInfoValidationError) ErrorName() string { return "SignInfoValidationError" }

// Error satisfies the builtin error interface
func (e SignInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignInfoValidationError{}

// Validate checks the field values on SignTxInput with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// SignTxInputMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *SignTxInput) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxInputIndex

	// no validation rules for SignMessage

	// no validation rules for HdChange

	// no validation rules for HdIndex

	if len(errors) > 0 {
		return SignTxInputMultiError(errors)
	}
	return nil
}

// SignTxInputMultiError is an error wrapping multiple validation errors
// returned by SignTxInput.Validate(true) if the designated constraints aren't met.
type SignTxInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignTxInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignTxInputMultiError) AllErrors() []error { return m }

// SignTxInputValidationError is the validation error returned by
// SignTxInput.Validate if the designated constraints aren't met.
type SignTxInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignTxInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignTxInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignTxInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignTxInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignTxInputValidationError) ErrorName() string { return "SignTxInputValidationError" }

// Error satisfies the builtin error interface
func (e SignTxInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignTxInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignTxInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignTxInputValidationError{}

// Validate checks the field values on Transfer with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// TransferMultiError, or nil if none found. Otherwise, only the first error
// is returned, if any.
func (m *Transfer) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransferId

	// no validation rules for Coin

	// no validation rules for TxId

	// no validation rules for TransferType

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for JpyRate

	// no validation rules for PartnerWalletId

	// no validation rules for PartnerAddress

	// no validation rules for DestinationTag

	// no validation rules for MemoId

	// no validation rules for Message

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for State

	// no validation rules for Result

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransferValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransferValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return TransferMultiError(errors)
	}
	return nil
}

// TransferMultiError is an error wrapping multiple validation errors returned
// by Transfer.Validate(true) if the designated constraints aren't met.
type TransferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferMultiError) AllErrors() []error { return m }

// TransferValidationError is the validation error returned by
// Transfer.Validate if the designated constraints aren't met.
type TransferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferValidationError) ErrorName() string { return "TransferValidationError" }

// Error satisfies the builtin error interface
func (e TransferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransfer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferValidationError{}

// Validate checks the field values on UncheckedTransfer with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in UncheckedTransferMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *UncheckedTransfer) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransferId

	// no validation rules for Coin

	// no validation rules for TxId

	// no validation rules for TransferType

	// no validation rules for State

	// no validation rules for Result

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for JpyRate

	// no validation rules for PartnerWalletId

	// no validation rules for PartnerAddress

	// no validation rules for DestinationTag

	// no validation rules for MemoId

	// no validation rules for Message

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for HasChecked

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = UncheckedTransferValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = UncheckedTransferValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return UncheckedTransferMultiError(errors)
	}
	return nil
}

// UncheckedTransferMultiError is an error wrapping multiple validation errors
// returned by UncheckedTransfer.Validate(true) if the designated constraints
// aren't met.
type UncheckedTransferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UncheckedTransferMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UncheckedTransferMultiError) AllErrors() []error { return m }

// UncheckedTransferValidationError is the validation error returned by
// UncheckedTransfer.Validate if the designated constraints aren't met.
type UncheckedTransferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UncheckedTransferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UncheckedTransferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UncheckedTransferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UncheckedTransferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UncheckedTransferValidationError) ErrorName() string {
	return "UncheckedTransferValidationError"
}

// Error satisfies the builtin error interface
func (e UncheckedTransferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUncheckedTransfer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UncheckedTransferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UncheckedTransferValidationError{}

// Validate checks the field values on EventTriggeredMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in EventTriggeredMessageMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *EventTriggeredMessage) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventTriggeredMessageId

	// no validation rules for EventTriggeredMessageType

	// no validation rules for OwnerId

	// no validation rules for Destination

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = EventTriggeredMessageValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = EventTriggeredMessageValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return EventTriggeredMessageMultiError(errors)
	}
	return nil
}

// EventTriggeredMessageMultiError is an error wrapping multiple validation
// errors returned by EventTriggeredMessage.Validate(true) if the designated
// constraints aren't met.
type EventTriggeredMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventTriggeredMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventTriggeredMessageMultiError) AllErrors() []error { return m }

// EventTriggeredMessageValidationError is the validation error returned by
// EventTriggeredMessage.Validate if the designated constraints aren't met.
type EventTriggeredMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventTriggeredMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventTriggeredMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventTriggeredMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventTriggeredMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventTriggeredMessageValidationError) ErrorName() string {
	return "EventTriggeredMessageValidationError"
}

// Error satisfies the builtin error interface
func (e EventTriggeredMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventTriggeredMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventTriggeredMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventTriggeredMessageValidationError{}

// Validate checks the field values on Rate with the rules defined in the proto
// definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// RateMultiError, or nil if none found. Otherwise, only the first error is
// returned, if any.
func (m *Rate) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Coin

	// no validation rules for Jpy

	if len(errors) > 0 {
		return RateMultiError(errors)
	}
	return nil
}

// RateMultiError is an error wrapping multiple validation errors returned by
// Rate.Validate(true) if the designated constraints aren't met.
type RateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateMultiError) AllErrors() []error { return m }

// RateValidationError is the validation error returned by Rate.Validate if the
// designated constraints aren't met.
type RateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateValidationError) ErrorName() string { return "RateValidationError" }

// Error satisfies the builtin error interface
func (e RateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateValidationError{}

// Validate checks the field values on RateSnapshot with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// RateSnapshotMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *RateSnapshot) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RateSnapshotId

	for key, val := range m.GetRates() {
		_ = val

		// no validation rules for Rates[key]

		if v, ok := interface{}(val).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = RateSnapshotValidationError{
					field:  fmt.Sprintf("Rates[%v]", key),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return RateSnapshotMultiError(errors)
	}
	return nil
}

// RateSnapshotMultiError is an error wrapping multiple validation errors
// returned by RateSnapshot.Validate(true) if the designated constraints
// aren't met.
type RateSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateSnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateSnapshotMultiError) AllErrors() []error { return m }

// RateSnapshotValidationError is the validation error returned by
// RateSnapshot.Validate if the designated constraints aren't met.
type RateSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateSnapshotValidationError) ErrorName() string { return "RateSnapshotValidationError" }

// Error satisfies the builtin error interface
func (e RateSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateSnapshotValidationError{}

// Validate checks the field values on Deactivatability with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in DeactivatabilityMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *Deactivatability) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for Deactivatable

	if len(errors) > 0 {
		return DeactivatabilityMultiError(errors)
	}
	return nil
}

// DeactivatabilityMultiError is an error wrapping multiple validation errors
// returned by Deactivatability.Validate(true) if the designated constraints
// aren't met.
type DeactivatabilityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeactivatabilityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeactivatabilityMultiError) AllErrors() []error { return m }

// DeactivatabilityValidationError is the validation error returned by
// Deactivatability.Validate if the designated constraints aren't met.
type DeactivatabilityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeactivatabilityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeactivatabilityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeactivatabilityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeactivatabilityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeactivatabilityValidationError) ErrorName() string { return "DeactivatabilityValidationError" }

// Error satisfies the builtin error interface
func (e DeactivatabilityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeactivatability.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeactivatabilityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeactivatabilityValidationError{}

// Validate checks the field values on LabeledAddress with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// LabeledAddressMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *LabeledAddress) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LabeledAddressId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Address

	if v, ok := interface{}(m.GetProposal()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = LabeledAddressValidationError{
				field:  "Proposal",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = LabeledAddressValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = LabeledAddressValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return LabeledAddressMultiError(errors)
	}
	return nil
}

// LabeledAddressMultiError is an error wrapping multiple validation errors
// returned by LabeledAddress.Validate(true) if the designated constraints
// aren't met.
type LabeledAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabeledAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabeledAddressMultiError) AllErrors() []error { return m }

// LabeledAddressValidationError is the validation error returned by
// LabeledAddress.Validate if the designated constraints aren't met.
type LabeledAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabeledAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabeledAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabeledAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabeledAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabeledAddressValidationError) ErrorName() string { return "LabeledAddressValidationError" }

// Error satisfies the builtin error interface
func (e LabeledAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabeledAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabeledAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabeledAddressValidationError{}

// Validate checks the field values on LabeledAddressProposal with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in LabeledAddressProposalMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *LabeledAddressProposal) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	// no validation rules for ProposedAddress

	// no validation rules for AddressIsReviewed

	if len(errors) > 0 {
		return LabeledAddressProposalMultiError(errors)
	}
	return nil
}

// LabeledAddressProposalMultiError is an error wrapping multiple validation
// errors returned by LabeledAddressProposal.Validate(true) if the designated
// constraints aren't met.
type LabeledAddressProposalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabeledAddressProposalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabeledAddressProposalMultiError) AllErrors() []error { return m }

// LabeledAddressProposalValidationError is the validation error returned by
// LabeledAddressProposal.Validate if the designated constraints aren't met.
type LabeledAddressProposalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabeledAddressProposalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabeledAddressProposalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabeledAddressProposalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabeledAddressProposalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabeledAddressProposalValidationError) ErrorName() string {
	return "LabeledAddressProposalValidationError"
}

// Error satisfies the builtin error interface
func (e LabeledAddressProposalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabeledAddressProposal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabeledAddressProposalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabeledAddressProposalValidationError{}

// Validate checks the field values on Whitelist with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// WhitelistMultiError, or nil if none found. Otherwise, only the first error
// is returned, if any.
func (m *Whitelist) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WhitelistId

	// no validation rules for Name

	// no validation rules for Coin

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = WhitelistValidationError{
					field:  fmt.Sprintf("Addresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WhitelistValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WhitelistValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return WhitelistMultiError(errors)
	}
	return nil
}

// WhitelistMultiError is an error wrapping multiple validation errors returned
// by Whitelist.Validate(true) if the designated constraints aren't met.
type WhitelistMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WhitelistMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WhitelistMultiError) AllErrors() []error { return m }

// WhitelistValidationError is the validation error returned by
// Whitelist.Validate if the designated constraints aren't met.
type WhitelistValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WhitelistValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WhitelistValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WhitelistValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WhitelistValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WhitelistValidationError) ErrorName() string { return "WhitelistValidationError" }

// Error satisfies the builtin error interface
func (e WhitelistValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWhitelist.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WhitelistValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WhitelistValidationError{}

// Validate checks the field values on TransferLimit with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// TransferLimitMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *TransferLimit) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferLimitId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for HourlyLimit

	// no validation rules for DailyLimit

	// no validation rules for OneTimeLimit

	if v, ok := interface{}(m.GetProposal()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransferLimitValidationError{
				field:  "Proposal",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	// no validation rules for IsReviewed

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransferLimitValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransferLimitValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return TransferLimitMultiError(errors)
	}
	return nil
}

// TransferLimitMultiError is an error wrapping multiple validation errors
// returned by TransferLimit.Validate(true) if the designated constraints
// aren't met.
type TransferLimitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferLimitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferLimitMultiError) AllErrors() []error { return m }

// TransferLimitValidationError is the validation error returned by
// TransferLimit.Validate if the designated constraints aren't met.
type TransferLimitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferLimitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferLimitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferLimitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferLimitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferLimitValidationError) ErrorName() string { return "TransferLimitValidationError" }

// Error satisfies the builtin error interface
func (e TransferLimitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferLimit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferLimitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferLimitValidationError{}

// Validate checks the field values on TransferLimitProposal with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in TransferLimitProposalMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *TransferLimitProposal) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	// no validation rules for ProposedHourlyLimit

	// no validation rules for ProposedDailyLimit

	// no validation rules for ProposedOneTimeLimit

	// no validation rules for IsReviewed

	if len(errors) > 0 {
		return TransferLimitProposalMultiError(errors)
	}
	return nil
}

// TransferLimitProposalMultiError is an error wrapping multiple validation
// errors returned by TransferLimitProposal.Validate(true) if the designated
// constraints aren't met.
type TransferLimitProposalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferLimitProposalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferLimitProposalMultiError) AllErrors() []error { return m }

// TransferLimitProposalValidationError is the validation error returned by
// TransferLimitProposal.Validate if the designated constraints aren't met.
type TransferLimitProposalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferLimitProposalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferLimitProposalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferLimitProposalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferLimitProposalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferLimitProposalValidationError) ErrorName() string {
	return "TransferLimitProposalValidationError"
}

// Error satisfies the builtin error interface
func (e TransferLimitProposalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferLimitProposal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferLimitProposalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferLimitProposalValidationError{}

// Validate checks the field values on Policy with the rules defined in the
// proto definition for this message. If any rules are violated, an error is
// returned. When asked to return all errors, validation continues after first
// violation, and the result is a list of violation errors wrapped in
// PolicyMultiError, or nil if none found. Otherwise, only the first error is
// returned, if any.
func (m *Policy) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PolicyId

	// no validation rules for PolicyType

	// no validation rules for Name

	// no validation rules for IsBasePolicy

	// no validation rules for Coin

	if v, ok := interface{}(m.GetWhitelist()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = PolicyValidationError{
				field:  "Whitelist",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetTransferLimit()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = PolicyValidationError{
				field:  "TransferLimit",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetProposal()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = PolicyValidationError{
				field:  "Proposal",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = PolicyValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = PolicyValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return PolicyMultiError(errors)
	}
	return nil
}

// PolicyMultiError is an error wrapping multiple validation errors returned by
// Policy.Validate(true) if the designated constraints aren't met.
type PolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolicyMultiError) AllErrors() []error { return m }

// PolicyValidationError is the validation error returned by Policy.Validate if
// the designated constraints aren't met.
type PolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolicyValidationError) ErrorName() string { return "PolicyValidationError" }

// Error satisfies the builtin error interface
func (e PolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolicyValidationError{}

// Validate checks the field values on PolicyProposal with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// PolicyProposalMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *PolicyProposal) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	if v, ok := interface{}(m.GetProposedWhitelist()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = PolicyProposalValidationError{
				field:  "ProposedWhitelist",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	// no validation rules for IsReviewed

	if len(errors) > 0 {
		return PolicyProposalMultiError(errors)
	}
	return nil
}

// PolicyProposalMultiError is an error wrapping multiple validation errors
// returned by PolicyProposal.Validate(true) if the designated constraints
// aren't met.
type PolicyProposalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolicyProposalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolicyProposalMultiError) AllErrors() []error { return m }

// PolicyProposalValidationError is the validation error returned by
// PolicyProposal.Validate if the designated constraints aren't met.
type PolicyProposalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolicyProposalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolicyProposalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolicyProposalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolicyProposalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolicyProposalValidationError) ErrorName() string { return "PolicyProposalValidationError" }

// Error satisfies the builtin error interface
func (e PolicyProposalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolicyProposal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolicyProposalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolicyProposalValidationError{}

// Validate checks the field values on TotalBalanceByCoin with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in TotalBalanceByCoinMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *TotalBalanceByCoin) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Coin

	// no validation rules for ColdStringBalance

	// no validation rules for HotStringBalance

	if len(errors) > 0 {
		return TotalBalanceByCoinMultiError(errors)
	}
	return nil
}

// TotalBalanceByCoinMultiError is an error wrapping multiple validation errors
// returned by TotalBalanceByCoin.Validate(true) if the designated constraints
// aren't met.
type TotalBalanceByCoinMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TotalBalanceByCoinMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TotalBalanceByCoinMultiError) AllErrors() []error { return m }

// TotalBalanceByCoinValidationError is the validation error returned by
// TotalBalanceByCoin.Validate if the designated constraints aren't met.
type TotalBalanceByCoinValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TotalBalanceByCoinValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TotalBalanceByCoinValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TotalBalanceByCoinValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TotalBalanceByCoinValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TotalBalanceByCoinValidationError) ErrorName() string {
	return "TotalBalanceByCoinValidationError"
}

// Error satisfies the builtin error interface
func (e TotalBalanceByCoinValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTotalBalanceByCoin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TotalBalanceByCoinValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TotalBalanceByCoinValidationError{}

// Validate checks the field values on TotalBalance with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// TotalBalanceMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *TotalBalance) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for key, val := range m.GetTotalBalances() {
		_ = val

		if val == nil {
			err := TotalBalanceValidationError{
				field:  fmt.Sprintf("TotalBalances[%v]", key),
				reason: "value cannot be sparse, all pairs must be non-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		// no validation rules for TotalBalances[key]

		if v, ok := interface{}(val).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = TotalBalanceValidationError{
					field:  fmt.Sprintf("TotalBalances[%v]", key),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return TotalBalanceMultiError(errors)
	}
	return nil
}

// TotalBalanceMultiError is an error wrapping multiple validation errors
// returned by TotalBalance.Validate(true) if the designated constraints
// aren't met.
type TotalBalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TotalBalanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TotalBalanceMultiError) AllErrors() []error { return m }

// TotalBalanceValidationError is the validation error returned by
// TotalBalance.Validate if the designated constraints aren't met.
type TotalBalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TotalBalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TotalBalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TotalBalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TotalBalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TotalBalanceValidationError) ErrorName() string { return "TotalBalanceValidationError" }

// Error satisfies the builtin error interface
func (e TotalBalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTotalBalance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TotalBalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TotalBalanceValidationError{}

// Validate checks the field values on BalanceSnapshot with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in BalanceSnapshotMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *BalanceSnapshot) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = BalanceSnapshotValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	for key, val := range m.GetTotalBalances() {
		_ = val

		if val == nil {
			err := BalanceSnapshotValidationError{
				field:  fmt.Sprintf("TotalBalances[%v]", key),
				reason: "value cannot be sparse, all pairs must be non-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		// no validation rules for TotalBalances[key]

		if v, ok := interface{}(val).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = BalanceSnapshotValidationError{
					field:  fmt.Sprintf("TotalBalances[%v]", key),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	for key, val := range m.GetRates() {
		_ = val

		if val == nil {
			err := BalanceSnapshotValidationError{
				field:  fmt.Sprintf("Rates[%v]", key),
				reason: "value cannot be sparse, all pairs must be non-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		// no validation rules for Rates[key]

		if v, ok := interface{}(val).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = BalanceSnapshotValidationError{
					field:  fmt.Sprintf("Rates[%v]", key),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return BalanceSnapshotMultiError(errors)
	}
	return nil
}

// BalanceSnapshotMultiError is an error wrapping multiple validation errors
// returned by BalanceSnapshot.Validate(true) if the designated constraints
// aren't met.
type BalanceSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BalanceSnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BalanceSnapshotMultiError) AllErrors() []error { return m }

// BalanceSnapshotValidationError is the validation error returned by
// BalanceSnapshot.Validate if the designated constraints aren't met.
type BalanceSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BalanceSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BalanceSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BalanceSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BalanceSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BalanceSnapshotValidationError) ErrorName() string { return "BalanceSnapshotValidationError" }

// Error satisfies the builtin error interface
func (e BalanceSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBalanceSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BalanceSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BalanceSnapshotValidationError{}

// Validate checks the field values on WalletBalanceSnapshotMap with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in WalletBalanceSnapshotMapMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *WalletBalanceSnapshotMap) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for key, val := range m.GetWalletBalanceSnapshotMap() {
		_ = val

		if val == nil {
			err := WalletBalanceSnapshotMapValidationError{
				field:  fmt.Sprintf("WalletBalanceSnapshotMap[%v]", key),
				reason: "value cannot be sparse, all pairs must be non-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		// no validation rules for WalletBalanceSnapshotMap[key]

		if v, ok := interface{}(val).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = WalletBalanceSnapshotMapValidationError{
					field:  fmt.Sprintf("WalletBalanceSnapshotMap[%v]", key),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return WalletBalanceSnapshotMapMultiError(errors)
	}
	return nil
}

// WalletBalanceSnapshotMapMultiError is an error wrapping multiple validation
// errors returned by WalletBalanceSnapshotMap.Validate(true) if the
// designated constraints aren't met.
type WalletBalanceSnapshotMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletBalanceSnapshotMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletBalanceSnapshotMapMultiError) AllErrors() []error { return m }

// WalletBalanceSnapshotMapValidationError is the validation error returned by
// WalletBalanceSnapshotMap.Validate if the designated constraints aren't met.
type WalletBalanceSnapshotMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletBalanceSnapshotMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletBalanceSnapshotMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletBalanceSnapshotMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletBalanceSnapshotMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletBalanceSnapshotMapValidationError) ErrorName() string {
	return "WalletBalanceSnapshotMapValidationError"
}

// Error satisfies the builtin error interface
func (e WalletBalanceSnapshotMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletBalanceSnapshotMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletBalanceSnapshotMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletBalanceSnapshotMapValidationError{}

// Validate checks the field values on ListWalletBalanceSnapshots with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListWalletBalanceSnapshotsMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListWalletBalanceSnapshots) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWalletBalanceSnapshots() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListWalletBalanceSnapshotsValidationError{
					field:  fmt.Sprintf("WalletBalanceSnapshots[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListWalletBalanceSnapshotsMultiError(errors)
	}
	return nil
}

// ListWalletBalanceSnapshotsMultiError is an error wrapping multiple
// validation errors returned by ListWalletBalanceSnapshots.Validate(true) if
// the designated constraints aren't met.
type ListWalletBalanceSnapshotsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletBalanceSnapshotsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletBalanceSnapshotsMultiError) AllErrors() []error { return m }

// ListWalletBalanceSnapshotsValidationError is the validation error returned
// by ListWalletBalanceSnapshots.Validate if the designated constraints aren't met.
type ListWalletBalanceSnapshotsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletBalanceSnapshotsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletBalanceSnapshotsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletBalanceSnapshotsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletBalanceSnapshotsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletBalanceSnapshotsValidationError) ErrorName() string {
	return "ListWalletBalanceSnapshotsValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletBalanceSnapshotsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletBalanceSnapshots.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletBalanceSnapshotsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletBalanceSnapshotsValidationError{}

// Validate checks the field values on WalletBalanceSnapshot with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in WalletBalanceSnapshotMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *WalletBalanceSnapshot) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WalletBalanceSnapshotValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	// no validation rules for StringBalance

	// no validation rules for Jpy

	if len(errors) > 0 {
		return WalletBalanceSnapshotMultiError(errors)
	}
	return nil
}

// WalletBalanceSnapshotMultiError is an error wrapping multiple validation
// errors returned by WalletBalanceSnapshot.Validate(true) if the designated
// constraints aren't met.
type WalletBalanceSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletBalanceSnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletBalanceSnapshotMultiError) AllErrors() []error { return m }

// WalletBalanceSnapshotValidationError is the validation error returned by
// WalletBalanceSnapshot.Validate if the designated constraints aren't met.
type WalletBalanceSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletBalanceSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletBalanceSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletBalanceSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletBalanceSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletBalanceSnapshotValidationError) ErrorName() string {
	return "WalletBalanceSnapshotValidationError"
}

// Error satisfies the builtin error interface
func (e WalletBalanceSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletBalanceSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletBalanceSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletBalanceSnapshotValidationError{}

// Validate checks the field values on TransferVolumeSnapshots with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in TransferVolumeSnapshotsMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *TransferVolumeSnapshots) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for key, val := range m.GetTransferVolumeSnapshotByTransferType() {
		_ = val

		if val == nil {
			err := TransferVolumeSnapshotsValidationError{
				field:  fmt.Sprintf("TransferVolumeSnapshotByTransferType[%v]", key),
				reason: "value cannot be sparse, all pairs must be non-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		// no validation rules for TransferVolumeSnapshotByTransferType[key]

		if v, ok := interface{}(val).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = TransferVolumeSnapshotsValidationError{
					field:  fmt.Sprintf("TransferVolumeSnapshotByTransferType[%v]", key),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return TransferVolumeSnapshotsMultiError(errors)
	}
	return nil
}

// TransferVolumeSnapshotsMultiError is an error wrapping multiple validation
// errors returned by TransferVolumeSnapshots.Validate(true) if the designated
// constraints aren't met.
type TransferVolumeSnapshotsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferVolumeSnapshotsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferVolumeSnapshotsMultiError) AllErrors() []error { return m }

// TransferVolumeSnapshotsValidationError is the validation error returned by
// TransferVolumeSnapshots.Validate if the designated constraints aren't met.
type TransferVolumeSnapshotsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferVolumeSnapshotsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferVolumeSnapshotsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferVolumeSnapshotsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferVolumeSnapshotsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferVolumeSnapshotsValidationError) ErrorName() string {
	return "TransferVolumeSnapshotsValidationError"
}

// Error satisfies the builtin error interface
func (e TransferVolumeSnapshotsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferVolumeSnapshots.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferVolumeSnapshotsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferVolumeSnapshotsValidationError{}

// Validate checks the field values on ListTransferVolumeSnapshots with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ListTransferVolumeSnapshotsMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ListTransferVolumeSnapshots) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransferVolumeSnapshots() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListTransferVolumeSnapshotsValidationError{
					field:  fmt.Sprintf("TransferVolumeSnapshots[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListTransferVolumeSnapshotsMultiError(errors)
	}
	return nil
}

// ListTransferVolumeSnapshotsMultiError is an error wrapping multiple
// validation errors returned by ListTransferVolumeSnapshots.Validate(true) if
// the designated constraints aren't met.
type ListTransferVolumeSnapshotsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransferVolumeSnapshotsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransferVolumeSnapshotsMultiError) AllErrors() []error { return m }

// ListTransferVolumeSnapshotsValidationError is the validation error returned
// by ListTransferVolumeSnapshots.Validate if the designated constraints
// aren't met.
type ListTransferVolumeSnapshotsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransferVolumeSnapshotsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransferVolumeSnapshotsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransferVolumeSnapshotsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransferVolumeSnapshotsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransferVolumeSnapshotsValidationError) ErrorName() string {
	return "ListTransferVolumeSnapshotsValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransferVolumeSnapshotsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransferVolumeSnapshots.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransferVolumeSnapshotsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransferVolumeSnapshotsValidationError{}

// Validate checks the field values on TransferVolumeSnapshot with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in TransferVolumeSnapshotMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *TransferVolumeSnapshot) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetTargetTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = TransferVolumeSnapshotValidationError{
				field:  "TargetTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	for key, val := range m.GetTransferVolumeByCoin() {
		_ = val

		// no validation rules for TransferVolumeByCoin[key]

		if v, ok := interface{}(val).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = TransferVolumeSnapshotValidationError{
					field:  fmt.Sprintf("TransferVolumeByCoin[%v]", key),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return TransferVolumeSnapshotMultiError(errors)
	}
	return nil
}

// TransferVolumeSnapshotMultiError is an error wrapping multiple validation
// errors returned by TransferVolumeSnapshot.Validate(true) if the designated
// constraints aren't met.
type TransferVolumeSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferVolumeSnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferVolumeSnapshotMultiError) AllErrors() []error { return m }

// TransferVolumeSnapshotValidationError is the validation error returned by
// TransferVolumeSnapshot.Validate if the designated constraints aren't met.
type TransferVolumeSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferVolumeSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferVolumeSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferVolumeSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferVolumeSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferVolumeSnapshotValidationError) ErrorName() string {
	return "TransferVolumeSnapshotValidationError"
}

// Error satisfies the builtin error interface
func (e TransferVolumeSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferVolumeSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferVolumeSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferVolumeSnapshotValidationError{}

// Validate checks the field values on TransferVolume with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// TransferVolumeMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *TransferVolume) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Coin

	// no validation rules for HotStringVolume

	// no validation rules for ColdStringVolume

	// no validation rules for HotStringJpyVolume

	// no validation rules for ColdStringJpyVolume

	// no validation rules for HotNumber

	// no validation rules for ColdNumber

	// no validation rules for TransferType

	if len(errors) > 0 {
		return TransferVolumeMultiError(errors)
	}
	return nil
}

// TransferVolumeMultiError is an error wrapping multiple validation errors
// returned by TransferVolume.Validate(true) if the designated constraints
// aren't met.
type TransferVolumeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferVolumeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferVolumeMultiError) AllErrors() []error { return m }

// TransferVolumeValidationError is the validation error returned by
// TransferVolume.Validate if the designated constraints aren't met.
type TransferVolumeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferVolumeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferVolumeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferVolumeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferVolumeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferVolumeValidationError) ErrorName() string { return "TransferVolumeValidationError" }

// Error satisfies the builtin error interface
func (e TransferVolumeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferVolume.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferVolumeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferVolumeValidationError{}

// Validate checks the field values on WalletTransferVolumeSnapshots with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in WalletTransferVolumeSnapshotsMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *WalletTransferVolumeSnapshots) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for key, val := range m.GetWalletTransferVolumeSnapshotByWalletId() {
		_ = val

		if val == nil {
			err := WalletTransferVolumeSnapshotsValidationError{
				field:  fmt.Sprintf("WalletTransferVolumeSnapshotByWalletId[%v]", key),
				reason: "value cannot be sparse, all pairs must be non-nil",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

		// no validation rules for WalletTransferVolumeSnapshotByWalletId[key]

		if v, ok := interface{}(val).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = WalletTransferVolumeSnapshotsValidationError{
					field:  fmt.Sprintf("WalletTransferVolumeSnapshotByWalletId[%v]", key),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return WalletTransferVolumeSnapshotsMultiError(errors)
	}
	return nil
}

// WalletTransferVolumeSnapshotsMultiError is an error wrapping multiple
// validation errors returned by WalletTransferVolumeSnapshots.Validate(true)
// if the designated constraints aren't met.
type WalletTransferVolumeSnapshotsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletTransferVolumeSnapshotsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletTransferVolumeSnapshotsMultiError) AllErrors() []error { return m }

// WalletTransferVolumeSnapshotsValidationError is the validation error
// returned by WalletTransferVolumeSnapshots.Validate if the designated
// constraints aren't met.
type WalletTransferVolumeSnapshotsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletTransferVolumeSnapshotsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletTransferVolumeSnapshotsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletTransferVolumeSnapshotsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletTransferVolumeSnapshotsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletTransferVolumeSnapshotsValidationError) ErrorName() string {
	return "WalletTransferVolumeSnapshotsValidationError"
}

// Error satisfies the builtin error interface
func (e WalletTransferVolumeSnapshotsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletTransferVolumeSnapshots.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletTransferVolumeSnapshotsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletTransferVolumeSnapshotsValidationError{}

// Validate checks the field values on ListWalletTransferVolumeSnapshots with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListWalletTransferVolumeSnapshotsMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListWalletTransferVolumeSnapshots) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWalletTransferVolumeSnapshots() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListWalletTransferVolumeSnapshotsValidationError{
					field:  fmt.Sprintf("WalletTransferVolumeSnapshots[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListWalletTransferVolumeSnapshotsMultiError(errors)
	}
	return nil
}

// ListWalletTransferVolumeSnapshotsMultiError is an error wrapping multiple
// validation errors returned by
// ListWalletTransferVolumeSnapshots.Validate(true) if the designated
// constraints aren't met.
type ListWalletTransferVolumeSnapshotsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletTransferVolumeSnapshotsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletTransferVolumeSnapshotsMultiError) AllErrors() []error { return m }

// ListWalletTransferVolumeSnapshotsValidationError is the validation error
// returned by ListWalletTransferVolumeSnapshots.Validate if the designated
// constraints aren't met.
type ListWalletTransferVolumeSnapshotsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletTransferVolumeSnapshotsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletTransferVolumeSnapshotsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletTransferVolumeSnapshotsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletTransferVolumeSnapshotsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletTransferVolumeSnapshotsValidationError) ErrorName() string {
	return "ListWalletTransferVolumeSnapshotsValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletTransferVolumeSnapshotsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletTransferVolumeSnapshots.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletTransferVolumeSnapshotsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletTransferVolumeSnapshotsValidationError{}

// Validate checks the field values on WalletTransferVolumeSnapshot with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in WalletTransferVolumeSnapshotMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *WalletTransferVolumeSnapshot) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if v, ok := interface{}(m.GetTargetTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WalletTransferVolumeSnapshotValidationError{
				field:  "TargetTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	for key, val := range m.GetWalletTransferVolumeByTransferType() {
		_ = val

		// no validation rules for WalletTransferVolumeByTransferType[key]

		if v, ok := interface{}(val).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = WalletTransferVolumeSnapshotValidationError{
					field:  fmt.Sprintf("WalletTransferVolumeByTransferType[%v]", key),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return WalletTransferVolumeSnapshotMultiError(errors)
	}
	return nil
}

// WalletTransferVolumeSnapshotMultiError is an error wrapping multiple
// validation errors returned by WalletTransferVolumeSnapshot.Validate(true)
// if the designated constraints aren't met.
type WalletTransferVolumeSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletTransferVolumeSnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletTransferVolumeSnapshotMultiError) AllErrors() []error { return m }

// WalletTransferVolumeSnapshotValidationError is the validation error returned
// by WalletTransferVolumeSnapshot.Validate if the designated constraints
// aren't met.
type WalletTransferVolumeSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletTransferVolumeSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletTransferVolumeSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletTransferVolumeSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletTransferVolumeSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletTransferVolumeSnapshotValidationError) ErrorName() string {
	return "WalletTransferVolumeSnapshotValidationError"
}

// Error satisfies the builtin error interface
func (e WalletTransferVolumeSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletTransferVolumeSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletTransferVolumeSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletTransferVolumeSnapshotValidationError{}

// Validate checks the field values on WalletTransferVolume with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in WalletTransferVolumeMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *WalletTransferVolume) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StringVolume

	// no validation rules for StringJpyVolume

	// no validation rules for Number

	// no validation rules for TransferType

	if len(errors) > 0 {
		return WalletTransferVolumeMultiError(errors)
	}
	return nil
}

// WalletTransferVolumeMultiError is an error wrapping multiple validation
// errors returned by WalletTransferVolume.Validate(true) if the designated
// constraints aren't met.
type WalletTransferVolumeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletTransferVolumeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletTransferVolumeMultiError) AllErrors() []error { return m }

// WalletTransferVolumeValidationError is the validation error returned by
// WalletTransferVolume.Validate if the designated constraints aren't met.
type WalletTransferVolumeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletTransferVolumeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletTransferVolumeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletTransferVolumeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletTransferVolumeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletTransferVolumeValidationError) ErrorName() string {
	return "WalletTransferVolumeValidationError"
}

// Error satisfies the builtin error interface
func (e WalletTransferVolumeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletTransferVolume.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletTransferVolumeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletTransferVolumeValidationError{}

// Validate checks the field values on Confirmation with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// ConfirmationMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *Confirmation) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Coin

	// no validation rules for Confirmation

	if len(errors) > 0 {
		return ConfirmationMultiError(errors)
	}
	return nil
}

// ConfirmationMultiError is an error wrapping multiple validation errors
// returned by Confirmation.Validate(true) if the designated constraints
// aren't met.
type ConfirmationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfirmationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfirmationMultiError) AllErrors() []error { return m }

// ConfirmationValidationError is the validation error returned by
// Confirmation.Validate if the designated constraints aren't met.
type ConfirmationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfirmationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfirmationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfirmationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfirmationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfirmationValidationError) ErrorName() string { return "ConfirmationValidationError" }

// Error satisfies the builtin error interface
func (e ConfirmationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfirmation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfirmationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfirmationValidationError{}

// Validate checks the field values on WalletFlushSetting with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in WalletFlushSettingMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *WalletFlushSetting) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerId

	// no validation rules for Coin

	// no validation rules for DestinationWalletId

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WalletFlushSettingValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WalletFlushSettingValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return WalletFlushSettingMultiError(errors)
	}
	return nil
}

// WalletFlushSettingMultiError is an error wrapping multiple validation errors
// returned by WalletFlushSetting.Validate(true) if the designated constraints
// aren't met.
type WalletFlushSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletFlushSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletFlushSettingMultiError) AllErrors() []error { return m }

// WalletFlushSettingValidationError is the validation error returned by
// WalletFlushSetting.Validate if the designated constraints aren't met.
type WalletFlushSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletFlushSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletFlushSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletFlushSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletFlushSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletFlushSettingValidationError) ErrorName() string {
	return "WalletFlushSettingValidationError"
}

// Error satisfies the builtin error interface
func (e WalletFlushSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletFlushSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletFlushSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletFlushSettingValidationError{}

// Validate checks the field values on CompensationFee with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in CompensationFeeMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *CompensationFee) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StringValue

	// no validation rules for IsSpent

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = CompensationFeeValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return CompensationFeeMultiError(errors)
	}
	return nil
}

// CompensationFeeMultiError is an error wrapping multiple validation errors
// returned by CompensationFee.Validate(true) if the designated constraints
// aren't met.
type CompensationFeeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompensationFeeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompensationFeeMultiError) AllErrors() []error { return m }

// CompensationFeeValidationError is the validation error returned by
// CompensationFee.Validate if the designated constraints aren't met.
type CompensationFeeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompensationFeeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompensationFeeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompensationFeeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompensationFeeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompensationFeeValidationError) ErrorName() string { return "CompensationFeeValidationError" }

// Error satisfies the builtin error interface
func (e CompensationFeeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompensationFee.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompensationFeeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompensationFeeValidationError{}

// Validate checks the field values on WalletGroup with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// WalletGroupMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *WalletGroup) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletGroupId

	// no validation rules for Name

	// no validation rules for Coin

	for idx, item := range m.GetWallets() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = WalletGroupValidationError{
					field:  fmt.Sprintf("Wallets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	// no validation rules for WatchOnly

	if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WalletGroupValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate(bool) error }); ok {
		if err := v.Validate(all); err != nil {
			err = WalletGroupValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}
	}

	if len(errors) > 0 {
		return WalletGroupMultiError(errors)
	}
	return nil
}

// WalletGroupMultiError is an error wrapping multiple validation errors
// returned by WalletGroup.Validate(true) if the designated constraints aren't met.
type WalletGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletGroupMultiError) AllErrors() []error { return m }

// WalletGroupValidationError is the validation error returned by
// WalletGroup.Validate if the designated constraints aren't met.
type WalletGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletGroupValidationError) ErrorName() string { return "WalletGroupValidationError" }

// Error satisfies the builtin error interface
func (e WalletGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletGroupValidationError{}

// Validate checks the field values on RequestTxOutput with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in RequestTxOutputMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *RequestTxOutput) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) < 3 {
		err := RequestTxOutputValidationError{
			field:  "Address",
			reason: "value length must be at least 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetStringValue()) < 1 {
		err := RequestTxOutputValidationError{
			field:  "StringValue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RequestTxOutputMultiError(errors)
	}
	return nil
}

// RequestTxOutputMultiError is an error wrapping multiple validation errors
// returned by RequestTxOutput.Validate(true) if the designated constraints
// aren't met.
type RequestTxOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestTxOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestTxOutputMultiError) AllErrors() []error { return m }

// RequestTxOutputValidationError is the validation error returned by
// RequestTxOutput.Validate if the designated constraints aren't met.
type RequestTxOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestTxOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestTxOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestTxOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestTxOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestTxOutputValidationError) ErrorName() string { return "RequestTxOutputValidationError" }

// Error satisfies the builtin error interface
func (e RequestTxOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestTxOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestTxOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestTxOutputValidationError{}

// Validate checks the field values on RequestSignedInfo with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in RequestSignedInfoMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *RequestSignedInfo) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetSignatures()) < 1 {
		err := RequestSignedInfoValidationError{
			field:  "Signatures",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSignatures() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = RequestSignedInfoValidationError{
					field:  fmt.Sprintf("Signatures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return RequestSignedInfoMultiError(errors)
	}
	return nil
}

// RequestSignedInfoMultiError is an error wrapping multiple validation errors
// returned by RequestSignedInfo.Validate(true) if the designated constraints
// aren't met.
type RequestSignedInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestSignedInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestSignedInfoMultiError) AllErrors() []error { return m }

// RequestSignedInfoValidationError is the validation error returned by
// RequestSignedInfo.Validate if the designated constraints aren't met.
type RequestSignedInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestSignedInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestSignedInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestSignedInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestSignedInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestSignedInfoValidationError) ErrorName() string {
	return "RequestSignedInfoValidationError"
}

// Error satisfies the builtin error interface
func (e RequestSignedInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestSignedInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestSignedInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestSignedInfoValidationError{}

// Validate checks the field values on RequestSignature with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in RequestSignatureMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *RequestSignature) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SignIndex

	if utf8.RuneCountInString(m.GetSignature()) < 1 {
		err := RequestSignatureValidationError{
			field:  "Signature",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RequestSignatureMultiError(errors)
	}
	return nil
}

// RequestSignatureMultiError is an error wrapping multiple validation errors
// returned by RequestSignature.Validate(true) if the designated constraints
// aren't met.
type RequestSignatureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestSignatureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestSignatureMultiError) AllErrors() []error { return m }

// RequestSignatureValidationError is the validation error returned by
// RequestSignature.Validate if the designated constraints aren't met.
type RequestSignatureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestSignatureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestSignatureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestSignatureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestSignatureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestSignatureValidationError) ErrorName() string { return "RequestSignatureValidationError" }

// Error satisfies the builtin error interface
func (e RequestSignatureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestSignature.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestSignatureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestSignatureValidationError{}

// Validate checks the field values on RequestTransferLimitEntry with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in RequestTransferLimitEntryMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *RequestTransferLimitEntry) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _RequestTransferLimitEntry_TransferLimitType_NotInLookup[m.GetTransferLimitType()]; ok {
		err := RequestTransferLimitEntryValidationError{
			field:  "TransferLimitType",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := TransferLimitType_name[int32(m.GetTransferLimitType())]; !ok {
		err := RequestTransferLimitEntryValidationError{
			field:  "TransferLimitType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTransferLimitValue() < 0 {
		err := RequestTransferLimitEntryValidationError{
			field:  "TransferLimitValue",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RequestTransferLimitEntryMultiError(errors)
	}
	return nil
}

// RequestTransferLimitEntryMultiError is an error wrapping multiple validation
// errors returned by RequestTransferLimitEntry.Validate(true) if the
// designated constraints aren't met.
type RequestTransferLimitEntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestTransferLimitEntryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestTransferLimitEntryMultiError) AllErrors() []error { return m }

// RequestTransferLimitEntryValidationError is the validation error returned by
// RequestTransferLimitEntry.Validate if the designated constraints aren't met.
type RequestTransferLimitEntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestTransferLimitEntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestTransferLimitEntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestTransferLimitEntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestTransferLimitEntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestTransferLimitEntryValidationError) ErrorName() string {
	return "RequestTransferLimitEntryValidationError"
}

// Error satisfies the builtin error interface
func (e RequestTransferLimitEntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestTransferLimitEntry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestTransferLimitEntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestTransferLimitEntryValidationError{}

var _RequestTransferLimitEntry_TransferLimitType_NotInLookup = map[TransferLimitType]struct{}{
	0: {},
}

// Validate checks the field values on RequestRate with the rules defined in
// the proto definition for this message. If any rules are violated, an error
// is returned. When asked to return all errors, validation continues after
// first violation, and the result is a list of violation errors wrapped in
// RequestRateMultiError, or nil if none found. Otherwise, only the first
// error is returned, if any.
func (m *RequestRate) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _RequestRate_Coin_NotInLookup[m.GetCoin()]; ok {
		err := RequestRateValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := RequestRateValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetJpy() < 0 {
		err := RequestRateValidationError{
			field:  "Jpy",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RequestRateMultiError(errors)
	}
	return nil
}

// RequestRateMultiError is an error wrapping multiple validation errors
// returned by RequestRate.Validate(true) if the designated constraints aren't met.
type RequestRateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestRateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestRateMultiError) AllErrors() []error { return m }

// RequestRateValidationError is the validation error returned by
// RequestRate.Validate if the designated constraints aren't met.
type RequestRateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestRateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestRateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestRateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestRateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestRateValidationError) ErrorName() string { return "RequestRateValidationError" }

// Error satisfies the builtin error interface
func (e RequestRateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestRate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestRateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestRateValidationError{}

var _RequestRate_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

// Validate checks the field values on SubstrateChildAddress with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SubstrateChildAddressMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *SubstrateChildAddress) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for AccountId

	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	if len(errors) > 0 {
		return SubstrateChildAddressMultiError(errors)
	}
	return nil
}

// SubstrateChildAddressMultiError is an error wrapping multiple validation
// errors returned by SubstrateChildAddress.Validate(true) if the designated
// constraints aren't met.
type SubstrateChildAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubstrateChildAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubstrateChildAddressMultiError) AllErrors() []error { return m }

// SubstrateChildAddressValidationError is the validation error returned by
// SubstrateChildAddress.Validate if the designated constraints aren't met.
type SubstrateChildAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubstrateChildAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubstrateChildAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubstrateChildAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubstrateChildAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubstrateChildAddressValidationError) ErrorName() string {
	return "SubstrateChildAddressValidationError"
}

// Error satisfies the builtin error interface
func (e SubstrateChildAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubstrateChildAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubstrateChildAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubstrateChildAddressValidationError{}

// Validate checks the field values on IOSTChildAccount with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in IOSTChildAccountMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *IOSTChildAccount) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for AccountId

	// no validation rules for AccountName

	if len(errors) > 0 {
		return IOSTChildAccountMultiError(errors)
	}
	return nil
}

// IOSTChildAccountMultiError is an error wrapping multiple validation errors
// returned by IOSTChildAccount.Validate(true) if the designated constraints
// aren't met.
type IOSTChildAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IOSTChildAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IOSTChildAccountMultiError) AllErrors() []error { return m }

// IOSTChildAccountValidationError is the validation error returned by
// IOSTChildAccount.Validate if the designated constraints aren't met.
type IOSTChildAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IOSTChildAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IOSTChildAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IOSTChildAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IOSTChildAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IOSTChildAccountValidationError) ErrorName() string { return "IOSTChildAccountValidationError" }

// Error satisfies the builtin error interface
func (e IOSTChildAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIOSTChildAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IOSTChildAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IOSTChildAccountValidationError{}

// Validate checks the field values on IOSTCallerAccount with the rules defined
// in the proto definition for this message. If any rules are violated, an
// error is returned. When asked to return all errors, validation continues
// after first violation, and the result is a list of violation errors wrapped
// in IOSTCallerAccountMultiError, or nil if none found. Otherwise, only the
// first error is returned, if any.
func (m *IOSTCallerAccount) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountName

	// no validation rules for Balance

	// no validation rules for StringBalance

	if len(errors) > 0 {
		return IOSTCallerAccountMultiError(errors)
	}
	return nil
}

// IOSTCallerAccountMultiError is an error wrapping multiple validation errors
// returned by IOSTCallerAccount.Validate(true) if the designated constraints
// aren't met.
type IOSTCallerAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IOSTCallerAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IOSTCallerAccountMultiError) AllErrors() []error { return m }

// IOSTCallerAccountValidationError is the validation error returned by
// IOSTCallerAccount.Validate if the designated constraints aren't met.
type IOSTCallerAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IOSTCallerAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IOSTCallerAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IOSTCallerAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IOSTCallerAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IOSTCallerAccountValidationError) ErrorName() string {
	return "IOSTCallerAccountValidationError"
}

// Error satisfies the builtin error interface
func (e IOSTCallerAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIOSTCallerAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IOSTCallerAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IOSTCallerAccountValidationError{}
