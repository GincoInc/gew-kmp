// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: gincoinc/adamant/global/v1/adamantglobalv1/model.proto

package adamantglobalv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	gincoincglobalv1 "github.com/GincoInc/gew-kmp/gen/gincoinc/global/v1/gincoincglobalv1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = gincoincglobalv1.StakingValidatorStatus(0)
)

// Validate checks the field values on Wallet with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Wallet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Wallet with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in WalletMultiError, or nil if none found.
func (m *Wallet) ValidateAll() error {
	return m.validate(true)
}

func (m *Wallet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for HdAccount

	// no validation rules for WalletType

	// no validation rules for AddressType

	// no validation rules for M

	// no validation rules for N

	// no validation rules for State

	for idx, item := range m.GetKeys() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WalletValidationError{
						field:  fmt.Sprintf("Keys[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WalletValidationError{
						field:  fmt.Sprintf("Keys[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WalletValidationError{
					field:  fmt.Sprintf("Keys[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMembers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WalletValidationError{
						field:  fmt.Sprintf("Members[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WalletValidationError{
						field:  fmt.Sprintf("Members[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WalletValidationError{
					field:  fmt.Sprintf("Members[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequiredApprovalCount

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for Address

	// no validation rules for PolicyId

	if all {
		switch v := interface{}(m.GetProposal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalletValidationError{
					field:  "Proposal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalletValidationError{
					field:  "Proposal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProposal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalletValidationError{
				field:  "Proposal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DestinationWalletId

	// no validation rules for WatchOnly

	// no validation rules for AddressNumber

	// no validation rules for ShouldCheckRemittance

	// no validation rules for InheritWalletId

	// no validation rules for IsStakingAvailable

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalletValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalletValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalletValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalletValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalletValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalletValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WalletMultiError(errors)
	}

	return nil
}

// WalletMultiError is an error wrapping multiple validation errors returned by
// Wallet.ValidateAll() if the designated constraints aren't met.
type WalletMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletMultiError) AllErrors() []error { return m }

// WalletValidationError is the validation error returned by Wallet.Validate if
// the designated constraints aren't met.
type WalletValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletValidationError) ErrorName() string { return "WalletValidationError" }

// Error satisfies the builtin error interface
func (e WalletValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWallet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletValidationError{}

// Validate checks the field values on WalletWithoutBalance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WalletWithoutBalance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalletWithoutBalance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WalletWithoutBalanceMultiError, or nil if none found.
func (m *WalletWithoutBalance) ValidateAll() error {
	return m.validate(true)
}

func (m *WalletWithoutBalance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for HdAccount

	// no validation rules for WalletType

	// no validation rules for AddressType

	// no validation rules for M

	// no validation rules for N

	// no validation rules for State

	for idx, item := range m.GetKeys() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WalletWithoutBalanceValidationError{
						field:  fmt.Sprintf("Keys[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WalletWithoutBalanceValidationError{
						field:  fmt.Sprintf("Keys[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WalletWithoutBalanceValidationError{
					field:  fmt.Sprintf("Keys[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMembers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WalletWithoutBalanceValidationError{
						field:  fmt.Sprintf("Members[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WalletWithoutBalanceValidationError{
						field:  fmt.Sprintf("Members[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WalletWithoutBalanceValidationError{
					field:  fmt.Sprintf("Members[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for RequiredApprovalCount

	// no validation rules for Address

	// no validation rules for PolicyId

	if all {
		switch v := interface{}(m.GetProposal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalletWithoutBalanceValidationError{
					field:  "Proposal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalletWithoutBalanceValidationError{
					field:  "Proposal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProposal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalletWithoutBalanceValidationError{
				field:  "Proposal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for DestinationWalletId

	// no validation rules for WatchOnly

	// no validation rules for ShouldCheckRemittance

	// no validation rules for InheritWalletId

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalletWithoutBalanceValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalletWithoutBalanceValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalletWithoutBalanceValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalletWithoutBalanceValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalletWithoutBalanceValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalletWithoutBalanceValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WalletWithoutBalanceMultiError(errors)
	}

	return nil
}

// WalletWithoutBalanceMultiError is an error wrapping multiple validation
// errors returned by WalletWithoutBalance.ValidateAll() if the designated
// constraints aren't met.
type WalletWithoutBalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletWithoutBalanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletWithoutBalanceMultiError) AllErrors() []error { return m }

// WalletWithoutBalanceValidationError is the validation error returned by
// WalletWithoutBalance.Validate if the designated constraints aren't met.
type WalletWithoutBalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletWithoutBalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletWithoutBalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletWithoutBalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletWithoutBalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletWithoutBalanceValidationError) ErrorName() string {
	return "WalletWithoutBalanceValidationError"
}

// Error satisfies the builtin error interface
func (e WalletWithoutBalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletWithoutBalance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletWithoutBalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletWithoutBalanceValidationError{}

// Validate checks the field values on StakingWallet with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StakingWallet) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StakingWallet with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StakingWalletMultiError, or
// nil if none found.
func (m *StakingWallet) ValidateAll() error {
	return m.validate(true)
}

func (m *StakingWallet) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for WalletType

	// no validation rules for AddressType

	// no validation rules for State

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for SpendableBalance

	// no validation rules for StringSpendableBalance

	// no validation rules for StakingBalance

	// no validation rules for StringStakingBalance

	// no validation rules for ClaimableRewardBalance

	// no validation rules for StringClaimableRewardBalance

	// no validation rules for WithdrawableUnstakedBalance

	// no validation rules for StringWithdrawableUnstakedBalance

	// no validation rules for FrozenUnstakedBalance

	// no validation rules for StringFrozenUnstakedBalance

	// no validation rules for Address

	// no validation rules for ActiveValidatorsCount

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StakingWalletValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StakingWalletValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StakingWalletValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StakingWalletValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StakingWalletValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StakingWalletValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StakingWalletMultiError(errors)
	}

	return nil
}

// StakingWalletMultiError is an error wrapping multiple validation errors
// returned by StakingWallet.ValidateAll() if the designated constraints
// aren't met.
type StakingWalletMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StakingWalletMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StakingWalletMultiError) AllErrors() []error { return m }

// StakingWalletValidationError is the validation error returned by
// StakingWallet.Validate if the designated constraints aren't met.
type StakingWalletValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StakingWalletValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StakingWalletValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StakingWalletValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StakingWalletValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StakingWalletValidationError) ErrorName() string { return "StakingWalletValidationError" }

// Error satisfies the builtin error interface
func (e StakingWalletValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStakingWallet.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StakingWalletValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StakingWalletValidationError{}

// Validate checks the field values on WalletProposal with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WalletProposal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalletProposal with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WalletProposalMultiError,
// or nil if none found.
func (m *WalletProposal) ValidateAll() error {
	return m.validate(true)
}

func (m *WalletProposal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ProposalType

	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	// no validation rules for ProposedPolicy

	// no validation rules for ProposedRequiredApprovalCount

	// no validation rules for IsReviewed

	if len(errors) > 0 {
		return WalletProposalMultiError(errors)
	}

	return nil
}

// WalletProposalMultiError is an error wrapping multiple validation errors
// returned by WalletProposal.ValidateAll() if the designated constraints
// aren't met.
type WalletProposalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletProposalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletProposalMultiError) AllErrors() []error { return m }

// WalletProposalValidationError is the validation error returned by
// WalletProposal.Validate if the designated constraints aren't met.
type WalletProposalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletProposalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletProposalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletProposalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletProposalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletProposalValidationError) ErrorName() string { return "WalletProposalValidationError" }

// Error satisfies the builtin error interface
func (e WalletProposalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletProposal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletProposalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletProposalValidationError{}

// Validate checks the field values on WalletMember with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WalletMember) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalletMember with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WalletMemberMultiError, or
// nil if none found.
func (m *WalletMember) ValidateAll() error {
	return m.validate(true)
}

func (m *WalletMember) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for Name

	// no validation rules for Email

	// no validation rules for Role

	// no validation rules for IsKeyRegistered

	// no validation rules for IsMaster

	// no validation rules for IsValidatedToCreateWallet

	if len(errors) > 0 {
		return WalletMemberMultiError(errors)
	}

	return nil
}

// WalletMemberMultiError is an error wrapping multiple validation errors
// returned by WalletMember.ValidateAll() if the designated constraints aren't met.
type WalletMemberMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletMemberMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletMemberMultiError) AllErrors() []error { return m }

// WalletMemberValidationError is the validation error returned by
// WalletMember.Validate if the designated constraints aren't met.
type WalletMemberValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletMemberValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletMemberValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletMemberValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletMemberValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletMemberValidationError) ErrorName() string { return "WalletMemberValidationError" }

// Error satisfies the builtin error interface
func (e WalletMemberValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletMember.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletMemberValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletMemberValidationError{}

// Validate checks the field values on Key with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Key) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Key with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in KeyMultiError, or nil if none found.
func (m *Key) ValidateAll() error {
	return m.validate(true)
}

func (m *Key) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for KeyId

	// no validation rules for KeyIndex

	// no validation rules for HdIndex

	if len(errors) > 0 {
		return KeyMultiError(errors)
	}

	return nil
}

// KeyMultiError is an error wrapping multiple validation errors returned by
// Key.ValidateAll() if the designated constraints aren't met.
type KeyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KeyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KeyMultiError) AllErrors() []error { return m }

// KeyValidationError is the validation error returned by Key.Validate if the
// designated constraints aren't met.
type KeyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KeyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KeyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KeyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KeyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KeyValidationError) ErrorName() string { return "KeyValidationError" }

// Error satisfies the builtin error interface
func (e KeyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKey.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KeyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KeyValidationError{}

// Validate checks the field values on Address with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Address) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Address with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in AddressMultiError, or nil if none found.
func (m *Address) ValidateAll() error {
	return m.validate(true)
}

func (m *Address) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for AddressId

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for Address

	// no validation rules for Index

	// no validation rules for HdChange

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for State

	// no validation rules for AddressType

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddressValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddressValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddressValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddressValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddressValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddressValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddressMultiError(errors)
	}

	return nil
}

// AddressMultiError is an error wrapping multiple validation errors returned
// by Address.ValidateAll() if the designated constraints aren't met.
type AddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressMultiError) AllErrors() []error { return m }

// AddressValidationError is the validation error returned by Address.Validate
// if the designated constraints aren't met.
type AddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressValidationError) ErrorName() string { return "AddressValidationError" }

// Error satisfies the builtin error interface
func (e AddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressValidationError{}

// Validate checks the field values on AddressWithoutBalance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddressWithoutBalance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddressWithoutBalance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddressWithoutBalanceMultiError, or nil if none found.
func (m *AddressWithoutBalance) ValidateAll() error {
	return m.validate(true)
}

func (m *AddressWithoutBalance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for AddressId

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for Address

	// no validation rules for Index

	// no validation rules for HdChange

	// no validation rules for State

	// no validation rules for AddressType

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddressWithoutBalanceValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddressWithoutBalanceValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddressWithoutBalanceValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AddressWithoutBalanceValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AddressWithoutBalanceValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AddressWithoutBalanceValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AddressWithoutBalanceMultiError(errors)
	}

	return nil
}

// AddressWithoutBalanceMultiError is an error wrapping multiple validation
// errors returned by AddressWithoutBalance.ValidateAll() if the designated
// constraints aren't met.
type AddressWithoutBalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressWithoutBalanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressWithoutBalanceMultiError) AllErrors() []error { return m }

// AddressWithoutBalanceValidationError is the validation error returned by
// AddressWithoutBalance.Validate if the designated constraints aren't met.
type AddressWithoutBalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressWithoutBalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressWithoutBalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressWithoutBalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressWithoutBalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressWithoutBalanceValidationError) ErrorName() string {
	return "AddressWithoutBalanceValidationError"
}

// Error satisfies the builtin error interface
func (e AddressWithoutBalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressWithoutBalance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressWithoutBalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressWithoutBalanceValidationError{}

// Validate checks the field values on FlushedAddress with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FlushedAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlushedAddress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FlushedAddressMultiError,
// or nil if none found.
func (m *FlushedAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *FlushedAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for AddressId

	// no validation rules for Coin

	// no validation rules for Address

	// no validation rules for Index

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for State

	// no validation rules for AddressType

	if len(errors) > 0 {
		return FlushedAddressMultiError(errors)
	}

	return nil
}

// FlushedAddressMultiError is an error wrapping multiple validation errors
// returned by FlushedAddress.ValidateAll() if the designated constraints
// aren't met.
type FlushedAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlushedAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlushedAddressMultiError) AllErrors() []error { return m }

// FlushedAddressValidationError is the validation error returned by
// FlushedAddress.Validate if the designated constraints aren't met.
type FlushedAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlushedAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlushedAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlushedAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlushedAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlushedAddressValidationError) ErrorName() string { return "FlushedAddressValidationError" }

// Error satisfies the builtin error interface
func (e FlushedAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlushedAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlushedAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlushedAddressValidationError{}

// Validate checks the field values on EthereumFeeAddress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EthereumFeeAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EthereumFeeAddress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EthereumFeeAddressMultiError, or nil if none found.
func (m *EthereumFeeAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *EthereumFeeAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	if len(errors) > 0 {
		return EthereumFeeAddressMultiError(errors)
	}

	return nil
}

// EthereumFeeAddressMultiError is an error wrapping multiple validation errors
// returned by EthereumFeeAddress.ValidateAll() if the designated constraints
// aren't met.
type EthereumFeeAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EthereumFeeAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EthereumFeeAddressMultiError) AllErrors() []error { return m }

// EthereumFeeAddressValidationError is the validation error returned by
// EthereumFeeAddress.Validate if the designated constraints aren't met.
type EthereumFeeAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EthereumFeeAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EthereumFeeAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EthereumFeeAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EthereumFeeAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EthereumFeeAddressValidationError) ErrorName() string {
	return "EthereumFeeAddressValidationError"
}

// Error satisfies the builtin error interface
func (e EthereumFeeAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEthereumFeeAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EthereumFeeAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EthereumFeeAddressValidationError{}

// Validate checks the field values on AddressWithBalance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AddressWithBalance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AddressWithBalance with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AddressWithBalanceMultiError, or nil if none found.
func (m *AddressWithBalance) ValidateAll() error {
	return m.validate(true)
}

func (m *AddressWithBalance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for FeeBalance

	// no validation rules for StringFeeBalance

	if len(errors) > 0 {
		return AddressWithBalanceMultiError(errors)
	}

	return nil
}

// AddressWithBalanceMultiError is an error wrapping multiple validation errors
// returned by AddressWithBalance.ValidateAll() if the designated constraints
// aren't met.
type AddressWithBalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AddressWithBalanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AddressWithBalanceMultiError) AllErrors() []error { return m }

// AddressWithBalanceValidationError is the validation error returned by
// AddressWithBalance.Validate if the designated constraints aren't met.
type AddressWithBalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AddressWithBalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AddressWithBalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AddressWithBalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AddressWithBalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AddressWithBalanceValidationError) ErrorName() string {
	return "AddressWithBalanceValidationError"
}

// Error satisfies the builtin error interface
func (e AddressWithBalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAddressWithBalance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AddressWithBalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AddressWithBalanceValidationError{}

// Validate checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transaction with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransactionMultiError, or
// nil if none found.
func (m *Transaction) ValidateAll() error {
	return m.validate(true)
}

func (m *Transaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for TxId

	// no validation rules for Address

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for JpyRate

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for FeeRate

	// no validation rules for State

	for idx, item := range m.GetSignedKeys() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  fmt.Sprintf("SignedKeys[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  fmt.Sprintf("SignedKeys[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  fmt.Sprintf("SignedKeys[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetMembers() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  fmt.Sprintf("Members[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, TransactionValidationError{
						field:  fmt.Sprintf("Members[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return TransactionValidationError{
					field:  fmt.Sprintf("Members[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetBitcoinSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "BitcoinSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "BitcoinSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBitcoinSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "BitcoinSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEthereumSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "EthereumSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "EthereumSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEthereumSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "EthereumSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetLitecoinSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "LitecoinSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "LitecoinSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetLitecoinSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "LitecoinSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBitcoincashSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "BitcoincashSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "BitcoincashSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBitcoincashSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "BitcoincashSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetXrpSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "XrpSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "XrpSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetXrpSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "XrpSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTronSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "TronSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "TronSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTronSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "TronSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetC0BanSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "C0BanSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "C0BanSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetC0BanSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "C0BanSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetStellarSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "StellarSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "StellarSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetStellarSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "StellarSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCardanoSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "CardanoSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "CardanoSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCardanoSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "CardanoSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSubstrateSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "SubstrateSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "SubstrateSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSubstrateSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "SubstrateSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetMonacoinSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "MonacoinSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "MonacoinSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetMonacoinSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "MonacoinSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetNemSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "NemSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "NemSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetNemSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "NemSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetIostSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "IostSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "IostSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetIostSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "IostSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetPolygonSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "PolygonSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "PolygonSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetPolygonSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "PolygonSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetKlaytnSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "KlaytnSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "KlaytnSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetKlaytnSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "KlaytnSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSymbolSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "SymbolSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "SymbolSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSymbolSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "SymbolSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAvalancheSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "AvalancheSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "AvalancheSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAvalancheSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "AvalancheSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetOasysSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "OasysSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "OasysSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetOasysSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "OasysSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetXdcSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "XdcSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "XdcSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetXdcSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "XdcSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCosmosSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "CosmosSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "CosmosSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCosmosSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "CosmosSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetEthereumClassicSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "EthereumClassicSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "EthereumClassicSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEthereumClassicSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "EthereumClassicSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAlgorandSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "AlgorandSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "AlgorandSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAlgorandSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "AlgorandSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetHederaSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "HederaSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "HederaSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetHederaSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "HederaSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetJapanOpenChainSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "JapanOpenChainSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "JapanOpenChainSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetJapanOpenChainSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "JapanOpenChainSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetSolanaSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "SolanaSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "SolanaSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetSolanaSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "SolanaSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetBnbSmartChainSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "BnbSmartChainSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "BnbSmartChainSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBnbSmartChainSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "BnbSmartChainSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetFlareSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "FlareSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "FlareSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetFlareSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "FlareSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetArbitrumOneSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "ArbitrumOneSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "ArbitrumOneSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetArbitrumOneSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "ArbitrumOneSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAptosSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "AptosSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "AptosSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAptosSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "AptosSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetDogecoinSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "DogecoinSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "DogecoinSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetDogecoinSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "DogecoinSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAvalanchePlatformChainSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "AvalanchePlatformChainSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "AvalanchePlatformChainSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAvalanchePlatformChainSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "AvalanchePlatformChainSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransactionValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransactionValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransactionMultiError(errors)
	}

	return nil
}

// TransactionMultiError is an error wrapping multiple validation errors
// returned by Transaction.ValidateAll() if the designated constraints aren't met.
type TransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionMultiError) AllErrors() []error { return m }

// TransactionValidationError is the validation error returned by
// Transaction.Validate if the designated constraints aren't met.
type TransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionValidationError) ErrorName() string { return "TransactionValidationError" }

// Error satisfies the builtin error interface
func (e TransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionValidationError{}

// Validate checks the field values on TransactionMember with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *TransactionMember) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransactionMember with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransactionMemberMultiError, or nil if none found.
func (m *TransactionMember) ValidateAll() error {
	return m.validate(true)
}

func (m *TransactionMember) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for Name

	// no validation rules for Email

	// no validation rules for Role

	// no validation rules for Signed

	// no validation rules for Validated

	if len(errors) > 0 {
		return TransactionMemberMultiError(errors)
	}

	return nil
}

// TransactionMemberMultiError is an error wrapping multiple validation errors
// returned by TransactionMember.ValidateAll() if the designated constraints
// aren't met.
type TransactionMemberMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransactionMemberMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransactionMemberMultiError) AllErrors() []error { return m }

// TransactionMemberValidationError is the validation error returned by
// TransactionMember.Validate if the designated constraints aren't met.
type TransactionMemberValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransactionMemberValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransactionMemberValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransactionMemberValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransactionMemberValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransactionMemberValidationError) ErrorName() string {
	return "TransactionMemberValidationError"
}

// Error satisfies the builtin error interface
func (e TransactionMemberValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransactionMember.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransactionMemberValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransactionMemberValidationError{}

// Validate checks the field values on TxInput with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TxInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TxInput with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in TxInputMultiError, or nil if none found.
func (m *TxInput) ValidateAll() error {
	return m.validate(true)
}

func (m *TxInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	// no validation rules for TxIndex

	// no validation rules for Value

	// no validation rules for StringValue

	if len(errors) > 0 {
		return TxInputMultiError(errors)
	}

	return nil
}

// TxInputMultiError is an error wrapping multiple validation errors returned
// by TxInput.ValidateAll() if the designated constraints aren't met.
type TxInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TxInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TxInputMultiError) AllErrors() []error { return m }

// TxInputValidationError is the validation error returned by TxInput.Validate
// if the designated constraints aren't met.
type TxInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxInputValidationError) ErrorName() string { return "TxInputValidationError" }

// Error satisfies the builtin error interface
func (e TxInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxInputValidationError{}

// Validate checks the field values on TxOutput with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TxOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TxOutput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TxOutputMultiError, or nil
// if none found.
func (m *TxOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *TxOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for IsChange

	if len(errors) > 0 {
		return TxOutputMultiError(errors)
	}

	return nil
}

// TxOutputMultiError is an error wrapping multiple validation errors returned
// by TxOutput.ValidateAll() if the designated constraints aren't met.
type TxOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TxOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TxOutputMultiError) AllErrors() []error { return m }

// TxOutputValidationError is the validation error returned by
// TxOutput.Validate if the designated constraints aren't met.
type TxOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TxOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TxOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TxOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TxOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TxOutputValidationError) ErrorName() string { return "TxOutputValidationError" }

// Error satisfies the builtin error interface
func (e TxOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTxOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TxOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TxOutputValidationError{}

// Validate checks the field values on UTXO with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *UTXO) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UTXO with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in UTXOMultiError, or nil if none found.
func (m *UTXO) ValidateAll() error {
	return m.validate(true)
}

func (m *UTXO) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	// no validation rules for Vout

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for Address

	if !_UTXO_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := UTXOValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if all {
		switch v := interface{}(m.GetCardanoSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UTXOValidationError{
					field:  "CardanoSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UTXOValidationError{
					field:  "CardanoSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCardanoSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UTXOValidationError{
				field:  "CardanoSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetAvalanchePlatformChainSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UTXOValidationError{
					field:  "AvalanchePlatformChainSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UTXOValidationError{
					field:  "AvalanchePlatformChainSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAvalanchePlatformChainSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UTXOValidationError{
				field:  "AvalanchePlatformChainSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UTXOMultiError(errors)
	}

	return nil
}

// UTXOMultiError is an error wrapping multiple validation errors returned by
// UTXO.ValidateAll() if the designated constraints aren't met.
type UTXOMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UTXOMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UTXOMultiError) AllErrors() []error { return m }

// UTXOValidationError is the validation error returned by UTXO.Validate if the
// designated constraints aren't met.
type UTXOValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UTXOValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UTXOValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UTXOValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UTXOValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UTXOValidationError) ErrorName() string { return "UTXOValidationError" }

// Error satisfies the builtin error interface
func (e UTXOValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUTXO.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UTXOValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UTXOValidationError{}

var _UTXO_TransactionId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on CardanoUTXOSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CardanoUTXOSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CardanoUTXOSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CardanoUTXOSpecificMultiError, or nil if none found.
func (m *CardanoUTXOSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CardanoUTXOSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTokens() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CardanoUTXOSpecificValidationError{
						field:  fmt.Sprintf("Tokens[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CardanoUTXOSpecificValidationError{
						field:  fmt.Sprintf("Tokens[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CardanoUTXOSpecificValidationError{
					field:  fmt.Sprintf("Tokens[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CardanoUTXOSpecificMultiError(errors)
	}

	return nil
}

// CardanoUTXOSpecificMultiError is an error wrapping multiple validation
// errors returned by CardanoUTXOSpecific.ValidateAll() if the designated
// constraints aren't met.
type CardanoUTXOSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardanoUTXOSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardanoUTXOSpecificMultiError) AllErrors() []error { return m }

// CardanoUTXOSpecificValidationError is the validation error returned by
// CardanoUTXOSpecific.Validate if the designated constraints aren't met.
type CardanoUTXOSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardanoUTXOSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardanoUTXOSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardanoUTXOSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardanoUTXOSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardanoUTXOSpecificValidationError) ErrorName() string {
	return "CardanoUTXOSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CardanoUTXOSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCardanoUTXOSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardanoUTXOSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardanoUTXOSpecificValidationError{}

// Validate checks the field values on AvalanchePlatformChainUTXOSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *AvalanchePlatformChainUTXOSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AvalanchePlatformChainUTXOSpecific
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// AvalanchePlatformChainUTXOSpecificMultiError, or nil if none found.
func (m *AvalanchePlatformChainUTXOSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *AvalanchePlatformChainUTXOSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Threshold

	if len(errors) > 0 {
		return AvalanchePlatformChainUTXOSpecificMultiError(errors)
	}

	return nil
}

// AvalanchePlatformChainUTXOSpecificMultiError is an error wrapping multiple
// validation errors returned by
// AvalanchePlatformChainUTXOSpecific.ValidateAll() if the designated
// constraints aren't met.
type AvalanchePlatformChainUTXOSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvalanchePlatformChainUTXOSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvalanchePlatformChainUTXOSpecificMultiError) AllErrors() []error { return m }

// AvalanchePlatformChainUTXOSpecificValidationError is the validation error
// returned by AvalanchePlatformChainUTXOSpecific.Validate if the designated
// constraints aren't met.
type AvalanchePlatformChainUTXOSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvalanchePlatformChainUTXOSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvalanchePlatformChainUTXOSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvalanchePlatformChainUTXOSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvalanchePlatformChainUTXOSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvalanchePlatformChainUTXOSpecificValidationError) ErrorName() string {
	return "AvalanchePlatformChainUTXOSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e AvalanchePlatformChainUTXOSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvalanchePlatformChainUTXOSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvalanchePlatformChainUTXOSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvalanchePlatformChainUTXOSpecificValidationError{}

// Validate checks the field values on CardanoCustomToken with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CardanoCustomToken) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CardanoCustomToken with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CardanoCustomTokenMultiError, or nil if none found.
func (m *CardanoCustomToken) ValidateAll() error {
	return m.validate(true)
}

func (m *CardanoCustomToken) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PolicyId

	// no validation rules for AssetName

	// no validation rules for Value

	if len(errors) > 0 {
		return CardanoCustomTokenMultiError(errors)
	}

	return nil
}

// CardanoCustomTokenMultiError is an error wrapping multiple validation errors
// returned by CardanoCustomToken.ValidateAll() if the designated constraints
// aren't met.
type CardanoCustomTokenMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardanoCustomTokenMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardanoCustomTokenMultiError) AllErrors() []error { return m }

// CardanoCustomTokenValidationError is the validation error returned by
// CardanoCustomToken.Validate if the designated constraints aren't met.
type CardanoCustomTokenValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardanoCustomTokenValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardanoCustomTokenValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardanoCustomTokenValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardanoCustomTokenValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardanoCustomTokenValidationError) ErrorName() string {
	return "CardanoCustomTokenValidationError"
}

// Error satisfies the builtin error interface
func (e CardanoCustomTokenValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCardanoCustomToken.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardanoCustomTokenValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardanoCustomTokenValidationError{}

// Validate checks the field values on BitcoinSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BitcoinSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BitcoinSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BitcoinSpecificMultiError, or nil if none found.
func (m *BitcoinSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *BitcoinSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BitcoinSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BitcoinSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BitcoinSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BitcoinSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BitcoinSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BitcoinSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BitcoinSpecificMultiError(errors)
	}

	return nil
}

// BitcoinSpecificMultiError is an error wrapping multiple validation errors
// returned by BitcoinSpecific.ValidateAll() if the designated constraints
// aren't met.
type BitcoinSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BitcoinSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BitcoinSpecificMultiError) AllErrors() []error { return m }

// BitcoinSpecificValidationError is the validation error returned by
// BitcoinSpecific.Validate if the designated constraints aren't met.
type BitcoinSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BitcoinSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BitcoinSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BitcoinSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BitcoinSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BitcoinSpecificValidationError) ErrorName() string { return "BitcoinSpecificValidationError" }

// Error satisfies the builtin error interface
func (e BitcoinSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBitcoinSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BitcoinSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BitcoinSpecificValidationError{}

// Validate checks the field values on LitecoinSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *LitecoinSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LitecoinSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LitecoinSpecificMultiError, or nil if none found.
func (m *LitecoinSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *LitecoinSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LitecoinSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LitecoinSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LitecoinSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, LitecoinSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, LitecoinSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return LitecoinSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return LitecoinSpecificMultiError(errors)
	}

	return nil
}

// LitecoinSpecificMultiError is an error wrapping multiple validation errors
// returned by LitecoinSpecific.ValidateAll() if the designated constraints
// aren't met.
type LitecoinSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LitecoinSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LitecoinSpecificMultiError) AllErrors() []error { return m }

// LitecoinSpecificValidationError is the validation error returned by
// LitecoinSpecific.Validate if the designated constraints aren't met.
type LitecoinSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LitecoinSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LitecoinSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LitecoinSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LitecoinSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LitecoinSpecificValidationError) ErrorName() string { return "LitecoinSpecificValidationError" }

// Error satisfies the builtin error interface
func (e LitecoinSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLitecoinSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LitecoinSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LitecoinSpecificValidationError{}

// Validate checks the field values on DogecoinSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *DogecoinSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on DogecoinSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DogecoinSpecificMultiError, or nil if none found.
func (m *DogecoinSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *DogecoinSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DogecoinSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DogecoinSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DogecoinSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, DogecoinSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, DogecoinSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return DogecoinSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return DogecoinSpecificMultiError(errors)
	}

	return nil
}

// DogecoinSpecificMultiError is an error wrapping multiple validation errors
// returned by DogecoinSpecific.ValidateAll() if the designated constraints
// aren't met.
type DogecoinSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DogecoinSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DogecoinSpecificMultiError) AllErrors() []error { return m }

// DogecoinSpecificValidationError is the validation error returned by
// DogecoinSpecific.Validate if the designated constraints aren't met.
type DogecoinSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DogecoinSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DogecoinSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DogecoinSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DogecoinSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DogecoinSpecificValidationError) ErrorName() string { return "DogecoinSpecificValidationError" }

// Error satisfies the builtin error interface
func (e DogecoinSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDogecoinSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DogecoinSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DogecoinSpecificValidationError{}

// Validate checks the field values on BitcoincashSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BitcoincashSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BitcoincashSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BitcoincashSpecificMultiError, or nil if none found.
func (m *BitcoincashSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *BitcoincashSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BitcoincashSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BitcoincashSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BitcoincashSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, BitcoincashSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, BitcoincashSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return BitcoincashSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return BitcoincashSpecificMultiError(errors)
	}

	return nil
}

// BitcoincashSpecificMultiError is an error wrapping multiple validation
// errors returned by BitcoincashSpecific.ValidateAll() if the designated
// constraints aren't met.
type BitcoincashSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BitcoincashSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BitcoincashSpecificMultiError) AllErrors() []error { return m }

// BitcoincashSpecificValidationError is the validation error returned by
// BitcoincashSpecific.Validate if the designated constraints aren't met.
type BitcoincashSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BitcoincashSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BitcoincashSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BitcoincashSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BitcoincashSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BitcoincashSpecificValidationError) ErrorName() string {
	return "BitcoincashSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e BitcoincashSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBitcoincashSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BitcoincashSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BitcoincashSpecificValidationError{}

// Validate checks the field values on EthereumSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *EthereumSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EthereumSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EthereumSpecificMultiError, or nil if none found.
func (m *EthereumSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *EthereumSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	// no validation rules for MethodIdType

	// no validation rules for Expiration

	// no validation rules for Data

	// no validation rules for IsStakingTransaction

	if len(errors) > 0 {
		return EthereumSpecificMultiError(errors)
	}

	return nil
}

// EthereumSpecificMultiError is an error wrapping multiple validation errors
// returned by EthereumSpecific.ValidateAll() if the designated constraints
// aren't met.
type EthereumSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EthereumSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EthereumSpecificMultiError) AllErrors() []error { return m }

// EthereumSpecificValidationError is the validation error returned by
// EthereumSpecific.Validate if the designated constraints aren't met.
type EthereumSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EthereumSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EthereumSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EthereumSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EthereumSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EthereumSpecificValidationError) ErrorName() string { return "EthereumSpecificValidationError" }

// Error satisfies the builtin error interface
func (e EthereumSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEthereumSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EthereumSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EthereumSpecificValidationError{}

// Validate checks the field values on XrpSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *XrpSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on XrpSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in XrpSpecificMultiError, or
// nil if none found.
func (m *XrpSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *XrpSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SequenceNumber

	// no validation rules for DestinationTag

	// no validation rules for TxType

	// no validation rules for IsNextSequenceNumber

	if len(errors) > 0 {
		return XrpSpecificMultiError(errors)
	}

	return nil
}

// XrpSpecificMultiError is an error wrapping multiple validation errors
// returned by XrpSpecific.ValidateAll() if the designated constraints aren't met.
type XrpSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m XrpSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m XrpSpecificMultiError) AllErrors() []error { return m }

// XrpSpecificValidationError is the validation error returned by
// XrpSpecific.Validate if the designated constraints aren't met.
type XrpSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e XrpSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e XrpSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e XrpSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e XrpSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e XrpSpecificValidationError) ErrorName() string { return "XrpSpecificValidationError" }

// Error satisfies the builtin error interface
func (e XrpSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sXrpSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = XrpSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = XrpSpecificValidationError{}

// Validate checks the field values on TronSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TronSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TronSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TronSpecificMultiError, or
// nil if none found.
func (m *TronSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *TronSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Expiration

	if len(errors) > 0 {
		return TronSpecificMultiError(errors)
	}

	return nil
}

// TronSpecificMultiError is an error wrapping multiple validation errors
// returned by TronSpecific.ValidateAll() if the designated constraints aren't met.
type TronSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TronSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TronSpecificMultiError) AllErrors() []error { return m }

// TronSpecificValidationError is the validation error returned by
// TronSpecific.Validate if the designated constraints aren't met.
type TronSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TronSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TronSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TronSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TronSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TronSpecificValidationError) ErrorName() string { return "TronSpecificValidationError" }

// Error satisfies the builtin error interface
func (e TronSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTronSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TronSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TronSpecificValidationError{}

// Validate checks the field values on C0BanSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *C0BanSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on C0BanSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in C0BanSpecificMultiError, or
// nil if none found.
func (m *C0BanSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *C0BanSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, C0BanSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, C0BanSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return C0BanSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, C0BanSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, C0BanSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return C0BanSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return C0BanSpecificMultiError(errors)
	}

	return nil
}

// C0BanSpecificMultiError is an error wrapping multiple validation errors
// returned by C0BanSpecific.ValidateAll() if the designated constraints
// aren't met.
type C0BanSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m C0BanSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m C0BanSpecificMultiError) AllErrors() []error { return m }

// C0BanSpecificValidationError is the validation error returned by
// C0BanSpecific.Validate if the designated constraints aren't met.
type C0BanSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e C0BanSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e C0BanSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e C0BanSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e C0BanSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e C0BanSpecificValidationError) ErrorName() string { return "C0BanSpecificValidationError" }

// Error satisfies the builtin error interface
func (e C0BanSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sC0BanSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = C0BanSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = C0BanSpecificValidationError{}

// Validate checks the field values on StellarSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StellarSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StellarSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StellarSpecificMultiError, or nil if none found.
func (m *StellarSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *StellarSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SequenceNumber

	// no validation rules for MemoId

	// no validation rules for IsNextSequenceNumber

	if len(errors) > 0 {
		return StellarSpecificMultiError(errors)
	}

	return nil
}

// StellarSpecificMultiError is an error wrapping multiple validation errors
// returned by StellarSpecific.ValidateAll() if the designated constraints
// aren't met.
type StellarSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StellarSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StellarSpecificMultiError) AllErrors() []error { return m }

// StellarSpecificValidationError is the validation error returned by
// StellarSpecific.Validate if the designated constraints aren't met.
type StellarSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StellarSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StellarSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StellarSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StellarSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StellarSpecificValidationError) ErrorName() string { return "StellarSpecificValidationError" }

// Error satisfies the builtin error interface
func (e StellarSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStellarSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StellarSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StellarSpecificValidationError{}

// Validate checks the field values on CardanoSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CardanoSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CardanoSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CardanoSpecificMultiError, or nil if none found.
func (m *CardanoSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CardanoSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CardanoSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CardanoSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CardanoSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CardanoSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CardanoSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CardanoSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CardanoSpecificMultiError(errors)
	}

	return nil
}

// CardanoSpecificMultiError is an error wrapping multiple validation errors
// returned by CardanoSpecific.ValidateAll() if the designated constraints
// aren't met.
type CardanoSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CardanoSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CardanoSpecificMultiError) AllErrors() []error { return m }

// CardanoSpecificValidationError is the validation error returned by
// CardanoSpecific.Validate if the designated constraints aren't met.
type CardanoSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CardanoSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CardanoSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CardanoSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CardanoSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CardanoSpecificValidationError) ErrorName() string { return "CardanoSpecificValidationError" }

// Error satisfies the builtin error interface
func (e CardanoSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCardanoSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CardanoSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CardanoSpecificValidationError{}

// Validate checks the field values on SubstrateSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *SubstrateSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubstrateSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubstrateSpecificMultiError, or nil if none found.
func (m *SubstrateSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *SubstrateSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	for idx, item := range m.GetSubstrateMultisigTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SubstrateSpecificValidationError{
						field:  fmt.Sprintf("SubstrateMultisigTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SubstrateSpecificValidationError{
						field:  fmt.Sprintf("SubstrateMultisigTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SubstrateSpecificValidationError{
					field:  fmt.Sprintf("SubstrateMultisigTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for CallType

	if len(errors) > 0 {
		return SubstrateSpecificMultiError(errors)
	}

	return nil
}

// SubstrateSpecificMultiError is an error wrapping multiple validation errors
// returned by SubstrateSpecific.ValidateAll() if the designated constraints
// aren't met.
type SubstrateSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubstrateSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubstrateSpecificMultiError) AllErrors() []error { return m }

// SubstrateSpecificValidationError is the validation error returned by
// SubstrateSpecific.Validate if the designated constraints aren't met.
type SubstrateSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubstrateSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubstrateSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubstrateSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubstrateSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubstrateSpecificValidationError) ErrorName() string {
	return "SubstrateSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e SubstrateSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubstrateSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubstrateSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubstrateSpecificValidationError{}

// Validate checks the field values on MonacoinSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *MonacoinSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on MonacoinSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// MonacoinSpecificMultiError, or nil if none found.
func (m *MonacoinSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *MonacoinSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MonacoinSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MonacoinSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MonacoinSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, MonacoinSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, MonacoinSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return MonacoinSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return MonacoinSpecificMultiError(errors)
	}

	return nil
}

// MonacoinSpecificMultiError is an error wrapping multiple validation errors
// returned by MonacoinSpecific.ValidateAll() if the designated constraints
// aren't met.
type MonacoinSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m MonacoinSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m MonacoinSpecificMultiError) AllErrors() []error { return m }

// MonacoinSpecificValidationError is the validation error returned by
// MonacoinSpecific.Validate if the designated constraints aren't met.
type MonacoinSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e MonacoinSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e MonacoinSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e MonacoinSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e MonacoinSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e MonacoinSpecificValidationError) ErrorName() string { return "MonacoinSpecificValidationError" }

// Error satisfies the builtin error interface
func (e MonacoinSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sMonacoinSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = MonacoinSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = MonacoinSpecificValidationError{}

// Validate checks the field values on NemSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *NemSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NemSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in NemSpecificMultiError, or
// nil if none found.
func (m *NemSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *NemSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	// no validation rules for TxType

	for idx, item := range m.GetNemMultisigTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, NemSpecificValidationError{
						field:  fmt.Sprintf("NemMultisigTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, NemSpecificValidationError{
						field:  fmt.Sprintf("NemMultisigTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return NemSpecificValidationError{
					field:  fmt.Sprintf("NemMultisigTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Expiration

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return NemSpecificMultiError(errors)
	}

	return nil
}

// NemSpecificMultiError is an error wrapping multiple validation errors
// returned by NemSpecific.ValidateAll() if the designated constraints aren't met.
type NemSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NemSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NemSpecificMultiError) AllErrors() []error { return m }

// NemSpecificValidationError is the validation error returned by
// NemSpecific.Validate if the designated constraints aren't met.
type NemSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NemSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NemSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NemSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NemSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NemSpecificValidationError) ErrorName() string { return "NemSpecificValidationError" }

// Error satisfies the builtin error interface
func (e NemSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNemSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NemSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NemSpecificValidationError{}

// Validate checks the field values on IOSTSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *IOSTSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IOSTSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in IOSTSpecificMultiError, or
// nil if none found.
func (m *IOSTSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *IOSTSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Memo

	// no validation rules for Timestamp

	// no validation rules for Expiration

	// no validation rules for Type

	if len(errors) > 0 {
		return IOSTSpecificMultiError(errors)
	}

	return nil
}

// IOSTSpecificMultiError is an error wrapping multiple validation errors
// returned by IOSTSpecific.ValidateAll() if the designated constraints aren't met.
type IOSTSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IOSTSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IOSTSpecificMultiError) AllErrors() []error { return m }

// IOSTSpecificValidationError is the validation error returned by
// IOSTSpecific.Validate if the designated constraints aren't met.
type IOSTSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IOSTSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IOSTSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IOSTSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IOSTSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IOSTSpecificValidationError) ErrorName() string { return "IOSTSpecificValidationError" }

// Error satisfies the builtin error interface
func (e IOSTSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIOSTSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IOSTSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IOSTSpecificValidationError{}

// Validate checks the field values on PolygonSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *PolygonSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PolygonSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// PolygonSpecificMultiError, or nil if none found.
func (m *PolygonSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *PolygonSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	if len(errors) > 0 {
		return PolygonSpecificMultiError(errors)
	}

	return nil
}

// PolygonSpecificMultiError is an error wrapping multiple validation errors
// returned by PolygonSpecific.ValidateAll() if the designated constraints
// aren't met.
type PolygonSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolygonSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolygonSpecificMultiError) AllErrors() []error { return m }

// PolygonSpecificValidationError is the validation error returned by
// PolygonSpecific.Validate if the designated constraints aren't met.
type PolygonSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolygonSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolygonSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolygonSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolygonSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolygonSpecificValidationError) ErrorName() string { return "PolygonSpecificValidationError" }

// Error satisfies the builtin error interface
func (e PolygonSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolygonSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolygonSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolygonSpecificValidationError{}

// Validate checks the field values on KlaytnSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *KlaytnSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on KlaytnSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in KlaytnSpecificMultiError,
// or nil if none found.
func (m *KlaytnSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *KlaytnSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	if len(errors) > 0 {
		return KlaytnSpecificMultiError(errors)
	}

	return nil
}

// KlaytnSpecificMultiError is an error wrapping multiple validation errors
// returned by KlaytnSpecific.ValidateAll() if the designated constraints
// aren't met.
type KlaytnSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m KlaytnSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m KlaytnSpecificMultiError) AllErrors() []error { return m }

// KlaytnSpecificValidationError is the validation error returned by
// KlaytnSpecific.Validate if the designated constraints aren't met.
type KlaytnSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e KlaytnSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e KlaytnSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e KlaytnSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e KlaytnSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e KlaytnSpecificValidationError) ErrorName() string { return "KlaytnSpecificValidationError" }

// Error satisfies the builtin error interface
func (e KlaytnSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sKlaytnSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = KlaytnSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = KlaytnSpecificValidationError{}

// Validate checks the field values on SymbolSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SymbolSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SymbolSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SymbolSpecificMultiError,
// or nil if none found.
func (m *SymbolSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *SymbolSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Message

	// no validation rules for TxType

	for idx, item := range m.GetSymbolMultisigTransactions() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SymbolSpecificValidationError{
						field:  fmt.Sprintf("SymbolMultisigTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SymbolSpecificValidationError{
						field:  fmt.Sprintf("SymbolMultisigTransactions[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SymbolSpecificValidationError{
					field:  fmt.Sprintf("SymbolMultisigTransactions[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for Expiration

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return SymbolSpecificMultiError(errors)
	}

	return nil
}

// SymbolSpecificMultiError is an error wrapping multiple validation errors
// returned by SymbolSpecific.ValidateAll() if the designated constraints
// aren't met.
type SymbolSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SymbolSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SymbolSpecificMultiError) AllErrors() []error { return m }

// SymbolSpecificValidationError is the validation error returned by
// SymbolSpecific.Validate if the designated constraints aren't met.
type SymbolSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SymbolSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SymbolSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SymbolSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SymbolSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SymbolSpecificValidationError) ErrorName() string { return "SymbolSpecificValidationError" }

// Error satisfies the builtin error interface
func (e SymbolSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSymbolSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SymbolSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SymbolSpecificValidationError{}

// Validate checks the field values on AvalancheSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AvalancheSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AvalancheSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AvalancheSpecificMultiError, or nil if none found.
func (m *AvalancheSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *AvalancheSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	if all {
		switch v := interface{}(m.GetAtomicTx()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, AvalancheSpecificValidationError{
					field:  "AtomicTx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, AvalancheSpecificValidationError{
					field:  "AtomicTx",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetAtomicTx()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return AvalancheSpecificValidationError{
				field:  "AtomicTx",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return AvalancheSpecificMultiError(errors)
	}

	return nil
}

// AvalancheSpecificMultiError is an error wrapping multiple validation errors
// returned by AvalancheSpecific.ValidateAll() if the designated constraints
// aren't met.
type AvalancheSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvalancheSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvalancheSpecificMultiError) AllErrors() []error { return m }

// AvalancheSpecificValidationError is the validation error returned by
// AvalancheSpecific.Validate if the designated constraints aren't met.
type AvalancheSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvalancheSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvalancheSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvalancheSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvalancheSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvalancheSpecificValidationError) ErrorName() string {
	return "AvalancheSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e AvalancheSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvalancheSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvalancheSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvalancheSpecificValidationError{}

// Validate checks the field values on OasysSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *OasysSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on OasysSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in OasysSpecificMultiError, or
// nil if none found.
func (m *OasysSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *OasysSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	if len(errors) > 0 {
		return OasysSpecificMultiError(errors)
	}

	return nil
}

// OasysSpecificMultiError is an error wrapping multiple validation errors
// returned by OasysSpecific.ValidateAll() if the designated constraints
// aren't met.
type OasysSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m OasysSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m OasysSpecificMultiError) AllErrors() []error { return m }

// OasysSpecificValidationError is the validation error returned by
// OasysSpecific.Validate if the designated constraints aren't met.
type OasysSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e OasysSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e OasysSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e OasysSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e OasysSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e OasysSpecificValidationError) ErrorName() string { return "OasysSpecificValidationError" }

// Error satisfies the builtin error interface
func (e OasysSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sOasysSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = OasysSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = OasysSpecificValidationError{}

// Validate checks the field values on XdcSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *XdcSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on XdcSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in XdcSpecificMultiError, or
// nil if none found.
func (m *XdcSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *XdcSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	if len(errors) > 0 {
		return XdcSpecificMultiError(errors)
	}

	return nil
}

// XdcSpecificMultiError is an error wrapping multiple validation errors
// returned by XdcSpecific.ValidateAll() if the designated constraints aren't met.
type XdcSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m XdcSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m XdcSpecificMultiError) AllErrors() []error { return m }

// XdcSpecificValidationError is the validation error returned by
// XdcSpecific.Validate if the designated constraints aren't met.
type XdcSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e XdcSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e XdcSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e XdcSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e XdcSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e XdcSpecificValidationError) ErrorName() string { return "XdcSpecificValidationError" }

// Error satisfies the builtin error interface
func (e XdcSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sXdcSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = XdcSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = XdcSpecificValidationError{}

// Validate checks the field values on CosmosSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CosmosSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CosmosSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CosmosSpecificMultiError,
// or nil if none found.
func (m *CosmosSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CosmosSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	// no validation rules for Type

	// no validation rules for Memo

	// no validation rules for GasAdjustment

	if len(errors) > 0 {
		return CosmosSpecificMultiError(errors)
	}

	return nil
}

// CosmosSpecificMultiError is an error wrapping multiple validation errors
// returned by CosmosSpecific.ValidateAll() if the designated constraints
// aren't met.
type CosmosSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CosmosSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CosmosSpecificMultiError) AllErrors() []error { return m }

// CosmosSpecificValidationError is the validation error returned by
// CosmosSpecific.Validate if the designated constraints aren't met.
type CosmosSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CosmosSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CosmosSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CosmosSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CosmosSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CosmosSpecificValidationError) ErrorName() string { return "CosmosSpecificValidationError" }

// Error satisfies the builtin error interface
func (e CosmosSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCosmosSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CosmosSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CosmosSpecificValidationError{}

// Validate checks the field values on EthereumClassicSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EthereumClassicSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EthereumClassicSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EthereumClassicSpecificMultiError, or nil if none found.
func (m *EthereumClassicSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *EthereumClassicSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	if len(errors) > 0 {
		return EthereumClassicSpecificMultiError(errors)
	}

	return nil
}

// EthereumClassicSpecificMultiError is an error wrapping multiple validation
// errors returned by EthereumClassicSpecific.ValidateAll() if the designated
// constraints aren't met.
type EthereumClassicSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EthereumClassicSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EthereumClassicSpecificMultiError) AllErrors() []error { return m }

// EthereumClassicSpecificValidationError is the validation error returned by
// EthereumClassicSpecific.Validate if the designated constraints aren't met.
type EthereumClassicSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EthereumClassicSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EthereumClassicSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EthereumClassicSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EthereumClassicSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EthereumClassicSpecificValidationError) ErrorName() string {
	return "EthereumClassicSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e EthereumClassicSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEthereumClassicSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EthereumClassicSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EthereumClassicSpecificValidationError{}

// Validate checks the field values on AlgorandSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AlgorandSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AlgorandSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AlgorandSpecificMultiError, or nil if none found.
func (m *AlgorandSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *AlgorandSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	// no validation rules for Memo

	// no validation rules for FirstRound

	// no validation rules for LastRound

	// no validation rules for Expiration

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return AlgorandSpecificMultiError(errors)
	}

	return nil
}

// AlgorandSpecificMultiError is an error wrapping multiple validation errors
// returned by AlgorandSpecific.ValidateAll() if the designated constraints
// aren't met.
type AlgorandSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AlgorandSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AlgorandSpecificMultiError) AllErrors() []error { return m }

// AlgorandSpecificValidationError is the validation error returned by
// AlgorandSpecific.Validate if the designated constraints aren't met.
type AlgorandSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AlgorandSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AlgorandSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AlgorandSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AlgorandSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AlgorandSpecificValidationError) ErrorName() string { return "AlgorandSpecificValidationError" }

// Error satisfies the builtin error interface
func (e AlgorandSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAlgorandSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AlgorandSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AlgorandSpecificValidationError{}

// Validate checks the field values on HederaSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *HederaSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on HederaSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in HederaSpecificMultiError,
// or nil if none found.
func (m *HederaSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *HederaSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Memo

	// no validation rules for Timestamp

	// no validation rules for Expiration

	if len(errors) > 0 {
		return HederaSpecificMultiError(errors)
	}

	return nil
}

// HederaSpecificMultiError is an error wrapping multiple validation errors
// returned by HederaSpecific.ValidateAll() if the designated constraints
// aren't met.
type HederaSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m HederaSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m HederaSpecificMultiError) AllErrors() []error { return m }

// HederaSpecificValidationError is the validation error returned by
// HederaSpecific.Validate if the designated constraints aren't met.
type HederaSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e HederaSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e HederaSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e HederaSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e HederaSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e HederaSpecificValidationError) ErrorName() string { return "HederaSpecificValidationError" }

// Error satisfies the builtin error interface
func (e HederaSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sHederaSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = HederaSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = HederaSpecificValidationError{}

// Validate checks the field values on JapanOpenChainSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *JapanOpenChainSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on JapanOpenChainSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// JapanOpenChainSpecificMultiError, or nil if none found.
func (m *JapanOpenChainSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *JapanOpenChainSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	if len(errors) > 0 {
		return JapanOpenChainSpecificMultiError(errors)
	}

	return nil
}

// JapanOpenChainSpecificMultiError is an error wrapping multiple validation
// errors returned by JapanOpenChainSpecific.ValidateAll() if the designated
// constraints aren't met.
type JapanOpenChainSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m JapanOpenChainSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m JapanOpenChainSpecificMultiError) AllErrors() []error { return m }

// JapanOpenChainSpecificValidationError is the validation error returned by
// JapanOpenChainSpecific.Validate if the designated constraints aren't met.
type JapanOpenChainSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e JapanOpenChainSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e JapanOpenChainSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e JapanOpenChainSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e JapanOpenChainSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e JapanOpenChainSpecificValidationError) ErrorName() string {
	return "JapanOpenChainSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e JapanOpenChainSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sJapanOpenChainSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = JapanOpenChainSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = JapanOpenChainSpecificValidationError{}

// Validate checks the field values on SolanaSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SolanaSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SolanaSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SolanaSpecificMultiError,
// or nil if none found.
func (m *SolanaSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *SolanaSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Expiration

	// no validation rules for EventType

	if len(errors) > 0 {
		return SolanaSpecificMultiError(errors)
	}

	return nil
}

// SolanaSpecificMultiError is an error wrapping multiple validation errors
// returned by SolanaSpecific.ValidateAll() if the designated constraints
// aren't met.
type SolanaSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SolanaSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SolanaSpecificMultiError) AllErrors() []error { return m }

// SolanaSpecificValidationError is the validation error returned by
// SolanaSpecific.Validate if the designated constraints aren't met.
type SolanaSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SolanaSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SolanaSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SolanaSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SolanaSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SolanaSpecificValidationError) ErrorName() string { return "SolanaSpecificValidationError" }

// Error satisfies the builtin error interface
func (e SolanaSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSolanaSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SolanaSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SolanaSpecificValidationError{}

// Validate checks the field values on AptosSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AptosSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AptosSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AptosSpecificMultiError, or
// nil if none found.
func (m *AptosSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *AptosSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	// no validation rules for Expiration

	if len(errors) > 0 {
		return AptosSpecificMultiError(errors)
	}

	return nil
}

// AptosSpecificMultiError is an error wrapping multiple validation errors
// returned by AptosSpecific.ValidateAll() if the designated constraints
// aren't met.
type AptosSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AptosSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AptosSpecificMultiError) AllErrors() []error { return m }

// AptosSpecificValidationError is the validation error returned by
// AptosSpecific.Validate if the designated constraints aren't met.
type AptosSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AptosSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AptosSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AptosSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AptosSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AptosSpecificValidationError) ErrorName() string { return "AptosSpecificValidationError" }

// Error satisfies the builtin error interface
func (e AptosSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAptosSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AptosSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AptosSpecificValidationError{}

// Validate checks the field values on BNBSmartChainSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *BNBSmartChainSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BNBSmartChainSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BNBSmartChainSpecificMultiError, or nil if none found.
func (m *BNBSmartChainSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *BNBSmartChainSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	if len(errors) > 0 {
		return BNBSmartChainSpecificMultiError(errors)
	}

	return nil
}

// BNBSmartChainSpecificMultiError is an error wrapping multiple validation
// errors returned by BNBSmartChainSpecific.ValidateAll() if the designated
// constraints aren't met.
type BNBSmartChainSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BNBSmartChainSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BNBSmartChainSpecificMultiError) AllErrors() []error { return m }

// BNBSmartChainSpecificValidationError is the validation error returned by
// BNBSmartChainSpecific.Validate if the designated constraints aren't met.
type BNBSmartChainSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BNBSmartChainSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BNBSmartChainSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BNBSmartChainSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BNBSmartChainSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BNBSmartChainSpecificValidationError) ErrorName() string {
	return "BNBSmartChainSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e BNBSmartChainSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBNBSmartChainSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BNBSmartChainSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BNBSmartChainSpecificValidationError{}

// Validate checks the field values on FlareSpecific with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *FlareSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FlareSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in FlareSpecificMultiError, or
// nil if none found.
func (m *FlareSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *FlareSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	if len(errors) > 0 {
		return FlareSpecificMultiError(errors)
	}

	return nil
}

// FlareSpecificMultiError is an error wrapping multiple validation errors
// returned by FlareSpecific.ValidateAll() if the designated constraints
// aren't met.
type FlareSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FlareSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FlareSpecificMultiError) AllErrors() []error { return m }

// FlareSpecificValidationError is the validation error returned by
// FlareSpecific.Validate if the designated constraints aren't met.
type FlareSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FlareSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FlareSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FlareSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FlareSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FlareSpecificValidationError) ErrorName() string { return "FlareSpecificValidationError" }

// Error satisfies the builtin error interface
func (e FlareSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFlareSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FlareSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FlareSpecificValidationError{}

// Validate checks the field values on ArbitrumOneSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ArbitrumOneSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ArbitrumOneSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ArbitrumOneSpecificMultiError, or nil if none found.
func (m *ArbitrumOneSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *ArbitrumOneSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	// no validation rules for Data

	if len(errors) > 0 {
		return ArbitrumOneSpecificMultiError(errors)
	}

	return nil
}

// ArbitrumOneSpecificMultiError is an error wrapping multiple validation
// errors returned by ArbitrumOneSpecific.ValidateAll() if the designated
// constraints aren't met.
type ArbitrumOneSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ArbitrumOneSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ArbitrumOneSpecificMultiError) AllErrors() []error { return m }

// ArbitrumOneSpecificValidationError is the validation error returned by
// ArbitrumOneSpecific.Validate if the designated constraints aren't met.
type ArbitrumOneSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ArbitrumOneSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ArbitrumOneSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ArbitrumOneSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ArbitrumOneSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ArbitrumOneSpecificValidationError) ErrorName() string {
	return "ArbitrumOneSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e ArbitrumOneSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sArbitrumOneSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ArbitrumOneSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ArbitrumOneSpecificValidationError{}

// Validate checks the field values on AtomicTx with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *AtomicTx) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AtomicTx with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in AtomicTxMultiError, or nil
// if none found.
func (m *AtomicTx) ValidateAll() error {
	return m.validate(true)
}

func (m *AtomicTx) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxType

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AtomicTxValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AtomicTxValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AtomicTxValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AtomicTxValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AtomicTxValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AtomicTxValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AtomicTxMultiError(errors)
	}

	return nil
}

// AtomicTxMultiError is an error wrapping multiple validation errors returned
// by AtomicTx.ValidateAll() if the designated constraints aren't met.
type AtomicTxMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AtomicTxMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AtomicTxMultiError) AllErrors() []error { return m }

// AtomicTxValidationError is the validation error returned by
// AtomicTx.Validate if the designated constraints aren't met.
type AtomicTxValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AtomicTxValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AtomicTxValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AtomicTxValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AtomicTxValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AtomicTxValidationError) ErrorName() string { return "AtomicTxValidationError" }

// Error satisfies the builtin error interface
func (e AtomicTxValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAtomicTx.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AtomicTxValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AtomicTxValidationError{}

// Validate checks the field values on AvalanchePlatformChainSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *AvalanchePlatformChainSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AvalanchePlatformChainSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// AvalanchePlatformChainSpecificMultiError, or nil if none found.
func (m *AvalanchePlatformChainSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *AvalanchePlatformChainSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxType

	for idx, item := range m.GetTxInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AvalanchePlatformChainSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AvalanchePlatformChainSpecificValidationError{
						field:  fmt.Sprintf("TxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AvalanchePlatformChainSpecificValidationError{
					field:  fmt.Sprintf("TxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	for idx, item := range m.GetTxOutputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, AvalanchePlatformChainSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, AvalanchePlatformChainSpecificValidationError{
						field:  fmt.Sprintf("TxOutputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return AvalanchePlatformChainSpecificValidationError{
					field:  fmt.Sprintf("TxOutputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return AvalanchePlatformChainSpecificMultiError(errors)
	}

	return nil
}

// AvalanchePlatformChainSpecificMultiError is an error wrapping multiple
// validation errors returned by AvalanchePlatformChainSpecific.ValidateAll()
// if the designated constraints aren't met.
type AvalanchePlatformChainSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvalanchePlatformChainSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvalanchePlatformChainSpecificMultiError) AllErrors() []error { return m }

// AvalanchePlatformChainSpecificValidationError is the validation error
// returned by AvalanchePlatformChainSpecific.Validate if the designated
// constraints aren't met.
type AvalanchePlatformChainSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvalanchePlatformChainSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvalanchePlatformChainSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvalanchePlatformChainSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvalanchePlatformChainSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvalanchePlatformChainSpecificValidationError) ErrorName() string {
	return "AvalanchePlatformChainSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e AvalanchePlatformChainSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvalanchePlatformChainSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvalanchePlatformChainSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvalanchePlatformChainSpecificValidationError{}

// Validate checks the field values on AvalancheTxInput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AvalancheTxInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AvalancheTxInput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AvalancheTxInputMultiError, or nil if none found.
func (m *AvalancheTxInput) ValidateAll() error {
	return m.validate(true)
}

func (m *AvalancheTxInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	// no validation rules for InputIndex

	// no validation rules for InputIndexType

	// no validation rules for Value

	// no validation rules for StringValue

	if len(errors) > 0 {
		return AvalancheTxInputMultiError(errors)
	}

	return nil
}

// AvalancheTxInputMultiError is an error wrapping multiple validation errors
// returned by AvalancheTxInput.ValidateAll() if the designated constraints
// aren't met.
type AvalancheTxInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvalancheTxInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvalancheTxInputMultiError) AllErrors() []error { return m }

// AvalancheTxInputValidationError is the validation error returned by
// AvalancheTxInput.Validate if the designated constraints aren't met.
type AvalancheTxInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvalancheTxInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvalancheTxInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvalancheTxInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvalancheTxInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvalancheTxInputValidationError) ErrorName() string { return "AvalancheTxInputValidationError" }

// Error satisfies the builtin error interface
func (e AvalancheTxInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvalancheTxInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvalancheTxInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvalancheTxInputValidationError{}

// Validate checks the field values on AvalancheTxOutput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *AvalancheTxOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on AvalancheTxOutput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// AvalancheTxOutputMultiError, or nil if none found.
func (m *AvalancheTxOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *AvalancheTxOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OutputIndex

	// no validation rules for OutputType

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for Locktime

	// no validation rules for Threshold

	// no validation rules for IsChange

	if len(errors) > 0 {
		return AvalancheTxOutputMultiError(errors)
	}

	return nil
}

// AvalancheTxOutputMultiError is an error wrapping multiple validation errors
// returned by AvalancheTxOutput.ValidateAll() if the designated constraints
// aren't met.
type AvalancheTxOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m AvalancheTxOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m AvalancheTxOutputMultiError) AllErrors() []error { return m }

// AvalancheTxOutputValidationError is the validation error returned by
// AvalancheTxOutput.Validate if the designated constraints aren't met.
type AvalancheTxOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e AvalancheTxOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e AvalancheTxOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e AvalancheTxOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e AvalancheTxOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e AvalancheTxOutputValidationError) ErrorName() string {
	return "AvalancheTxOutputValidationError"
}

// Error satisfies the builtin error interface
func (e AvalancheTxOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sAvalancheTxOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = AvalancheTxOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = AvalancheTxOutputValidationError{}

// Validate checks the field values on CreateTransactionSubstrateSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateTransactionSubstrateSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionSubstrateSpecific
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTransactionSubstrateSpecificMultiError, or nil if none found.
func (m *CreateTransactionSubstrateSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionSubstrateSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for CallType

	// no validation rules for MultisigCallType

	if len(errors) > 0 {
		return CreateTransactionSubstrateSpecificMultiError(errors)
	}

	return nil
}

// CreateTransactionSubstrateSpecificMultiError is an error wrapping multiple
// validation errors returned by
// CreateTransactionSubstrateSpecific.ValidateAll() if the designated
// constraints aren't met.
type CreateTransactionSubstrateSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionSubstrateSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionSubstrateSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionSubstrateSpecificValidationError is the validation error
// returned by CreateTransactionSubstrateSpecific.Validate if the designated
// constraints aren't met.
type CreateTransactionSubstrateSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionSubstrateSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionSubstrateSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionSubstrateSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionSubstrateSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionSubstrateSpecificValidationError) ErrorName() string {
	return "CreateTransactionSubstrateSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionSubstrateSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionSubstrateSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionSubstrateSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionSubstrateSpecificValidationError{}

// Validate checks the field values on CreateTransactionWalletConnectSpecific
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *CreateTransactionWalletConnectSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// CreateTransactionWalletConnectSpecific with the rules defined in the proto
// definition for this message. If any rules are violated, the result is a
// list of violation errors wrapped in
// CreateTransactionWalletConnectSpecificMultiError, or nil if none found.
func (m *CreateTransactionWalletConnectSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionWalletConnectSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for CallRequestType

	// no validation rules for CallRequestParams

	if len(errors) > 0 {
		return CreateTransactionWalletConnectSpecificMultiError(errors)
	}

	return nil
}

// CreateTransactionWalletConnectSpecificMultiError is an error wrapping
// multiple validation errors returned by
// CreateTransactionWalletConnectSpecific.ValidateAll() if the designated
// constraints aren't met.
type CreateTransactionWalletConnectSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionWalletConnectSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionWalletConnectSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionWalletConnectSpecificValidationError is the validation
// error returned by CreateTransactionWalletConnectSpecific.Validate if the
// designated constraints aren't met.
type CreateTransactionWalletConnectSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionWalletConnectSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionWalletConnectSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionWalletConnectSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionWalletConnectSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionWalletConnectSpecificValidationError) ErrorName() string {
	return "CreateTransactionWalletConnectSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionWalletConnectSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionWalletConnectSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionWalletConnectSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionWalletConnectSpecificValidationError{}

// Validate checks the field values on CreateTransactionNemSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionNemSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionNemSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateTransactionNemSpecificMultiError, or nil if none found.
func (m *CreateTransactionNemSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionNemSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for TxType

	// no validation rules for Message

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return CreateTransactionNemSpecificMultiError(errors)
	}

	return nil
}

// CreateTransactionNemSpecificMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionNemSpecific.ValidateAll() if
// the designated constraints aren't met.
type CreateTransactionNemSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionNemSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionNemSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionNemSpecificValidationError is the validation error returned
// by CreateTransactionNemSpecific.Validate if the designated constraints
// aren't met.
type CreateTransactionNemSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionNemSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionNemSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionNemSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionNemSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionNemSpecificValidationError) ErrorName() string {
	return "CreateTransactionNemSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionNemSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionNemSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionNemSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionNemSpecificValidationError{}

// Validate checks the field values on CreateTransactionIOSTSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionIOSTSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionIOSTSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateTransactionIOSTSpecificMultiError, or nil if none found.
func (m *CreateTransactionIOSTSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionIOSTSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Memo

	// no validation rules for Timestamp

	if m.Type != nil {
		// no validation rules for Type
	}

	if len(errors) > 0 {
		return CreateTransactionIOSTSpecificMultiError(errors)
	}

	return nil
}

// CreateTransactionIOSTSpecificMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionIOSTSpecific.ValidateAll()
// if the designated constraints aren't met.
type CreateTransactionIOSTSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionIOSTSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionIOSTSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionIOSTSpecificValidationError is the validation error
// returned by CreateTransactionIOSTSpecific.Validate if the designated
// constraints aren't met.
type CreateTransactionIOSTSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionIOSTSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionIOSTSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionIOSTSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionIOSTSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionIOSTSpecificValidationError) ErrorName() string {
	return "CreateTransactionIOSTSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionIOSTSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionIOSTSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionIOSTSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionIOSTSpecificValidationError{}

// Validate checks the field values on CreateTransactionSymbolSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionSymbolSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionSymbolSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateTransactionSymbolSpecificMultiError, or nil if none found.
func (m *CreateTransactionSymbolSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionSymbolSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransactionId

	// no validation rules for TxType

	// no validation rules for Message

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return CreateTransactionSymbolSpecificMultiError(errors)
	}

	return nil
}

// CreateTransactionSymbolSpecificMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionSymbolSpecific.ValidateAll()
// if the designated constraints aren't met.
type CreateTransactionSymbolSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionSymbolSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionSymbolSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionSymbolSpecificValidationError is the validation error
// returned by CreateTransactionSymbolSpecific.Validate if the designated
// constraints aren't met.
type CreateTransactionSymbolSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionSymbolSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionSymbolSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionSymbolSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionSymbolSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionSymbolSpecificValidationError) ErrorName() string {
	return "CreateTransactionSymbolSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionSymbolSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionSymbolSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionSymbolSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionSymbolSpecificValidationError{}

// Validate checks the field values on CreateTransactionEthereumSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateTransactionEthereumSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionEthereumSpecific
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTransactionEthereumSpecificMultiError, or nil if none found.
func (m *CreateTransactionEthereumSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionEthereumSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Data

	if m.StakingRecipientWalletId != nil {
		// no validation rules for StakingRecipientWalletId
	}

	if m.CallMethod != nil {
		// no validation rules for CallMethod
	}

	if m.UtilsAddress != nil {
		// no validation rules for UtilsAddress
	}

	if len(errors) > 0 {
		return CreateTransactionEthereumSpecificMultiError(errors)
	}

	return nil
}

// CreateTransactionEthereumSpecificMultiError is an error wrapping multiple
// validation errors returned by
// CreateTransactionEthereumSpecific.ValidateAll() if the designated
// constraints aren't met.
type CreateTransactionEthereumSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionEthereumSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionEthereumSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionEthereumSpecificValidationError is the validation error
// returned by CreateTransactionEthereumSpecific.Validate if the designated
// constraints aren't met.
type CreateTransactionEthereumSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionEthereumSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionEthereumSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionEthereumSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionEthereumSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionEthereumSpecificValidationError) ErrorName() string {
	return "CreateTransactionEthereumSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionEthereumSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionEthereumSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionEthereumSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionEthereumSpecificValidationError{}

// Validate checks the field values on CreateTransactionCosmosSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionCosmosSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionCosmosSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateTransactionCosmosSpecificMultiError, or nil if none found.
func (m *CreateTransactionCosmosSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionCosmosSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for Memo

	if len(errors) > 0 {
		return CreateTransactionCosmosSpecificMultiError(errors)
	}

	return nil
}

// CreateTransactionCosmosSpecificMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionCosmosSpecific.ValidateAll()
// if the designated constraints aren't met.
type CreateTransactionCosmosSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionCosmosSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionCosmosSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionCosmosSpecificValidationError is the validation error
// returned by CreateTransactionCosmosSpecific.Validate if the designated
// constraints aren't met.
type CreateTransactionCosmosSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionCosmosSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionCosmosSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionCosmosSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionCosmosSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionCosmosSpecificValidationError) ErrorName() string {
	return "CreateTransactionCosmosSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionCosmosSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionCosmosSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionCosmosSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionCosmosSpecificValidationError{}

// Validate checks the field values on CreateTransactionAlgorandSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateTransactionAlgorandSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionAlgorandSpecific
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTransactionAlgorandSpecificMultiError, or nil if none found.
func (m *CreateTransactionAlgorandSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionAlgorandSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return CreateTransactionAlgorandSpecificMultiError(errors)
	}

	return nil
}

// CreateTransactionAlgorandSpecificMultiError is an error wrapping multiple
// validation errors returned by
// CreateTransactionAlgorandSpecific.ValidateAll() if the designated
// constraints aren't met.
type CreateTransactionAlgorandSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionAlgorandSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionAlgorandSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionAlgorandSpecificValidationError is the validation error
// returned by CreateTransactionAlgorandSpecific.Validate if the designated
// constraints aren't met.
type CreateTransactionAlgorandSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionAlgorandSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionAlgorandSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionAlgorandSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionAlgorandSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionAlgorandSpecificValidationError) ErrorName() string {
	return "CreateTransactionAlgorandSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionAlgorandSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionAlgorandSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionAlgorandSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionAlgorandSpecificValidationError{}

// Validate checks the field values on CreateTransactionHederaSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionHederaSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionHederaSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateTransactionHederaSpecificMultiError, or nil if none found.
func (m *CreateTransactionHederaSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionHederaSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Memo

	// no validation rules for Timestamp

	if len(errors) > 0 {
		return CreateTransactionHederaSpecificMultiError(errors)
	}

	return nil
}

// CreateTransactionHederaSpecificMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionHederaSpecific.ValidateAll()
// if the designated constraints aren't met.
type CreateTransactionHederaSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionHederaSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionHederaSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionHederaSpecificValidationError is the validation error
// returned by CreateTransactionHederaSpecific.Validate if the designated
// constraints aren't met.
type CreateTransactionHederaSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionHederaSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionHederaSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionHederaSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionHederaSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionHederaSpecificValidationError) ErrorName() string {
	return "CreateTransactionHederaSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionHederaSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionHederaSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionHederaSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionHederaSpecificValidationError{}

// Validate checks the field values on CreateTransactionSolanaSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionSolanaSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionSolanaSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateTransactionSolanaSpecificMultiError, or nil if none found.
func (m *CreateTransactionSolanaSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionSolanaSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventType

	if len(errors) > 0 {
		return CreateTransactionSolanaSpecificMultiError(errors)
	}

	return nil
}

// CreateTransactionSolanaSpecificMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionSolanaSpecific.ValidateAll()
// if the designated constraints aren't met.
type CreateTransactionSolanaSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionSolanaSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionSolanaSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionSolanaSpecificValidationError is the validation error
// returned by CreateTransactionSolanaSpecific.Validate if the designated
// constraints aren't met.
type CreateTransactionSolanaSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionSolanaSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionSolanaSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionSolanaSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionSolanaSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionSolanaSpecificValidationError) ErrorName() string {
	return "CreateTransactionSolanaSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionSolanaSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionSolanaSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionSolanaSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionSolanaSpecificValidationError{}

// Validate checks the field values on CreateTransactionAptosSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateTransactionAptosSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionAptosSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// CreateTransactionAptosSpecificMultiError, or nil if none found.
func (m *CreateTransactionAptosSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionAptosSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.Expiration != nil {
		// no validation rules for Expiration
	}

	if len(errors) > 0 {
		return CreateTransactionAptosSpecificMultiError(errors)
	}

	return nil
}

// CreateTransactionAptosSpecificMultiError is an error wrapping multiple
// validation errors returned by CreateTransactionAptosSpecific.ValidateAll()
// if the designated constraints aren't met.
type CreateTransactionAptosSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionAptosSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionAptosSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionAptosSpecificValidationError is the validation error
// returned by CreateTransactionAptosSpecific.Validate if the designated
// constraints aren't met.
type CreateTransactionAptosSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionAptosSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionAptosSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionAptosSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionAptosSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionAptosSpecificValidationError) ErrorName() string {
	return "CreateTransactionAptosSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionAptosSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionAptosSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionAptosSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionAptosSpecificValidationError{}

// Validate checks the field values on CreateTransactionAvalancheSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *CreateTransactionAvalancheSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateTransactionAvalancheSpecific
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// CreateTransactionAvalancheSpecificMultiError, or nil if none found.
func (m *CreateTransactionAvalancheSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateTransactionAvalancheSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if m.TxType != nil {
		// no validation rules for TxType
	}

	if m.ImportTxSpecific != nil {

		if all {
			switch v := interface{}(m.GetImportTxSpecific()).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, CreateTransactionAvalancheSpecificValidationError{
						field:  "ImportTxSpecific",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, CreateTransactionAvalancheSpecificValidationError{
						field:  "ImportTxSpecific",
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(m.GetImportTxSpecific()).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return CreateTransactionAvalancheSpecificValidationError{
					field:  "ImportTxSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return CreateTransactionAvalancheSpecificMultiError(errors)
	}

	return nil
}

// CreateTransactionAvalancheSpecificMultiError is an error wrapping multiple
// validation errors returned by
// CreateTransactionAvalancheSpecific.ValidateAll() if the designated
// constraints aren't met.
type CreateTransactionAvalancheSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateTransactionAvalancheSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateTransactionAvalancheSpecificMultiError) AllErrors() []error { return m }

// CreateTransactionAvalancheSpecificValidationError is the validation error
// returned by CreateTransactionAvalancheSpecific.Validate if the designated
// constraints aren't met.
type CreateTransactionAvalancheSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateTransactionAvalancheSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateTransactionAvalancheSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateTransactionAvalancheSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateTransactionAvalancheSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateTransactionAvalancheSpecificValidationError) ErrorName() string {
	return "CreateTransactionAvalancheSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e CreateTransactionAvalancheSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateTransactionAvalancheSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateTransactionAvalancheSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateTransactionAvalancheSpecificValidationError{}

// Validate checks the field values on ImportTxSpecific with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *ImportTxSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ImportTxSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ImportTxSpecificMultiError, or nil if none found.
func (m *ImportTxSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *ImportTxSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	// no validation rules for OutputIndex

	// no validation rules for ExportedAmount

	// no validation rules for StringExportedAmount

	if len(errors) > 0 {
		return ImportTxSpecificMultiError(errors)
	}

	return nil
}

// ImportTxSpecificMultiError is an error wrapping multiple validation errors
// returned by ImportTxSpecific.ValidateAll() if the designated constraints
// aren't met.
type ImportTxSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ImportTxSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ImportTxSpecificMultiError) AllErrors() []error { return m }

// ImportTxSpecificValidationError is the validation error returned by
// ImportTxSpecific.Validate if the designated constraints aren't met.
type ImportTxSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ImportTxSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ImportTxSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ImportTxSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ImportTxSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ImportTxSpecificValidationError) ErrorName() string { return "ImportTxSpecificValidationError" }

// Error satisfies the builtin error interface
func (e ImportTxSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sImportTxSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ImportTxSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ImportTxSpecificValidationError{}

// Validate checks the field values on SelectedUTXO with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SelectedUTXO) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SelectedUTXO with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SelectedUTXOMultiError, or
// nil if none found.
func (m *SelectedUTXO) ValidateAll() error {
	return m.validate(true)
}

func (m *SelectedUTXO) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxId

	// no validation rules for Vout

	if len(errors) > 0 {
		return SelectedUTXOMultiError(errors)
	}

	return nil
}

// SelectedUTXOMultiError is an error wrapping multiple validation errors
// returned by SelectedUTXO.ValidateAll() if the designated constraints aren't met.
type SelectedUTXOMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SelectedUTXOMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SelectedUTXOMultiError) AllErrors() []error { return m }

// SelectedUTXOValidationError is the validation error returned by
// SelectedUTXO.Validate if the designated constraints aren't met.
type SelectedUTXOValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SelectedUTXOValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SelectedUTXOValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SelectedUTXOValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SelectedUTXOValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SelectedUTXOValidationError) ErrorName() string { return "SelectedUTXOValidationError" }

// Error satisfies the builtin error interface
func (e SelectedUTXOValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSelectedUTXO.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SelectedUTXOValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SelectedUTXOValidationError{}

// Validate checks the field values on SubstrateMultisigTransaction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubstrateMultisigTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubstrateMultisigTransaction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubstrateMultisigTransactionMultiError, or nil if none found.
func (m *SubstrateMultisigTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *SubstrateMultisigTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for SubstrateMultisigTransactionId

	// no validation rules for AccountId

	// no validation rules for TxId

	// no validation rules for ExtrinsicId

	// no validation rules for JpyRate

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for Nonce

	// no validation rules for MultisigCallType

	// no validation rules for State

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubstrateMultisigTransactionValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubstrateMultisigTransactionValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubstrateMultisigTransactionValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SubstrateMultisigTransactionValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SubstrateMultisigTransactionValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SubstrateMultisigTransactionValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SubstrateMultisigTransactionMultiError(errors)
	}

	return nil
}

// SubstrateMultisigTransactionMultiError is an error wrapping multiple
// validation errors returned by SubstrateMultisigTransaction.ValidateAll() if
// the designated constraints aren't met.
type SubstrateMultisigTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubstrateMultisigTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubstrateMultisigTransactionMultiError) AllErrors() []error { return m }

// SubstrateMultisigTransactionValidationError is the validation error returned
// by SubstrateMultisigTransaction.Validate if the designated constraints
// aren't met.
type SubstrateMultisigTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubstrateMultisigTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubstrateMultisigTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubstrateMultisigTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubstrateMultisigTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubstrateMultisigTransactionValidationError) ErrorName() string {
	return "SubstrateMultisigTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e SubstrateMultisigTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubstrateMultisigTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubstrateMultisigTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubstrateMultisigTransactionValidationError{}

// Validate checks the field values on NemMultisigTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *NemMultisigTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on NemMultisigTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// NemMultisigTransactionMultiError, or nil if none found.
func (m *NemMultisigTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *NemMultisigTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for NemMultisigTransactionId

	// no validation rules for AccountId

	// no validation rules for TxType

	// no validation rules for Data

	// no validation rules for Signature

	// no validation rules for State

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NemMultisigTransactionValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NemMultisigTransactionValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NemMultisigTransactionValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, NemMultisigTransactionValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, NemMultisigTransactionValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return NemMultisigTransactionValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return NemMultisigTransactionMultiError(errors)
	}

	return nil
}

// NemMultisigTransactionMultiError is an error wrapping multiple validation
// errors returned by NemMultisigTransaction.ValidateAll() if the designated
// constraints aren't met.
type NemMultisigTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m NemMultisigTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m NemMultisigTransactionMultiError) AllErrors() []error { return m }

// NemMultisigTransactionValidationError is the validation error returned by
// NemMultisigTransaction.Validate if the designated constraints aren't met.
type NemMultisigTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e NemMultisigTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e NemMultisigTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e NemMultisigTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e NemMultisigTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e NemMultisigTransactionValidationError) ErrorName() string {
	return "NemMultisigTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e NemMultisigTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sNemMultisigTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = NemMultisigTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = NemMultisigTransactionValidationError{}

// Validate checks the field values on SymbolMultisigTransaction with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SymbolMultisigTransaction) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SymbolMultisigTransaction with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SymbolMultisigTransactionMultiError, or nil if none found.
func (m *SymbolMultisigTransaction) ValidateAll() error {
	return m.validate(true)
}

func (m *SymbolMultisigTransaction) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for SymbolMultisigTransactionId

	// no validation rules for AccountId

	// no validation rules for TxType

	// no validation rules for Data

	// no validation rules for Signature

	// no validation rules for State

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SymbolMultisigTransactionValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SymbolMultisigTransactionValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SymbolMultisigTransactionValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, SymbolMultisigTransactionValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, SymbolMultisigTransactionValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return SymbolMultisigTransactionValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return SymbolMultisigTransactionMultiError(errors)
	}

	return nil
}

// SymbolMultisigTransactionMultiError is an error wrapping multiple validation
// errors returned by SymbolMultisigTransaction.ValidateAll() if the
// designated constraints aren't met.
type SymbolMultisigTransactionMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SymbolMultisigTransactionMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SymbolMultisigTransactionMultiError) AllErrors() []error { return m }

// SymbolMultisigTransactionValidationError is the validation error returned by
// SymbolMultisigTransaction.Validate if the designated constraints aren't met.
type SymbolMultisigTransactionValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SymbolMultisigTransactionValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SymbolMultisigTransactionValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SymbolMultisigTransactionValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SymbolMultisigTransactionValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SymbolMultisigTransactionValidationError) ErrorName() string {
	return "SymbolMultisigTransactionValidationError"
}

// Error satisfies the builtin error interface
func (e SymbolMultisigTransactionValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSymbolMultisigTransaction.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SymbolMultisigTransactionValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SymbolMultisigTransactionValidationError{}

// Validate checks the field values on SignInfo with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SignInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignInfo with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SignInfoMultiError, or nil
// if none found.
func (m *SignInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *SignInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for KeyId

	// no validation rules for HdAccount

	// no validation rules for Coin

	// no validation rules for TxId

	// no validation rules for SignIndex

	// no validation rules for SignMessage

	// no validation rules for HdChange

	// no validation rules for HdIndex

	// no validation rules for Network

	for idx, item := range m.GetSignTxInputs() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, SignInfoValidationError{
						field:  fmt.Sprintf("SignTxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, SignInfoValidationError{
						field:  fmt.Sprintf("SignTxInputs[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return SignInfoValidationError{
					field:  fmt.Sprintf("SignTxInputs[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return SignInfoMultiError(errors)
	}

	return nil
}

// SignInfoMultiError is an error wrapping multiple validation errors returned
// by SignInfo.ValidateAll() if the designated constraints aren't met.
type SignInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignInfoMultiError) AllErrors() []error { return m }

// SignInfoValidationError is the validation error returned by
// SignInfo.Validate if the designated constraints aren't met.
type SignInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignInfoValidationError) ErrorName() string { return "SignInfoValidationError" }

// Error satisfies the builtin error interface
func (e SignInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignInfoValidationError{}

// Validate checks the field values on SignTxInput with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *SignTxInput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignTxInput with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in SignTxInputMultiError, or
// nil if none found.
func (m *SignTxInput) ValidateAll() error {
	return m.validate(true)
}

func (m *SignTxInput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TxInputIndex

	// no validation rules for SignMessage

	// no validation rules for HdChange

	// no validation rules for HdIndex

	if len(errors) > 0 {
		return SignTxInputMultiError(errors)
	}

	return nil
}

// SignTxInputMultiError is an error wrapping multiple validation errors
// returned by SignTxInput.ValidateAll() if the designated constraints aren't met.
type SignTxInputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignTxInputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignTxInputMultiError) AllErrors() []error { return m }

// SignTxInputValidationError is the validation error returned by
// SignTxInput.Validate if the designated constraints aren't met.
type SignTxInputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignTxInputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignTxInputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignTxInputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignTxInputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignTxInputValidationError) ErrorName() string { return "SignTxInputValidationError" }

// Error satisfies the builtin error interface
func (e SignTxInputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignTxInput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignTxInputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignTxInputValidationError{}

// Validate checks the field values on Transfer with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Transfer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Transfer with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransferMultiError, or nil
// if none found.
func (m *Transfer) ValidateAll() error {
	return m.validate(true)
}

func (m *Transfer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransferId

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for TxId

	// no validation rules for TransferType

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for JpyRate

	// no validation rules for PartnerWalletId

	// no validation rules for PartnerAddress

	// no validation rules for DestinationTag

	// no validation rules for MemoId

	// no validation rules for Message

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for From

	// no validation rules for To

	// no validation rules for State

	// no validation rules for Result

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCosmosSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "CosmosSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferValidationError{
					field:  "CosmosSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCosmosSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferValidationError{
				field:  "CosmosSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StakingEventType

	// no validation rules for Method

	if len(errors) > 0 {
		return TransferMultiError(errors)
	}

	return nil
}

// TransferMultiError is an error wrapping multiple validation errors returned
// by Transfer.ValidateAll() if the designated constraints aren't met.
type TransferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferMultiError) AllErrors() []error { return m }

// TransferValidationError is the validation error returned by
// Transfer.Validate if the designated constraints aren't met.
type TransferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferValidationError) ErrorName() string { return "TransferValidationError" }

// Error satisfies the builtin error interface
func (e TransferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransfer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferValidationError{}

// Validate checks the field values on TransferCosmosSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransferCosmosSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferCosmosSpecific with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransferCosmosSpecificMultiError, or nil if none found.
func (m *TransferCosmosSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferCosmosSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Type

	// no validation rules for DelegateAmount

	// no validation rules for RewardAmount

	if len(errors) > 0 {
		return TransferCosmosSpecificMultiError(errors)
	}

	return nil
}

// TransferCosmosSpecificMultiError is an error wrapping multiple validation
// errors returned by TransferCosmosSpecific.ValidateAll() if the designated
// constraints aren't met.
type TransferCosmosSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferCosmosSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferCosmosSpecificMultiError) AllErrors() []error { return m }

// TransferCosmosSpecificValidationError is the validation error returned by
// TransferCosmosSpecific.Validate if the designated constraints aren't met.
type TransferCosmosSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferCosmosSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferCosmosSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferCosmosSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferCosmosSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferCosmosSpecificValidationError) ErrorName() string {
	return "TransferCosmosSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e TransferCosmosSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferCosmosSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferCosmosSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferCosmosSpecificValidationError{}

// Validate checks the field values on UncheckedTransfer with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *UncheckedTransfer) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on UncheckedTransfer with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// UncheckedTransferMultiError, or nil if none found.
func (m *UncheckedTransfer) ValidateAll() error {
	return m.validate(true)
}

func (m *UncheckedTransfer) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for TransferId

	// no validation rules for Coin

	// no validation rules for TxId

	// no validation rules for TransferType

	// no validation rules for State

	// no validation rules for Result

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for JpyRate

	// no validation rules for PartnerWalletId

	// no validation rules for PartnerAddress

	// no validation rules for DestinationTag

	// no validation rules for MemoId

	// no validation rules for Message

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for From

	// no validation rules for To

	// no validation rules for HasChecked

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UncheckedTransferValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UncheckedTransferValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UncheckedTransferValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, UncheckedTransferValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, UncheckedTransferValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return UncheckedTransferValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return UncheckedTransferMultiError(errors)
	}

	return nil
}

// UncheckedTransferMultiError is an error wrapping multiple validation errors
// returned by UncheckedTransfer.ValidateAll() if the designated constraints
// aren't met.
type UncheckedTransferMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m UncheckedTransferMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m UncheckedTransferMultiError) AllErrors() []error { return m }

// UncheckedTransferValidationError is the validation error returned by
// UncheckedTransfer.Validate if the designated constraints aren't met.
type UncheckedTransferValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e UncheckedTransferValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e UncheckedTransferValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e UncheckedTransferValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e UncheckedTransferValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e UncheckedTransferValidationError) ErrorName() string {
	return "UncheckedTransferValidationError"
}

// Error satisfies the builtin error interface
func (e UncheckedTransferValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sUncheckedTransfer.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = UncheckedTransferValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = UncheckedTransferValidationError{}

// Validate checks the field values on EventTriggeredMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *EventTriggeredMessage) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on EventTriggeredMessage with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// EventTriggeredMessageMultiError, or nil if none found.
func (m *EventTriggeredMessage) ValidateAll() error {
	return m.validate(true)
}

func (m *EventTriggeredMessage) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventTriggeredMessageId

	// no validation rules for EventTriggeredMessageType

	// no validation rules for OwnerId

	// no validation rules for Destination

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EventTriggeredMessageValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EventTriggeredMessageValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EventTriggeredMessageValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, EventTriggeredMessageValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, EventTriggeredMessageValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return EventTriggeredMessageValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return EventTriggeredMessageMultiError(errors)
	}

	return nil
}

// EventTriggeredMessageMultiError is an error wrapping multiple validation
// errors returned by EventTriggeredMessage.ValidateAll() if the designated
// constraints aren't met.
type EventTriggeredMessageMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m EventTriggeredMessageMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m EventTriggeredMessageMultiError) AllErrors() []error { return m }

// EventTriggeredMessageValidationError is the validation error returned by
// EventTriggeredMessage.Validate if the designated constraints aren't met.
type EventTriggeredMessageValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e EventTriggeredMessageValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e EventTriggeredMessageValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e EventTriggeredMessageValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e EventTriggeredMessageValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e EventTriggeredMessageValidationError) ErrorName() string {
	return "EventTriggeredMessageValidationError"
}

// Error satisfies the builtin error interface
func (e EventTriggeredMessageValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sEventTriggeredMessage.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = EventTriggeredMessageValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = EventTriggeredMessageValidationError{}

// Validate checks the field values on Rate with the rules defined in the proto
// definition for this message. If any rules are violated, the first error
// encountered is returned, or nil if there are no violations.
func (m *Rate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Rate with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in RateMultiError, or nil if none found.
func (m *Rate) ValidateAll() error {
	return m.validate(true)
}

func (m *Rate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Coin

	// no validation rules for Jpy

	if len(errors) > 0 {
		return RateMultiError(errors)
	}

	return nil
}

// RateMultiError is an error wrapping multiple validation errors returned by
// Rate.ValidateAll() if the designated constraints aren't met.
type RateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateMultiError) AllErrors() []error { return m }

// RateValidationError is the validation error returned by Rate.Validate if the
// designated constraints aren't met.
type RateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateValidationError) ErrorName() string { return "RateValidationError" }

// Error satisfies the builtin error interface
func (e RateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateValidationError{}

// Validate checks the field values on RateSnapshot with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RateSnapshot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RateSnapshot with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RateSnapshotMultiError, or
// nil if none found.
func (m *RateSnapshot) ValidateAll() error {
	return m.validate(true)
}

func (m *RateSnapshot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RateSnapshotId

	{
		sorted_keys := make([]uint32, len(m.GetRates()))
		i := 0
		for key := range m.GetRates() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetRates()[key]
			_ = val

			// no validation rules for Rates[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, RateSnapshotValidationError{
							field:  fmt.Sprintf("Rates[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, RateSnapshotValidationError{
							field:  fmt.Sprintf("Rates[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return RateSnapshotValidationError{
						field:  fmt.Sprintf("Rates[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return RateSnapshotMultiError(errors)
	}

	return nil
}

// RateSnapshotMultiError is an error wrapping multiple validation errors
// returned by RateSnapshot.ValidateAll() if the designated constraints aren't met.
type RateSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RateSnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RateSnapshotMultiError) AllErrors() []error { return m }

// RateSnapshotValidationError is the validation error returned by
// RateSnapshot.Validate if the designated constraints aren't met.
type RateSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RateSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RateSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RateSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RateSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RateSnapshotValidationError) ErrorName() string { return "RateSnapshotValidationError" }

// Error satisfies the builtin error interface
func (e RateSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRateSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RateSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RateSnapshotValidationError{}

// Validate checks the field values on Deactivatability with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *Deactivatability) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Deactivatability with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// DeactivatabilityMultiError, or nil if none found.
func (m *Deactivatability) ValidateAll() error {
	return m.validate(true)
}

func (m *Deactivatability) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountId

	// no validation rules for Deactivatable

	if len(errors) > 0 {
		return DeactivatabilityMultiError(errors)
	}

	return nil
}

// DeactivatabilityMultiError is an error wrapping multiple validation errors
// returned by Deactivatability.ValidateAll() if the designated constraints
// aren't met.
type DeactivatabilityMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m DeactivatabilityMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m DeactivatabilityMultiError) AllErrors() []error { return m }

// DeactivatabilityValidationError is the validation error returned by
// Deactivatability.Validate if the designated constraints aren't met.
type DeactivatabilityValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e DeactivatabilityValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e DeactivatabilityValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e DeactivatabilityValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e DeactivatabilityValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e DeactivatabilityValidationError) ErrorName() string { return "DeactivatabilityValidationError" }

// Error satisfies the builtin error interface
func (e DeactivatabilityValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sDeactivatability.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = DeactivatabilityValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = DeactivatabilityValidationError{}

// Validate checks the field values on LabeledAddress with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *LabeledAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LabeledAddress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in LabeledAddressMultiError,
// or nil if none found.
func (m *LabeledAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *LabeledAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for LabeledAddressId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Address

	if all {
		switch v := interface{}(m.GetProposal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LabeledAddressValidationError{
					field:  "Proposal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LabeledAddressValidationError{
					field:  "Proposal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProposal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LabeledAddressValidationError{
				field:  "Proposal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LabeledAddressValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LabeledAddressValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LabeledAddressValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, LabeledAddressValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, LabeledAddressValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return LabeledAddressValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for Network

	if len(errors) > 0 {
		return LabeledAddressMultiError(errors)
	}

	return nil
}

// LabeledAddressMultiError is an error wrapping multiple validation errors
// returned by LabeledAddress.ValidateAll() if the designated constraints
// aren't met.
type LabeledAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabeledAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabeledAddressMultiError) AllErrors() []error { return m }

// LabeledAddressValidationError is the validation error returned by
// LabeledAddress.Validate if the designated constraints aren't met.
type LabeledAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabeledAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabeledAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabeledAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabeledAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabeledAddressValidationError) ErrorName() string { return "LabeledAddressValidationError" }

// Error satisfies the builtin error interface
func (e LabeledAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabeledAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabeledAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabeledAddressValidationError{}

// Validate checks the field values on LabeledAddressProposal with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *LabeledAddressProposal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on LabeledAddressProposal with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// LabeledAddressProposalMultiError, or nil if none found.
func (m *LabeledAddressProposal) ValidateAll() error {
	return m.validate(true)
}

func (m *LabeledAddressProposal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	// no validation rules for ProposedAddress

	// no validation rules for AddressIsReviewed

	if len(errors) > 0 {
		return LabeledAddressProposalMultiError(errors)
	}

	return nil
}

// LabeledAddressProposalMultiError is an error wrapping multiple validation
// errors returned by LabeledAddressProposal.ValidateAll() if the designated
// constraints aren't met.
type LabeledAddressProposalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m LabeledAddressProposalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m LabeledAddressProposalMultiError) AllErrors() []error { return m }

// LabeledAddressProposalValidationError is the validation error returned by
// LabeledAddressProposal.Validate if the designated constraints aren't met.
type LabeledAddressProposalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e LabeledAddressProposalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e LabeledAddressProposalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e LabeledAddressProposalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e LabeledAddressProposalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e LabeledAddressProposalValidationError) ErrorName() string {
	return "LabeledAddressProposalValidationError"
}

// Error satisfies the builtin error interface
func (e LabeledAddressProposalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sLabeledAddressProposal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = LabeledAddressProposalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = LabeledAddressProposalValidationError{}

// Validate checks the field values on Whitelist with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Whitelist) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Whitelist with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WhitelistMultiError, or nil
// if none found.
func (m *Whitelist) ValidateAll() error {
	return m.validate(true)
}

func (m *Whitelist) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WhitelistId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Network

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WhitelistValidationError{
						field:  fmt.Sprintf("Addresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WhitelistValidationError{
						field:  fmt.Sprintf("Addresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WhitelistValidationError{
					field:  fmt.Sprintf("Addresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WhitelistValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WhitelistValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WhitelistValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WhitelistValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WhitelistValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WhitelistValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WhitelistMultiError(errors)
	}

	return nil
}

// WhitelistMultiError is an error wrapping multiple validation errors returned
// by Whitelist.ValidateAll() if the designated constraints aren't met.
type WhitelistMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WhitelistMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WhitelistMultiError) AllErrors() []error { return m }

// WhitelistValidationError is the validation error returned by
// Whitelist.Validate if the designated constraints aren't met.
type WhitelistValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WhitelistValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WhitelistValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WhitelistValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WhitelistValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WhitelistValidationError) ErrorName() string { return "WhitelistValidationError" }

// Error satisfies the builtin error interface
func (e WhitelistValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWhitelist.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WhitelistValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WhitelistValidationError{}

// Validate checks the field values on TransferLimit with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TransferLimit) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferLimit with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransferLimitMultiError, or
// nil if none found.
func (m *TransferLimit) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferLimit) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for TransferLimitId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for HourlyLimit

	// no validation rules for DailyLimit

	// no validation rules for OneTimeLimit

	if all {
		switch v := interface{}(m.GetProposal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferLimitValidationError{
					field:  "Proposal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferLimitValidationError{
					field:  "Proposal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProposal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferLimitValidationError{
				field:  "Proposal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsReviewed

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferLimitValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferLimitValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferLimitValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferLimitValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferLimitValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferLimitValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return TransferLimitMultiError(errors)
	}

	return nil
}

// TransferLimitMultiError is an error wrapping multiple validation errors
// returned by TransferLimit.ValidateAll() if the designated constraints
// aren't met.
type TransferLimitMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferLimitMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferLimitMultiError) AllErrors() []error { return m }

// TransferLimitValidationError is the validation error returned by
// TransferLimit.Validate if the designated constraints aren't met.
type TransferLimitValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferLimitValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferLimitValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferLimitValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferLimitValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferLimitValidationError) ErrorName() string { return "TransferLimitValidationError" }

// Error satisfies the builtin error interface
func (e TransferLimitValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferLimit.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferLimitValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferLimitValidationError{}

// Validate checks the field values on TransferLimitProposal with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransferLimitProposal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferLimitProposal with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransferLimitProposalMultiError, or nil if none found.
func (m *TransferLimitProposal) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferLimitProposal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	// no validation rules for ProposedHourlyLimit

	// no validation rules for ProposedDailyLimit

	// no validation rules for ProposedOneTimeLimit

	// no validation rules for IsReviewed

	if len(errors) > 0 {
		return TransferLimitProposalMultiError(errors)
	}

	return nil
}

// TransferLimitProposalMultiError is an error wrapping multiple validation
// errors returned by TransferLimitProposal.ValidateAll() if the designated
// constraints aren't met.
type TransferLimitProposalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferLimitProposalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferLimitProposalMultiError) AllErrors() []error { return m }

// TransferLimitProposalValidationError is the validation error returned by
// TransferLimitProposal.Validate if the designated constraints aren't met.
type TransferLimitProposalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferLimitProposalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferLimitProposalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferLimitProposalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferLimitProposalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferLimitProposalValidationError) ErrorName() string {
	return "TransferLimitProposalValidationError"
}

// Error satisfies the builtin error interface
func (e TransferLimitProposalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferLimitProposal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferLimitProposalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferLimitProposalValidationError{}

// Validate checks the field values on Policy with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Policy) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Policy with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in PolicyMultiError, or nil if none found.
func (m *Policy) ValidateAll() error {
	return m.validate(true)
}

func (m *Policy) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for PolicyId

	// no validation rules for PolicyType

	// no validation rules for Name

	// no validation rules for IsBasePolicy

	// no validation rules for Coin

	// no validation rules for Network

	if all {
		switch v := interface{}(m.GetWhitelist()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "Whitelist",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "Whitelist",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetWhitelist()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PolicyValidationError{
				field:  "Whitelist",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetTransferLimit()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "TransferLimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "TransferLimit",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTransferLimit()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PolicyValidationError{
				field:  "TransferLimit",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetProposal()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "Proposal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "Proposal",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProposal()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PolicyValidationError{
				field:  "Proposal",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PolicyValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PolicyValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PolicyValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return PolicyMultiError(errors)
	}

	return nil
}

// PolicyMultiError is an error wrapping multiple validation errors returned by
// Policy.ValidateAll() if the designated constraints aren't met.
type PolicyMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolicyMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolicyMultiError) AllErrors() []error { return m }

// PolicyValidationError is the validation error returned by Policy.Validate if
// the designated constraints aren't met.
type PolicyValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolicyValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolicyValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolicyValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolicyValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolicyValidationError) ErrorName() string { return "PolicyValidationError" }

// Error satisfies the builtin error interface
func (e PolicyValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolicy.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolicyValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolicyValidationError{}

// Validate checks the field values on PolicyProposal with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *PolicyProposal) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on PolicyProposal with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in PolicyProposalMultiError,
// or nil if none found.
func (m *PolicyProposal) ValidateAll() error {
	return m.validate(true)
}

func (m *PolicyProposal) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	if all {
		switch v := interface{}(m.GetProposedWhitelist()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, PolicyProposalValidationError{
					field:  "ProposedWhitelist",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, PolicyProposalValidationError{
					field:  "ProposedWhitelist",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetProposedWhitelist()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return PolicyProposalValidationError{
				field:  "ProposedWhitelist",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for IsReviewed

	if len(errors) > 0 {
		return PolicyProposalMultiError(errors)
	}

	return nil
}

// PolicyProposalMultiError is an error wrapping multiple validation errors
// returned by PolicyProposal.ValidateAll() if the designated constraints
// aren't met.
type PolicyProposalMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m PolicyProposalMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m PolicyProposalMultiError) AllErrors() []error { return m }

// PolicyProposalValidationError is the validation error returned by
// PolicyProposal.Validate if the designated constraints aren't met.
type PolicyProposalValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e PolicyProposalValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e PolicyProposalValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e PolicyProposalValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e PolicyProposalValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e PolicyProposalValidationError) ErrorName() string { return "PolicyProposalValidationError" }

// Error satisfies the builtin error interface
func (e PolicyProposalValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sPolicyProposal.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = PolicyProposalValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = PolicyProposalValidationError{}

// Validate checks the field values on TotalBalanceByCoin with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TotalBalanceByCoin) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TotalBalanceByCoin with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TotalBalanceByCoinMultiError, or nil if none found.
func (m *TotalBalanceByCoin) ValidateAll() error {
	return m.validate(true)
}

func (m *TotalBalanceByCoin) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for ColdStringBalance

	// no validation rules for HotStringBalance

	if len(errors) > 0 {
		return TotalBalanceByCoinMultiError(errors)
	}

	return nil
}

// TotalBalanceByCoinMultiError is an error wrapping multiple validation errors
// returned by TotalBalanceByCoin.ValidateAll() if the designated constraints
// aren't met.
type TotalBalanceByCoinMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TotalBalanceByCoinMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TotalBalanceByCoinMultiError) AllErrors() []error { return m }

// TotalBalanceByCoinValidationError is the validation error returned by
// TotalBalanceByCoin.Validate if the designated constraints aren't met.
type TotalBalanceByCoinValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TotalBalanceByCoinValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TotalBalanceByCoinValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TotalBalanceByCoinValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TotalBalanceByCoinValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TotalBalanceByCoinValidationError) ErrorName() string {
	return "TotalBalanceByCoinValidationError"
}

// Error satisfies the builtin error interface
func (e TotalBalanceByCoinValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTotalBalanceByCoin.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TotalBalanceByCoinValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TotalBalanceByCoinValidationError{}

// Validate checks the field values on TotalBalance with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TotalBalance) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TotalBalance with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TotalBalanceMultiError, or
// nil if none found.
func (m *TotalBalance) ValidateAll() error {
	return m.validate(true)
}

func (m *TotalBalance) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]uint32, len(m.GetTotalBalances()))
		i := 0
		for key := range m.GetTotalBalances() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetTotalBalances()[key]
			_ = val

			if val == nil {
				err := TotalBalanceValidationError{
					field:  fmt.Sprintf("TotalBalances[%v]", key),
					reason: "value cannot be sparse, all pairs must be non-nil",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			// no validation rules for TotalBalances[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TotalBalanceValidationError{
							field:  fmt.Sprintf("TotalBalances[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TotalBalanceValidationError{
							field:  fmt.Sprintf("TotalBalances[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TotalBalanceValidationError{
						field:  fmt.Sprintf("TotalBalances[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return TotalBalanceMultiError(errors)
	}

	return nil
}

// TotalBalanceMultiError is an error wrapping multiple validation errors
// returned by TotalBalance.ValidateAll() if the designated constraints aren't met.
type TotalBalanceMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TotalBalanceMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TotalBalanceMultiError) AllErrors() []error { return m }

// TotalBalanceValidationError is the validation error returned by
// TotalBalance.Validate if the designated constraints aren't met.
type TotalBalanceValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TotalBalanceValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TotalBalanceValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TotalBalanceValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TotalBalanceValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TotalBalanceValidationError) ErrorName() string { return "TotalBalanceValidationError" }

// Error satisfies the builtin error interface
func (e TotalBalanceValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTotalBalance.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TotalBalanceValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TotalBalanceValidationError{}

// Validate checks the field values on BalanceSnapshot with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *BalanceSnapshot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on BalanceSnapshot with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// BalanceSnapshotMultiError, or nil if none found.
func (m *BalanceSnapshot) ValidateAll() error {
	return m.validate(true)
}

func (m *BalanceSnapshot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, BalanceSnapshotValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, BalanceSnapshotValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return BalanceSnapshotValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]uint32, len(m.GetTotalBalances()))
		i := 0
		for key := range m.GetTotalBalances() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetTotalBalances()[key]
			_ = val

			if val == nil {
				err := BalanceSnapshotValidationError{
					field:  fmt.Sprintf("TotalBalances[%v]", key),
					reason: "value cannot be sparse, all pairs must be non-nil",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			// no validation rules for TotalBalances[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, BalanceSnapshotValidationError{
							field:  fmt.Sprintf("TotalBalances[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, BalanceSnapshotValidationError{
							field:  fmt.Sprintf("TotalBalances[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return BalanceSnapshotValidationError{
						field:  fmt.Sprintf("TotalBalances[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	{
		sorted_keys := make([]uint32, len(m.GetRates()))
		i := 0
		for key := range m.GetRates() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetRates()[key]
			_ = val

			if val == nil {
				err := BalanceSnapshotValidationError{
					field:  fmt.Sprintf("Rates[%v]", key),
					reason: "value cannot be sparse, all pairs must be non-nil",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			// no validation rules for Rates[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, BalanceSnapshotValidationError{
							field:  fmt.Sprintf("Rates[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, BalanceSnapshotValidationError{
							field:  fmt.Sprintf("Rates[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return BalanceSnapshotValidationError{
						field:  fmt.Sprintf("Rates[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return BalanceSnapshotMultiError(errors)
	}

	return nil
}

// BalanceSnapshotMultiError is an error wrapping multiple validation errors
// returned by BalanceSnapshot.ValidateAll() if the designated constraints
// aren't met.
type BalanceSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m BalanceSnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m BalanceSnapshotMultiError) AllErrors() []error { return m }

// BalanceSnapshotValidationError is the validation error returned by
// BalanceSnapshot.Validate if the designated constraints aren't met.
type BalanceSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e BalanceSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e BalanceSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e BalanceSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e BalanceSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e BalanceSnapshotValidationError) ErrorName() string { return "BalanceSnapshotValidationError" }

// Error satisfies the builtin error interface
func (e BalanceSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sBalanceSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = BalanceSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = BalanceSnapshotValidationError{}

// Validate checks the field values on WalletBalanceSnapshotMap with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WalletBalanceSnapshotMap) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalletBalanceSnapshotMap with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WalletBalanceSnapshotMapMultiError, or nil if none found.
func (m *WalletBalanceSnapshotMap) ValidateAll() error {
	return m.validate(true)
}

func (m *WalletBalanceSnapshotMap) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetWalletBalanceSnapshotMap()))
		i := 0
		for key := range m.GetWalletBalanceSnapshotMap() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetWalletBalanceSnapshotMap()[key]
			_ = val

			if val == nil {
				err := WalletBalanceSnapshotMapValidationError{
					field:  fmt.Sprintf("WalletBalanceSnapshotMap[%v]", key),
					reason: "value cannot be sparse, all pairs must be non-nil",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			// no validation rules for WalletBalanceSnapshotMap[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, WalletBalanceSnapshotMapValidationError{
							field:  fmt.Sprintf("WalletBalanceSnapshotMap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, WalletBalanceSnapshotMapValidationError{
							field:  fmt.Sprintf("WalletBalanceSnapshotMap[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return WalletBalanceSnapshotMapValidationError{
						field:  fmt.Sprintf("WalletBalanceSnapshotMap[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return WalletBalanceSnapshotMapMultiError(errors)
	}

	return nil
}

// WalletBalanceSnapshotMapMultiError is an error wrapping multiple validation
// errors returned by WalletBalanceSnapshotMap.ValidateAll() if the designated
// constraints aren't met.
type WalletBalanceSnapshotMapMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletBalanceSnapshotMapMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletBalanceSnapshotMapMultiError) AllErrors() []error { return m }

// WalletBalanceSnapshotMapValidationError is the validation error returned by
// WalletBalanceSnapshotMap.Validate if the designated constraints aren't met.
type WalletBalanceSnapshotMapValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletBalanceSnapshotMapValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletBalanceSnapshotMapValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletBalanceSnapshotMapValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletBalanceSnapshotMapValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletBalanceSnapshotMapValidationError) ErrorName() string {
	return "WalletBalanceSnapshotMapValidationError"
}

// Error satisfies the builtin error interface
func (e WalletBalanceSnapshotMapValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletBalanceSnapshotMap.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletBalanceSnapshotMapValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletBalanceSnapshotMapValidationError{}

// Validate checks the field values on ListWalletBalanceSnapshots with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListWalletBalanceSnapshots) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWalletBalanceSnapshots with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListWalletBalanceSnapshotsMultiError, or nil if none found.
func (m *ListWalletBalanceSnapshots) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWalletBalanceSnapshots) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWalletBalanceSnapshots() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWalletBalanceSnapshotsValidationError{
						field:  fmt.Sprintf("WalletBalanceSnapshots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWalletBalanceSnapshotsValidationError{
						field:  fmt.Sprintf("WalletBalanceSnapshots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWalletBalanceSnapshotsValidationError{
					field:  fmt.Sprintf("WalletBalanceSnapshots[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListWalletBalanceSnapshotsMultiError(errors)
	}

	return nil
}

// ListWalletBalanceSnapshotsMultiError is an error wrapping multiple
// validation errors returned by ListWalletBalanceSnapshots.ValidateAll() if
// the designated constraints aren't met.
type ListWalletBalanceSnapshotsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletBalanceSnapshotsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletBalanceSnapshotsMultiError) AllErrors() []error { return m }

// ListWalletBalanceSnapshotsValidationError is the validation error returned
// by ListWalletBalanceSnapshots.Validate if the designated constraints aren't met.
type ListWalletBalanceSnapshotsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletBalanceSnapshotsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletBalanceSnapshotsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletBalanceSnapshotsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletBalanceSnapshotsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletBalanceSnapshotsValidationError) ErrorName() string {
	return "ListWalletBalanceSnapshotsValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletBalanceSnapshotsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletBalanceSnapshots.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletBalanceSnapshotsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletBalanceSnapshotsValidationError{}

// Validate checks the field values on WalletBalanceSnapshot with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WalletBalanceSnapshot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalletBalanceSnapshot with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WalletBalanceSnapshotMultiError, or nil if none found.
func (m *WalletBalanceSnapshot) ValidateAll() error {
	return m.validate(true)
}

func (m *WalletBalanceSnapshot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalletBalanceSnapshotValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalletBalanceSnapshotValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalletBalanceSnapshotValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for StringBalance

	// no validation rules for Jpy

	if len(errors) > 0 {
		return WalletBalanceSnapshotMultiError(errors)
	}

	return nil
}

// WalletBalanceSnapshotMultiError is an error wrapping multiple validation
// errors returned by WalletBalanceSnapshot.ValidateAll() if the designated
// constraints aren't met.
type WalletBalanceSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletBalanceSnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletBalanceSnapshotMultiError) AllErrors() []error { return m }

// WalletBalanceSnapshotValidationError is the validation error returned by
// WalletBalanceSnapshot.Validate if the designated constraints aren't met.
type WalletBalanceSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletBalanceSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletBalanceSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletBalanceSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletBalanceSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletBalanceSnapshotValidationError) ErrorName() string {
	return "WalletBalanceSnapshotValidationError"
}

// Error satisfies the builtin error interface
func (e WalletBalanceSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletBalanceSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletBalanceSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletBalanceSnapshotValidationError{}

// Validate checks the field values on TransferVolumeSnapshots with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransferVolumeSnapshots) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferVolumeSnapshots with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransferVolumeSnapshotsMultiError, or nil if none found.
func (m *TransferVolumeSnapshots) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferVolumeSnapshots) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]int32, len(m.GetTransferVolumeSnapshotByTransferType()))
		i := 0
		for key := range m.GetTransferVolumeSnapshotByTransferType() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetTransferVolumeSnapshotByTransferType()[key]
			_ = val

			if val == nil {
				err := TransferVolumeSnapshotsValidationError{
					field:  fmt.Sprintf("TransferVolumeSnapshotByTransferType[%v]", key),
					reason: "value cannot be sparse, all pairs must be non-nil",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			// no validation rules for TransferVolumeSnapshotByTransferType[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TransferVolumeSnapshotsValidationError{
							field:  fmt.Sprintf("TransferVolumeSnapshotByTransferType[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TransferVolumeSnapshotsValidationError{
							field:  fmt.Sprintf("TransferVolumeSnapshotByTransferType[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TransferVolumeSnapshotsValidationError{
						field:  fmt.Sprintf("TransferVolumeSnapshotByTransferType[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return TransferVolumeSnapshotsMultiError(errors)
	}

	return nil
}

// TransferVolumeSnapshotsMultiError is an error wrapping multiple validation
// errors returned by TransferVolumeSnapshots.ValidateAll() if the designated
// constraints aren't met.
type TransferVolumeSnapshotsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferVolumeSnapshotsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferVolumeSnapshotsMultiError) AllErrors() []error { return m }

// TransferVolumeSnapshotsValidationError is the validation error returned by
// TransferVolumeSnapshots.Validate if the designated constraints aren't met.
type TransferVolumeSnapshotsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferVolumeSnapshotsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferVolumeSnapshotsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferVolumeSnapshotsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferVolumeSnapshotsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferVolumeSnapshotsValidationError) ErrorName() string {
	return "TransferVolumeSnapshotsValidationError"
}

// Error satisfies the builtin error interface
func (e TransferVolumeSnapshotsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferVolumeSnapshots.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferVolumeSnapshotsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferVolumeSnapshotsValidationError{}

// Validate checks the field values on ListTransferVolumeSnapshots with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ListTransferVolumeSnapshots) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListTransferVolumeSnapshots with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ListTransferVolumeSnapshotsMultiError, or nil if none found.
func (m *ListTransferVolumeSnapshots) ValidateAll() error {
	return m.validate(true)
}

func (m *ListTransferVolumeSnapshots) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetTransferVolumeSnapshots() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListTransferVolumeSnapshotsValidationError{
						field:  fmt.Sprintf("TransferVolumeSnapshots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListTransferVolumeSnapshotsValidationError{
						field:  fmt.Sprintf("TransferVolumeSnapshots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListTransferVolumeSnapshotsValidationError{
					field:  fmt.Sprintf("TransferVolumeSnapshots[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListTransferVolumeSnapshotsMultiError(errors)
	}

	return nil
}

// ListTransferVolumeSnapshotsMultiError is an error wrapping multiple
// validation errors returned by ListTransferVolumeSnapshots.ValidateAll() if
// the designated constraints aren't met.
type ListTransferVolumeSnapshotsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListTransferVolumeSnapshotsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListTransferVolumeSnapshotsMultiError) AllErrors() []error { return m }

// ListTransferVolumeSnapshotsValidationError is the validation error returned
// by ListTransferVolumeSnapshots.Validate if the designated constraints
// aren't met.
type ListTransferVolumeSnapshotsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListTransferVolumeSnapshotsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListTransferVolumeSnapshotsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListTransferVolumeSnapshotsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListTransferVolumeSnapshotsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListTransferVolumeSnapshotsValidationError) ErrorName() string {
	return "ListTransferVolumeSnapshotsValidationError"
}

// Error satisfies the builtin error interface
func (e ListTransferVolumeSnapshotsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListTransferVolumeSnapshots.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListTransferVolumeSnapshotsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListTransferVolumeSnapshotsValidationError{}

// Validate checks the field values on TransferVolumeSnapshot with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *TransferVolumeSnapshot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferVolumeSnapshot with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// TransferVolumeSnapshotMultiError, or nil if none found.
func (m *TransferVolumeSnapshot) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferVolumeSnapshot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTargetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, TransferVolumeSnapshotValidationError{
					field:  "TargetTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, TransferVolumeSnapshotValidationError{
					field:  "TargetTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return TransferVolumeSnapshotValidationError{
				field:  "TargetTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]int32, len(m.GetTransferVolumeByCoin()))
		i := 0
		for key := range m.GetTransferVolumeByCoin() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetTransferVolumeByCoin()[key]
			_ = val

			// no validation rules for TransferVolumeByCoin[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, TransferVolumeSnapshotValidationError{
							field:  fmt.Sprintf("TransferVolumeByCoin[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, TransferVolumeSnapshotValidationError{
							field:  fmt.Sprintf("TransferVolumeByCoin[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return TransferVolumeSnapshotValidationError{
						field:  fmt.Sprintf("TransferVolumeByCoin[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return TransferVolumeSnapshotMultiError(errors)
	}

	return nil
}

// TransferVolumeSnapshotMultiError is an error wrapping multiple validation
// errors returned by TransferVolumeSnapshot.ValidateAll() if the designated
// constraints aren't met.
type TransferVolumeSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferVolumeSnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferVolumeSnapshotMultiError) AllErrors() []error { return m }

// TransferVolumeSnapshotValidationError is the validation error returned by
// TransferVolumeSnapshot.Validate if the designated constraints aren't met.
type TransferVolumeSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferVolumeSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferVolumeSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferVolumeSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferVolumeSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferVolumeSnapshotValidationError) ErrorName() string {
	return "TransferVolumeSnapshotValidationError"
}

// Error satisfies the builtin error interface
func (e TransferVolumeSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferVolumeSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferVolumeSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferVolumeSnapshotValidationError{}

// Validate checks the field values on TransferVolume with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *TransferVolume) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on TransferVolume with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in TransferVolumeMultiError,
// or nil if none found.
func (m *TransferVolume) ValidateAll() error {
	return m.validate(true)
}

func (m *TransferVolume) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for HotStringVolume

	// no validation rules for ColdStringVolume

	// no validation rules for HotStringJpyVolume

	// no validation rules for ColdStringJpyVolume

	// no validation rules for HotNumber

	// no validation rules for ColdNumber

	// no validation rules for TransferType

	if len(errors) > 0 {
		return TransferVolumeMultiError(errors)
	}

	return nil
}

// TransferVolumeMultiError is an error wrapping multiple validation errors
// returned by TransferVolume.ValidateAll() if the designated constraints
// aren't met.
type TransferVolumeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m TransferVolumeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m TransferVolumeMultiError) AllErrors() []error { return m }

// TransferVolumeValidationError is the validation error returned by
// TransferVolume.Validate if the designated constraints aren't met.
type TransferVolumeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e TransferVolumeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e TransferVolumeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e TransferVolumeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e TransferVolumeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e TransferVolumeValidationError) ErrorName() string { return "TransferVolumeValidationError" }

// Error satisfies the builtin error interface
func (e TransferVolumeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sTransferVolume.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = TransferVolumeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = TransferVolumeValidationError{}

// Validate checks the field values on WalletTransferVolumeSnapshots with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WalletTransferVolumeSnapshots) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalletTransferVolumeSnapshots with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// WalletTransferVolumeSnapshotsMultiError, or nil if none found.
func (m *WalletTransferVolumeSnapshots) ValidateAll() error {
	return m.validate(true)
}

func (m *WalletTransferVolumeSnapshots) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	{
		sorted_keys := make([]string, len(m.GetWalletTransferVolumeSnapshotByWalletId()))
		i := 0
		for key := range m.GetWalletTransferVolumeSnapshotByWalletId() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetWalletTransferVolumeSnapshotByWalletId()[key]
			_ = val

			if val == nil {
				err := WalletTransferVolumeSnapshotsValidationError{
					field:  fmt.Sprintf("WalletTransferVolumeSnapshotByWalletId[%v]", key),
					reason: "value cannot be sparse, all pairs must be non-nil",
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}

			// no validation rules for WalletTransferVolumeSnapshotByWalletId[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, WalletTransferVolumeSnapshotsValidationError{
							field:  fmt.Sprintf("WalletTransferVolumeSnapshotByWalletId[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, WalletTransferVolumeSnapshotsValidationError{
							field:  fmt.Sprintf("WalletTransferVolumeSnapshotByWalletId[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return WalletTransferVolumeSnapshotsValidationError{
						field:  fmt.Sprintf("WalletTransferVolumeSnapshotByWalletId[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return WalletTransferVolumeSnapshotsMultiError(errors)
	}

	return nil
}

// WalletTransferVolumeSnapshotsMultiError is an error wrapping multiple
// validation errors returned by WalletTransferVolumeSnapshots.ValidateAll()
// if the designated constraints aren't met.
type WalletTransferVolumeSnapshotsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletTransferVolumeSnapshotsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletTransferVolumeSnapshotsMultiError) AllErrors() []error { return m }

// WalletTransferVolumeSnapshotsValidationError is the validation error
// returned by WalletTransferVolumeSnapshots.Validate if the designated
// constraints aren't met.
type WalletTransferVolumeSnapshotsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletTransferVolumeSnapshotsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletTransferVolumeSnapshotsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletTransferVolumeSnapshotsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletTransferVolumeSnapshotsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletTransferVolumeSnapshotsValidationError) ErrorName() string {
	return "WalletTransferVolumeSnapshotsValidationError"
}

// Error satisfies the builtin error interface
func (e WalletTransferVolumeSnapshotsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletTransferVolumeSnapshots.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletTransferVolumeSnapshotsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletTransferVolumeSnapshotsValidationError{}

// Validate checks the field values on ListWalletTransferVolumeSnapshots with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListWalletTransferVolumeSnapshots) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListWalletTransferVolumeSnapshots
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListWalletTransferVolumeSnapshotsMultiError, or nil if none found.
func (m *ListWalletTransferVolumeSnapshots) ValidateAll() error {
	return m.validate(true)
}

func (m *ListWalletTransferVolumeSnapshots) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetWalletTransferVolumeSnapshots() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListWalletTransferVolumeSnapshotsValidationError{
						field:  fmt.Sprintf("WalletTransferVolumeSnapshots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListWalletTransferVolumeSnapshotsValidationError{
						field:  fmt.Sprintf("WalletTransferVolumeSnapshots[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListWalletTransferVolumeSnapshotsValidationError{
					field:  fmt.Sprintf("WalletTransferVolumeSnapshots[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListWalletTransferVolumeSnapshotsMultiError(errors)
	}

	return nil
}

// ListWalletTransferVolumeSnapshotsMultiError is an error wrapping multiple
// validation errors returned by
// ListWalletTransferVolumeSnapshots.ValidateAll() if the designated
// constraints aren't met.
type ListWalletTransferVolumeSnapshotsMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListWalletTransferVolumeSnapshotsMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListWalletTransferVolumeSnapshotsMultiError) AllErrors() []error { return m }

// ListWalletTransferVolumeSnapshotsValidationError is the validation error
// returned by ListWalletTransferVolumeSnapshots.Validate if the designated
// constraints aren't met.
type ListWalletTransferVolumeSnapshotsValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListWalletTransferVolumeSnapshotsValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListWalletTransferVolumeSnapshotsValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListWalletTransferVolumeSnapshotsValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListWalletTransferVolumeSnapshotsValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListWalletTransferVolumeSnapshotsValidationError) ErrorName() string {
	return "ListWalletTransferVolumeSnapshotsValidationError"
}

// Error satisfies the builtin error interface
func (e ListWalletTransferVolumeSnapshotsValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListWalletTransferVolumeSnapshots.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListWalletTransferVolumeSnapshotsValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListWalletTransferVolumeSnapshotsValidationError{}

// Validate checks the field values on WalletTransferVolumeSnapshot with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WalletTransferVolumeSnapshot) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalletTransferVolumeSnapshot with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WalletTransferVolumeSnapshotMultiError, or nil if none found.
func (m *WalletTransferVolumeSnapshot) ValidateAll() error {
	return m.validate(true)
}

func (m *WalletTransferVolumeSnapshot) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if all {
		switch v := interface{}(m.GetTargetTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalletTransferVolumeSnapshotValidationError{
					field:  "TargetTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalletTransferVolumeSnapshotValidationError{
					field:  "TargetTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetTargetTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalletTransferVolumeSnapshotValidationError{
				field:  "TargetTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	{
		sorted_keys := make([]int32, len(m.GetWalletTransferVolumeByTransferType()))
		i := 0
		for key := range m.GetWalletTransferVolumeByTransferType() {
			sorted_keys[i] = key
			i++
		}
		sort.Slice(sorted_keys, func(i, j int) bool { return sorted_keys[i] < sorted_keys[j] })
		for _, key := range sorted_keys {
			val := m.GetWalletTransferVolumeByTransferType()[key]
			_ = val

			// no validation rules for WalletTransferVolumeByTransferType[key]

			if all {
				switch v := interface{}(val).(type) {
				case interface{ ValidateAll() error }:
					if err := v.ValidateAll(); err != nil {
						errors = append(errors, WalletTransferVolumeSnapshotValidationError{
							field:  fmt.Sprintf("WalletTransferVolumeByTransferType[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				case interface{ Validate() error }:
					if err := v.Validate(); err != nil {
						errors = append(errors, WalletTransferVolumeSnapshotValidationError{
							field:  fmt.Sprintf("WalletTransferVolumeByTransferType[%v]", key),
							reason: "embedded message failed validation",
							cause:  err,
						})
					}
				}
			} else if v, ok := interface{}(val).(interface{ Validate() error }); ok {
				if err := v.Validate(); err != nil {
					return WalletTransferVolumeSnapshotValidationError{
						field:  fmt.Sprintf("WalletTransferVolumeByTransferType[%v]", key),
						reason: "embedded message failed validation",
						cause:  err,
					}
				}
			}

		}
	}

	if len(errors) > 0 {
		return WalletTransferVolumeSnapshotMultiError(errors)
	}

	return nil
}

// WalletTransferVolumeSnapshotMultiError is an error wrapping multiple
// validation errors returned by WalletTransferVolumeSnapshot.ValidateAll() if
// the designated constraints aren't met.
type WalletTransferVolumeSnapshotMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletTransferVolumeSnapshotMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletTransferVolumeSnapshotMultiError) AllErrors() []error { return m }

// WalletTransferVolumeSnapshotValidationError is the validation error returned
// by WalletTransferVolumeSnapshot.Validate if the designated constraints
// aren't met.
type WalletTransferVolumeSnapshotValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletTransferVolumeSnapshotValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletTransferVolumeSnapshotValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletTransferVolumeSnapshotValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletTransferVolumeSnapshotValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletTransferVolumeSnapshotValidationError) ErrorName() string {
	return "WalletTransferVolumeSnapshotValidationError"
}

// Error satisfies the builtin error interface
func (e WalletTransferVolumeSnapshotValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletTransferVolumeSnapshot.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletTransferVolumeSnapshotValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletTransferVolumeSnapshotValidationError{}

// Validate checks the field values on WalletTransferVolume with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WalletTransferVolume) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalletTransferVolume with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WalletTransferVolumeMultiError, or nil if none found.
func (m *WalletTransferVolume) ValidateAll() error {
	return m.validate(true)
}

func (m *WalletTransferVolume) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StringVolume

	// no validation rules for StringJpyVolume

	// no validation rules for Number

	// no validation rules for TransferType

	if len(errors) > 0 {
		return WalletTransferVolumeMultiError(errors)
	}

	return nil
}

// WalletTransferVolumeMultiError is an error wrapping multiple validation
// errors returned by WalletTransferVolume.ValidateAll() if the designated
// constraints aren't met.
type WalletTransferVolumeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletTransferVolumeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletTransferVolumeMultiError) AllErrors() []error { return m }

// WalletTransferVolumeValidationError is the validation error returned by
// WalletTransferVolume.Validate if the designated constraints aren't met.
type WalletTransferVolumeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletTransferVolumeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletTransferVolumeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletTransferVolumeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletTransferVolumeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletTransferVolumeValidationError) ErrorName() string {
	return "WalletTransferVolumeValidationError"
}

// Error satisfies the builtin error interface
func (e WalletTransferVolumeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletTransferVolume.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletTransferVolumeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletTransferVolumeValidationError{}

// Validate checks the field values on Confirmation with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *Confirmation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on Confirmation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in ConfirmationMultiError, or
// nil if none found.
func (m *Confirmation) ValidateAll() error {
	return m.validate(true)
}

func (m *Confirmation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Coin

	// no validation rules for Confirmation

	if len(errors) > 0 {
		return ConfirmationMultiError(errors)
	}

	return nil
}

// ConfirmationMultiError is an error wrapping multiple validation errors
// returned by Confirmation.ValidateAll() if the designated constraints aren't met.
type ConfirmationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ConfirmationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ConfirmationMultiError) AllErrors() []error { return m }

// ConfirmationValidationError is the validation error returned by
// Confirmation.Validate if the designated constraints aren't met.
type ConfirmationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ConfirmationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ConfirmationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ConfirmationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ConfirmationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ConfirmationValidationError) ErrorName() string { return "ConfirmationValidationError" }

// Error satisfies the builtin error interface
func (e ConfirmationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sConfirmation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ConfirmationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ConfirmationValidationError{}

// Validate checks the field values on WalletFlushSetting with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *WalletFlushSetting) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalletFlushSetting with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// WalletFlushSettingMultiError, or nil if none found.
func (m *WalletFlushSetting) ValidateAll() error {
	return m.validate(true)
}

func (m *WalletFlushSetting) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for OwnerId

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for DestinationWalletId

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalletFlushSettingValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalletFlushSettingValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalletFlushSettingValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalletFlushSettingValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalletFlushSettingValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalletFlushSettingValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for FlushThreshold

	if len(errors) > 0 {
		return WalletFlushSettingMultiError(errors)
	}

	return nil
}

// WalletFlushSettingMultiError is an error wrapping multiple validation errors
// returned by WalletFlushSetting.ValidateAll() if the designated constraints
// aren't met.
type WalletFlushSettingMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletFlushSettingMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletFlushSettingMultiError) AllErrors() []error { return m }

// WalletFlushSettingValidationError is the validation error returned by
// WalletFlushSetting.Validate if the designated constraints aren't met.
type WalletFlushSettingValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletFlushSettingValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletFlushSettingValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletFlushSettingValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletFlushSettingValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletFlushSettingValidationError) ErrorName() string {
	return "WalletFlushSettingValidationError"
}

// Error satisfies the builtin error interface
func (e WalletFlushSettingValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletFlushSetting.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletFlushSettingValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletFlushSettingValidationError{}

// Validate checks the field values on CompensationFee with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CompensationFee) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CompensationFee with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CompensationFeeMultiError, or nil if none found.
func (m *CompensationFee) ValidateAll() error {
	return m.validate(true)
}

func (m *CompensationFee) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StringValue

	// no validation rules for IsSpent

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, CompensationFeeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, CompensationFeeValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return CompensationFeeValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return CompensationFeeMultiError(errors)
	}

	return nil
}

// CompensationFeeMultiError is an error wrapping multiple validation errors
// returned by CompensationFee.ValidateAll() if the designated constraints
// aren't met.
type CompensationFeeMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CompensationFeeMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CompensationFeeMultiError) AllErrors() []error { return m }

// CompensationFeeValidationError is the validation error returned by
// CompensationFee.Validate if the designated constraints aren't met.
type CompensationFeeValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CompensationFeeValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CompensationFeeValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CompensationFeeValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CompensationFeeValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CompensationFeeValidationError) ErrorName() string { return "CompensationFeeValidationError" }

// Error satisfies the builtin error interface
func (e CompensationFeeValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCompensationFee.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CompensationFeeValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CompensationFeeValidationError{}

// Validate checks the field values on WalletGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *WalletGroup) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on WalletGroup with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in WalletGroupMultiError, or
// nil if none found.
func (m *WalletGroup) ValidateAll() error {
	return m.validate(true)
}

func (m *WalletGroup) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletGroupId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Network

	for idx, item := range m.GetWallets() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, WalletGroupValidationError{
						field:  fmt.Sprintf("Wallets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, WalletGroupValidationError{
						field:  fmt.Sprintf("Wallets[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return WalletGroupValidationError{
					field:  fmt.Sprintf("Wallets[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	// no validation rules for WatchOnly

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalletGroupValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalletGroupValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalletGroupValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, WalletGroupValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, WalletGroupValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return WalletGroupValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return WalletGroupMultiError(errors)
	}

	return nil
}

// WalletGroupMultiError is an error wrapping multiple validation errors
// returned by WalletGroup.ValidateAll() if the designated constraints aren't met.
type WalletGroupMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m WalletGroupMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m WalletGroupMultiError) AllErrors() []error { return m }

// WalletGroupValidationError is the validation error returned by
// WalletGroup.Validate if the designated constraints aren't met.
type WalletGroupValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e WalletGroupValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e WalletGroupValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e WalletGroupValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e WalletGroupValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e WalletGroupValidationError) ErrorName() string { return "WalletGroupValidationError" }

// Error satisfies the builtin error interface
func (e WalletGroupValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sWalletGroup.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = WalletGroupValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = WalletGroupValidationError{}

// Validate checks the field values on RequestTxOutput with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RequestTxOutput) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestTxOutput with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestTxOutputMultiError, or nil if none found.
func (m *RequestTxOutput) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestTxOutput) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if utf8.RuneCountInString(m.GetAddress()) < 3 {
		err := RequestTxOutputValidationError{
			field:  "Address",
			reason: "value length must be at least 3 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if utf8.RuneCountInString(m.GetStringValue()) < 1 {
		err := RequestTxOutputValidationError{
			field:  "StringValue",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RequestTxOutputMultiError(errors)
	}

	return nil
}

// RequestTxOutputMultiError is an error wrapping multiple validation errors
// returned by RequestTxOutput.ValidateAll() if the designated constraints
// aren't met.
type RequestTxOutputMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestTxOutputMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestTxOutputMultiError) AllErrors() []error { return m }

// RequestTxOutputValidationError is the validation error returned by
// RequestTxOutput.Validate if the designated constraints aren't met.
type RequestTxOutputValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestTxOutputValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestTxOutputValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestTxOutputValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestTxOutputValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestTxOutputValidationError) ErrorName() string { return "RequestTxOutputValidationError" }

// Error satisfies the builtin error interface
func (e RequestTxOutputValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestTxOutput.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestTxOutputValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestTxOutputValidationError{}

// Validate checks the field values on RequestSignedInfo with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RequestSignedInfo) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestSignedInfo with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestSignedInfoMultiError, or nil if none found.
func (m *RequestSignedInfo) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestSignedInfo) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(m.GetSignatures()) < 1 {
		err := RequestSignedInfoValidationError{
			field:  "Signatures",
			reason: "value must contain at least 1 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetSignatures() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, RequestSignedInfoValidationError{
						field:  fmt.Sprintf("Signatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, RequestSignedInfoValidationError{
						field:  fmt.Sprintf("Signatures[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return RequestSignedInfoValidationError{
					field:  fmt.Sprintf("Signatures[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return RequestSignedInfoMultiError(errors)
	}

	return nil
}

// RequestSignedInfoMultiError is an error wrapping multiple validation errors
// returned by RequestSignedInfo.ValidateAll() if the designated constraints
// aren't met.
type RequestSignedInfoMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestSignedInfoMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestSignedInfoMultiError) AllErrors() []error { return m }

// RequestSignedInfoValidationError is the validation error returned by
// RequestSignedInfo.Validate if the designated constraints aren't met.
type RequestSignedInfoValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestSignedInfoValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestSignedInfoValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestSignedInfoValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestSignedInfoValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestSignedInfoValidationError) ErrorName() string {
	return "RequestSignedInfoValidationError"
}

// Error satisfies the builtin error interface
func (e RequestSignedInfoValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestSignedInfo.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestSignedInfoValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestSignedInfoValidationError{}

// Validate checks the field values on RequestSignature with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *RequestSignature) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestSignature with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestSignatureMultiError, or nil if none found.
func (m *RequestSignature) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestSignature) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for SignIndex

	if utf8.RuneCountInString(m.GetSignature()) < 1 {
		err := RequestSignatureValidationError{
			field:  "Signature",
			reason: "value length must be at least 1 runes",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for HdIndex

	if len(errors) > 0 {
		return RequestSignatureMultiError(errors)
	}

	return nil
}

// RequestSignatureMultiError is an error wrapping multiple validation errors
// returned by RequestSignature.ValidateAll() if the designated constraints
// aren't met.
type RequestSignatureMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestSignatureMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestSignatureMultiError) AllErrors() []error { return m }

// RequestSignatureValidationError is the validation error returned by
// RequestSignature.Validate if the designated constraints aren't met.
type RequestSignatureValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestSignatureValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestSignatureValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestSignatureValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestSignatureValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestSignatureValidationError) ErrorName() string { return "RequestSignatureValidationError" }

// Error satisfies the builtin error interface
func (e RequestSignatureValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestSignature.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestSignatureValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestSignatureValidationError{}

// Validate checks the field values on RequestTransferLimitEntry with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *RequestTransferLimitEntry) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestTransferLimitEntry with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// RequestTransferLimitEntryMultiError, or nil if none found.
func (m *RequestTransferLimitEntry) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestTransferLimitEntry) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _RequestTransferLimitEntry_TransferLimitType_NotInLookup[m.GetTransferLimitType()]; ok {
		err := RequestTransferLimitEntryValidationError{
			field:  "TransferLimitType",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := TransferLimitType_name[int32(m.GetTransferLimitType())]; !ok {
		err := RequestTransferLimitEntryValidationError{
			field:  "TransferLimitType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTransferLimitValue() < 0 {
		err := RequestTransferLimitEntryValidationError{
			field:  "TransferLimitValue",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RequestTransferLimitEntryMultiError(errors)
	}

	return nil
}

// RequestTransferLimitEntryMultiError is an error wrapping multiple validation
// errors returned by RequestTransferLimitEntry.ValidateAll() if the
// designated constraints aren't met.
type RequestTransferLimitEntryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestTransferLimitEntryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestTransferLimitEntryMultiError) AllErrors() []error { return m }

// RequestTransferLimitEntryValidationError is the validation error returned by
// RequestTransferLimitEntry.Validate if the designated constraints aren't met.
type RequestTransferLimitEntryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestTransferLimitEntryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestTransferLimitEntryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestTransferLimitEntryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestTransferLimitEntryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestTransferLimitEntryValidationError) ErrorName() string {
	return "RequestTransferLimitEntryValidationError"
}

// Error satisfies the builtin error interface
func (e RequestTransferLimitEntryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestTransferLimitEntry.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestTransferLimitEntryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestTransferLimitEntryValidationError{}

var _RequestTransferLimitEntry_TransferLimitType_NotInLookup = map[TransferLimitType]struct{}{
	0: {},
}

// Validate checks the field values on RequestRate with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *RequestRate) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on RequestRate with the rules defined in
// the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in RequestRateMultiError, or
// nil if none found.
func (m *RequestRate) ValidateAll() error {
	return m.validate(true)
}

func (m *RequestRate) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if _, ok := _RequestRate_Coin_NotInLookup[m.GetCoin()]; ok {
		err := RequestRateValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := RequestRateValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetJpy() < 0 {
		err := RequestRateValidationError{
			field:  "Jpy",
			reason: "value must be greater than or equal to 0",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return RequestRateMultiError(errors)
	}

	return nil
}

// RequestRateMultiError is an error wrapping multiple validation errors
// returned by RequestRate.ValidateAll() if the designated constraints aren't met.
type RequestRateMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m RequestRateMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m RequestRateMultiError) AllErrors() []error { return m }

// RequestRateValidationError is the validation error returned by
// RequestRate.Validate if the designated constraints aren't met.
type RequestRateValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e RequestRateValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e RequestRateValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e RequestRateValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e RequestRateValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e RequestRateValidationError) ErrorName() string { return "RequestRateValidationError" }

// Error satisfies the builtin error interface
func (e RequestRateValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sRequestRate.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = RequestRateValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = RequestRateValidationError{}

var _RequestRate_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

// Validate checks the field values on SubstrateChildAddress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SubstrateChildAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SubstrateChildAddress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SubstrateChildAddressMultiError, or nil if none found.
func (m *SubstrateChildAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *SubstrateChildAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for AccountId

	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	if len(errors) > 0 {
		return SubstrateChildAddressMultiError(errors)
	}

	return nil
}

// SubstrateChildAddressMultiError is an error wrapping multiple validation
// errors returned by SubstrateChildAddress.ValidateAll() if the designated
// constraints aren't met.
type SubstrateChildAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SubstrateChildAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SubstrateChildAddressMultiError) AllErrors() []error { return m }

// SubstrateChildAddressValidationError is the validation error returned by
// SubstrateChildAddress.Validate if the designated constraints aren't met.
type SubstrateChildAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SubstrateChildAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SubstrateChildAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SubstrateChildAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SubstrateChildAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SubstrateChildAddressValidationError) ErrorName() string {
	return "SubstrateChildAddressValidationError"
}

// Error satisfies the builtin error interface
func (e SubstrateChildAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSubstrateChildAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SubstrateChildAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SubstrateChildAddressValidationError{}

// Validate checks the field values on SymbolChildAddress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SymbolChildAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SymbolChildAddress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SymbolChildAddressMultiError, or nil if none found.
func (m *SymbolChildAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *SymbolChildAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for AccountId

	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	if len(errors) > 0 {
		return SymbolChildAddressMultiError(errors)
	}

	return nil
}

// SymbolChildAddressMultiError is an error wrapping multiple validation errors
// returned by SymbolChildAddress.ValidateAll() if the designated constraints
// aren't met.
type SymbolChildAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SymbolChildAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SymbolChildAddressMultiError) AllErrors() []error { return m }

// SymbolChildAddressValidationError is the validation error returned by
// SymbolChildAddress.Validate if the designated constraints aren't met.
type SymbolChildAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SymbolChildAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SymbolChildAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SymbolChildAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SymbolChildAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SymbolChildAddressValidationError) ErrorName() string {
	return "SymbolChildAddressValidationError"
}

// Error satisfies the builtin error interface
func (e SymbolChildAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSymbolChildAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SymbolChildAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SymbolChildAddressValidationError{}

// Validate checks the field values on IOSTChildAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IOSTChildAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IOSTChildAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IOSTChildAccountMultiError, or nil if none found.
func (m *IOSTChildAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *IOSTChildAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for WalletId

	// no validation rules for AccountId

	// no validation rules for AccountName

	if len(errors) > 0 {
		return IOSTChildAccountMultiError(errors)
	}

	return nil
}

// IOSTChildAccountMultiError is an error wrapping multiple validation errors
// returned by IOSTChildAccount.ValidateAll() if the designated constraints
// aren't met.
type IOSTChildAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IOSTChildAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IOSTChildAccountMultiError) AllErrors() []error { return m }

// IOSTChildAccountValidationError is the validation error returned by
// IOSTChildAccount.Validate if the designated constraints aren't met.
type IOSTChildAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IOSTChildAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IOSTChildAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IOSTChildAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IOSTChildAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IOSTChildAccountValidationError) ErrorName() string { return "IOSTChildAccountValidationError" }

// Error satisfies the builtin error interface
func (e IOSTChildAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIOSTChildAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IOSTChildAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IOSTChildAccountValidationError{}

// Validate checks the field values on IOSTCallerAccount with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *IOSTCallerAccount) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on IOSTCallerAccount with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// IOSTCallerAccountMultiError, or nil if none found.
func (m *IOSTCallerAccount) ValidateAll() error {
	return m.validate(true)
}

func (m *IOSTCallerAccount) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for AccountName

	// no validation rules for Balance

	// no validation rules for StringBalance

	if len(errors) > 0 {
		return IOSTCallerAccountMultiError(errors)
	}

	return nil
}

// IOSTCallerAccountMultiError is an error wrapping multiple validation errors
// returned by IOSTCallerAccount.ValidateAll() if the designated constraints
// aren't met.
type IOSTCallerAccountMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m IOSTCallerAccountMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m IOSTCallerAccountMultiError) AllErrors() []error { return m }

// IOSTCallerAccountValidationError is the validation error returned by
// IOSTCallerAccount.Validate if the designated constraints aren't met.
type IOSTCallerAccountValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e IOSTCallerAccountValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e IOSTCallerAccountValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e IOSTCallerAccountValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e IOSTCallerAccountValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e IOSTCallerAccountValidationError) ErrorName() string {
	return "IOSTCallerAccountValidationError"
}

// Error satisfies the builtin error interface
func (e IOSTCallerAccountValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sIOSTCallerAccount.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = IOSTCallerAccountValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = IOSTCallerAccountValidationError{}

// Validate checks the field values on CallerAddress with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *CallerAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CallerAddress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in CallerAddressMultiError, or
// nil if none found.
func (m *CallerAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *CallerAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for Coin

	// no validation rules for Network

	if len(errors) > 0 {
		return CallerAddressMultiError(errors)
	}

	return nil
}

// CallerAddressMultiError is an error wrapping multiple validation errors
// returned by CallerAddress.ValidateAll() if the designated constraints
// aren't met.
type CallerAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CallerAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CallerAddressMultiError) AllErrors() []error { return m }

// CallerAddressValidationError is the validation error returned by
// CallerAddress.Validate if the designated constraints aren't met.
type CallerAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CallerAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CallerAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CallerAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CallerAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CallerAddressValidationError) ErrorName() string { return "CallerAddressValidationError" }

// Error satisfies the builtin error interface
func (e CallerAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCallerAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CallerAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CallerAddressValidationError{}

// Validate checks the field values on FeeDepositAddress with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *FeeDepositAddress) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on FeeDepositAddress with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// FeeDepositAddressMultiError, or nil if none found.
func (m *FeeDepositAddress) ValidateAll() error {
	return m.validate(true)
}

func (m *FeeDepositAddress) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for Coin

	// no validation rules for Network

	if len(errors) > 0 {
		return FeeDepositAddressMultiError(errors)
	}

	return nil
}

// FeeDepositAddressMultiError is an error wrapping multiple validation errors
// returned by FeeDepositAddress.ValidateAll() if the designated constraints
// aren't met.
type FeeDepositAddressMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m FeeDepositAddressMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m FeeDepositAddressMultiError) AllErrors() []error { return m }

// FeeDepositAddressValidationError is the validation error returned by
// FeeDepositAddress.Validate if the designated constraints aren't met.
type FeeDepositAddressValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e FeeDepositAddressValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e FeeDepositAddressValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e FeeDepositAddressValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e FeeDepositAddressValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e FeeDepositAddressValidationError) ErrorName() string {
	return "FeeDepositAddressValidationError"
}

// Error satisfies the builtin error interface
func (e FeeDepositAddressValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sFeeDepositAddress.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = FeeDepositAddressValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = FeeDepositAddressValidationError{}

// Validate checks the field values on CosmosDelegation with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *CosmosDelegation) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CosmosDelegation with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CosmosDelegationMultiError, or nil if none found.
func (m *CosmosDelegation) ValidateAll() error {
	return m.validate(true)
}

func (m *CosmosDelegation) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for ValidatorAddress

	// no validation rules for DelegateAmount

	// no validation rules for RewardAmount

	if len(errors) > 0 {
		return CosmosDelegationMultiError(errors)
	}

	return nil
}

// CosmosDelegationMultiError is an error wrapping multiple validation errors
// returned by CosmosDelegation.ValidateAll() if the designated constraints
// aren't met.
type CosmosDelegationMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CosmosDelegationMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CosmosDelegationMultiError) AllErrors() []error { return m }

// CosmosDelegationValidationError is the validation error returned by
// CosmosDelegation.Validate if the designated constraints aren't met.
type CosmosDelegationValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CosmosDelegationValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CosmosDelegationValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CosmosDelegationValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CosmosDelegationValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CosmosDelegationValidationError) ErrorName() string { return "CosmosDelegationValidationError" }

// Error satisfies the builtin error interface
func (e CosmosDelegationValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCosmosDelegation.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CosmosDelegationValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CosmosDelegationValidationError{}

// Validate checks the field values on StakingHistory with the rules defined in
// the proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *StakingHistory) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StakingHistory with the rules defined
// in the proto definition for this message. If any rules are violated, the
// result is a list of violation errors wrapped in StakingHistoryMultiError,
// or nil if none found.
func (m *StakingHistory) ValidateAll() error {
	return m.validate(true)
}

func (m *StakingHistory) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StakingHistoryId

	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Coin

	// no validation rules for ValidatorId

	// no validation rules for TxId

	// no validation rules for TxIndex

	// no validation rules for BlockHash

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for EventType

	// no validation rules for EventId

	if all {
		switch v := interface{}(m.GetEthereumSpecific()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StakingHistoryValidationError{
					field:  "EthereumSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StakingHistoryValidationError{
					field:  "EthereumSpecific",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetEthereumSpecific()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StakingHistoryValidationError{
				field:  "EthereumSpecific",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StakingHistoryValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StakingHistoryValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StakingHistoryValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StakingHistoryValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StakingHistoryValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StakingHistoryValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StakingHistoryMultiError(errors)
	}

	return nil
}

// StakingHistoryMultiError is an error wrapping multiple validation errors
// returned by StakingHistory.ValidateAll() if the designated constraints
// aren't met.
type StakingHistoryMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StakingHistoryMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StakingHistoryMultiError) AllErrors() []error { return m }

// StakingHistoryValidationError is the validation error returned by
// StakingHistory.Validate if the designated constraints aren't met.
type StakingHistoryValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StakingHistoryValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StakingHistoryValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StakingHistoryValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StakingHistoryValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StakingHistoryValidationError) ErrorName() string { return "StakingHistoryValidationError" }

// Error satisfies the builtin error interface
func (e StakingHistoryValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStakingHistory.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StakingHistoryValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StakingHistoryValidationError{}

// Validate checks the field values on StakingHistoryEthereumSpecific with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *StakingHistoryEthereumSpecific) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StakingHistoryEthereumSpecific with
// the rules defined in the proto definition for this message. If any rules
// are violated, the result is a list of violation errors wrapped in
// StakingHistoryEthereumSpecificMultiError, or nil if none found.
func (m *StakingHistoryEthereumSpecific) ValidateAll() error {
	return m.validate(true)
}

func (m *StakingHistoryEthereumSpecific) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for EventId

	// no validation rules for Address

	// no validation rules for WithdrawalIndex

	// no validation rules for ValidatorIndex

	// no validation rules for BlockNumber

	if all {
		switch v := interface{}(m.GetBlockTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StakingHistoryEthereumSpecificValidationError{
					field:  "BlockTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StakingHistoryEthereumSpecificValidationError{
					field:  "BlockTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetBlockTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StakingHistoryEthereumSpecificValidationError{
				field:  "BlockTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	// no validation rules for HistoryType

	if len(errors) > 0 {
		return StakingHistoryEthereumSpecificMultiError(errors)
	}

	return nil
}

// StakingHistoryEthereumSpecificMultiError is an error wrapping multiple
// validation errors returned by StakingHistoryEthereumSpecific.ValidateAll()
// if the designated constraints aren't met.
type StakingHistoryEthereumSpecificMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StakingHistoryEthereumSpecificMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StakingHistoryEthereumSpecificMultiError) AllErrors() []error { return m }

// StakingHistoryEthereumSpecificValidationError is the validation error
// returned by StakingHistoryEthereumSpecific.Validate if the designated
// constraints aren't met.
type StakingHistoryEthereumSpecificValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StakingHistoryEthereumSpecificValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StakingHistoryEthereumSpecificValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StakingHistoryEthereumSpecificValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StakingHistoryEthereumSpecificValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StakingHistoryEthereumSpecificValidationError) ErrorName() string {
	return "StakingHistoryEthereumSpecificValidationError"
}

// Error satisfies the builtin error interface
func (e StakingHistoryEthereumSpecificValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStakingHistoryEthereumSpecific.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StakingHistoryEthereumSpecificValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StakingHistoryEthereumSpecificValidationError{}

// Validate checks the field values on StakingValidator with the rules defined
// in the proto definition for this message. If any rules are violated, the
// first error encountered is returned, or nil if there are no violations.
func (m *StakingValidator) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on StakingValidator with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// StakingValidatorMultiError, or nil if none found.
func (m *StakingValidator) ValidateAll() error {
	return m.validate(true)
}

func (m *StakingValidator) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for StakingValidatorId

	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Coin

	// no validation rules for ValidatorId

	// no validation rules for RecipientWalletId

	// no validation rules for Status

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for ExpirationTime

	if all {
		switch v := interface{}(m.GetCreateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StakingValidatorValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StakingValidatorValidationError{
					field:  "CreateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetCreateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StakingValidatorValidationError{
				field:  "CreateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if all {
		switch v := interface{}(m.GetUpdateTime()).(type) {
		case interface{ ValidateAll() error }:
			if err := v.ValidateAll(); err != nil {
				errors = append(errors, StakingValidatorValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		case interface{ Validate() error }:
			if err := v.Validate(); err != nil {
				errors = append(errors, StakingValidatorValidationError{
					field:  "UpdateTime",
					reason: "embedded message failed validation",
					cause:  err,
				})
			}
		}
	} else if v, ok := interface{}(m.GetUpdateTime()).(interface{ Validate() error }); ok {
		if err := v.Validate(); err != nil {
			return StakingValidatorValidationError{
				field:  "UpdateTime",
				reason: "embedded message failed validation",
				cause:  err,
			}
		}
	}

	if len(errors) > 0 {
		return StakingValidatorMultiError(errors)
	}

	return nil
}

// StakingValidatorMultiError is an error wrapping multiple validation errors
// returned by StakingValidator.ValidateAll() if the designated constraints
// aren't met.
type StakingValidatorMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m StakingValidatorMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m StakingValidatorMultiError) AllErrors() []error { return m }

// StakingValidatorValidationError is the validation error returned by
// StakingValidator.Validate if the designated constraints aren't met.
type StakingValidatorValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e StakingValidatorValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e StakingValidatorValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e StakingValidatorValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e StakingValidatorValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e StakingValidatorValidationError) ErrorName() string { return "StakingValidatorValidationError" }

// Error satisfies the builtin error interface
func (e StakingValidatorValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sStakingValidator.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = StakingValidatorValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = StakingValidatorValidationError{}
