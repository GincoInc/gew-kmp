// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: gincoinc/adamant/teller/v1/adamanttellerv1/teller_api.proto

package adamanttellerv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"sort"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	adamantglobalv1 "github.com/GincoInc/gew-kmp/gen/gincoinc/adamant/global/v1/adamantglobalv1"

	gincoincglobalv1 "github.com/GincoInc/gew-kmp/gen/gincoinc/global/v1/gincoincglobalv1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}
	_ = sort.Sort

	_ = adamantglobalv1.WalletType(0)

	_ = gincoincglobalv1.AddressType(0)
)

// Validate checks the field values on CreateWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *CreateWalletRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on CreateWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// CreateWalletRequestMultiError, or nil if none found.
func (m *CreateWalletRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *CreateWalletRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetWalletName()); l < 1 || l > 40 {
		err := CreateWalletRequestValidationError{
			field:  "WalletName",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateWalletRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := CreateWalletRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := CreateWalletRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateWalletRequest_WalletType_NotInLookup[m.GetWalletType()]; ok {
		err := CreateWalletRequestValidationError{
			field:  "WalletType",
			reason: "value must not be in list [0 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := adamantglobalv1.WalletType_name[int32(m.GetWalletType())]; !ok {
		err := CreateWalletRequestValidationError{
			field:  "WalletType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateWalletRequest_AddressType_NotInLookup[m.GetAddressType()]; ok {
		err := CreateWalletRequestValidationError{
			field:  "AddressType",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.AddressType_name[int32(m.GetAddressType())]; !ok {
		err := CreateWalletRequestValidationError{
			field:  "AddressType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateWalletRequest_DestinationWalletId_Pattern.MatchString(m.GetDestinationWalletId()) {
		err := CreateWalletRequestValidationError{
			field:  "DestinationWalletId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateWalletRequest_InheritWalletId_Pattern.MatchString(m.GetInheritWalletId()) {
		err := CreateWalletRequestValidationError{
			field:  "InheritWalletId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.Network != nil {

		if _, ok := gincoincglobalv1.Network_name[int32(m.GetNetwork())]; !ok {
			err := CreateWalletRequestValidationError{
				field:  "Network",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateWalletRequestMultiError(errors)
	}

	return nil
}

// CreateWalletRequestMultiError is an error wrapping multiple validation
// errors returned by CreateWalletRequest.ValidateAll() if the designated
// constraints aren't met.
type CreateWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWalletRequestMultiError) AllErrors() []error { return m }

// CreateWalletRequestValidationError is the validation error returned by
// CreateWalletRequest.Validate if the designated constraints aren't met.
type CreateWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWalletRequestValidationError) ErrorName() string {
	return "CreateWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWalletRequestValidationError{}

var _CreateWalletRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

var _CreateWalletRequest_WalletType_NotInLookup = map[adamantglobalv1.WalletType]struct{}{
	0: {},
	2: {},
}

var _CreateWalletRequest_AddressType_NotInLookup = map[gincoincglobalv1.AddressType]struct{}{
	0: {},
}

var _CreateWalletRequest_DestinationWalletId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _CreateWalletRequest_InheritWalletId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on InitializeXRPWalletRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitializeXRPWalletRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitializeXRPWalletRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitializeXRPWalletRequestMultiError, or nil if none found.
func (m *InitializeXRPWalletRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitializeXRPWalletRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_InitializeXRPWalletRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := InitializeXRPWalletRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return InitializeXRPWalletRequestMultiError(errors)
	}

	return nil
}

// InitializeXRPWalletRequestMultiError is an error wrapping multiple
// validation errors returned by InitializeXRPWalletRequest.ValidateAll() if
// the designated constraints aren't met.
type InitializeXRPWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitializeXRPWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitializeXRPWalletRequestMultiError) AllErrors() []error { return m }

// InitializeXRPWalletRequestValidationError is the validation error returned
// by InitializeXRPWalletRequest.Validate if the designated constraints aren't met.
type InitializeXRPWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitializeXRPWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitializeXRPWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitializeXRPWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitializeXRPWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitializeXRPWalletRequestValidationError) ErrorName() string {
	return "InitializeXRPWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitializeXRPWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitializeXRPWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitializeXRPWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitializeXRPWalletRequestValidationError{}

var _InitializeXRPWalletRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on InitializeWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *InitializeWalletRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on InitializeWalletRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// InitializeWalletRequestMultiError, or nil if none found.
func (m *InitializeWalletRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *InitializeWalletRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_InitializeWalletRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := InitializeWalletRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return InitializeWalletRequestMultiError(errors)
	}

	return nil
}

// InitializeWalletRequestMultiError is an error wrapping multiple validation
// errors returned by InitializeWalletRequest.ValidateAll() if the designated
// constraints aren't met.
type InitializeWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitializeWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitializeWalletRequestMultiError) AllErrors() []error { return m }

// InitializeWalletRequestValidationError is the validation error returned by
// InitializeWalletRequest.Validate if the designated constraints aren't met.
type InitializeWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitializeWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitializeWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitializeWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitializeWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitializeWalletRequestValidationError) ErrorName() string {
	return "InitializeWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitializeWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitializeWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitializeWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitializeWalletRequestValidationError{}

var _InitializeWalletRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on SignTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignTransactionRequestMultiError, or nil if none found.
func (m *SignTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SignTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SignTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := SignTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SignTransactionRequest_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := SignTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SignTransactionRequestMultiError(errors)
	}

	return nil
}

// SignTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by SignTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type SignTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignTransactionRequestMultiError) AllErrors() []error { return m }

// SignTransactionRequestValidationError is the validation error returned by
// SignTransactionRequest.Validate if the designated constraints aren't met.
type SignTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignTransactionRequestValidationError) ErrorName() string {
	return "SignTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SignTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignTransactionRequestValidationError{}

var _SignTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _SignTransactionRequest_TransactionId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on SignMessageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignMessageRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignMessageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignMessageRequestMultiError, or nil if none found.
func (m *SignMessageRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SignMessageRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SignMessageRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := SignMessageRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Message

	if m.AddressId != nil {

		if !_SignMessageRequest_AddressId_Pattern.MatchString(m.GetAddressId()) {
			err := SignMessageRequestValidationError{
				field:  "AddressId",
				reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if m.Address != nil {
		// no validation rules for Address
	}

	if len(errors) > 0 {
		return SignMessageRequestMultiError(errors)
	}

	return nil
}

// SignMessageRequestMultiError is an error wrapping multiple validation errors
// returned by SignMessageRequest.ValidateAll() if the designated constraints
// aren't met.
type SignMessageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignMessageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignMessageRequestMultiError) AllErrors() []error { return m }

// SignMessageRequestValidationError is the validation error returned by
// SignMessageRequest.Validate if the designated constraints aren't met.
type SignMessageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignMessageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignMessageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignMessageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignMessageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignMessageRequestValidationError) ErrorName() string {
	return "SignMessageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SignMessageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignMessageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignMessageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignMessageRequestValidationError{}

var _SignMessageRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _SignMessageRequest_AddressId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on SignMessageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SignMessageResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SignMessageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SignMessageResponseMultiError, or nil if none found.
func (m *SignMessageResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *SignMessageResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Signature

	if len(errors) > 0 {
		return SignMessageResponseMultiError(errors)
	}

	return nil
}

// SignMessageResponseMultiError is an error wrapping multiple validation
// errors returned by SignMessageResponse.ValidateAll() if the designated
// constraints aren't met.
type SignMessageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignMessageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignMessageResponseMultiError) AllErrors() []error { return m }

// SignMessageResponseValidationError is the validation error returned by
// SignMessageResponse.Validate if the designated constraints aren't met.
type SignMessageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignMessageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignMessageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignMessageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignMessageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignMessageResponseValidationError) ErrorName() string {
	return "SignMessageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SignMessageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignMessageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignMessageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignMessageResponseValidationError{}

// Validate checks the field values on SendTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *SendTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on SendTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// SendTransactionRequestMultiError, or nil if none found.
func (m *SendTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *SendTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SendTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := SendTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SendTransactionRequest_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := SendTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SendTransactionRequestMultiError(errors)
	}

	return nil
}

// SendTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by SendTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type SendTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendTransactionRequestMultiError) AllErrors() []error { return m }

// SendTransactionRequestValidationError is the validation error returned by
// SendTransactionRequest.Validate if the designated constraints aren't met.
type SendTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendTransactionRequestValidationError) ErrorName() string {
	return "SendTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SendTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendTransactionRequestValidationError{}

var _SendTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _SendTransactionRequest_TransactionId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ResendTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ResendTransactionRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ResendTransactionRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ResendTransactionRequestMultiError, or nil if none found.
func (m *ResendTransactionRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ResendTransactionRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ResendTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ResendTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ResendTransactionRequest_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := ResendTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ResendTransactionRequestMultiError(errors)
	}

	return nil
}

// ResendTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by ResendTransactionRequest.ValidateAll() if the designated
// constraints aren't met.
type ResendTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResendTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResendTransactionRequestMultiError) AllErrors() []error { return m }

// ResendTransactionRequestValidationError is the validation error returned by
// ResendTransactionRequest.Validate if the designated constraints aren't met.
type ResendTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResendTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResendTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResendTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResendTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResendTransactionRequestValidationError) ErrorName() string {
	return "ResendTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ResendTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResendTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResendTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResendTransactionRequestValidationError{}

var _ResendTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ResendTransactionRequest_TransactionId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ProgmatCoinInitializeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProgmatCoinInitializeRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgmatCoinInitializeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProgmatCoinInitializeRequestMultiError, or nil if none found.
func (m *ProgmatCoinInitializeRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinInitializeRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinInitializeRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinInitializeRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTokenName()); l < 1 || l > 40 {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "TokenName",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTokenSymbol()); l < 1 || l > 10 {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "TokenSymbol",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTokenCurrency()); l < 1 || l > 3 {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "TokenCurrency",
			reason: "value length must be between 1 and 3 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTokenDecimals() >= 100 {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "TokenDecimals",
			reason: "value must be less than 100",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinInitializeRequest_NewMasterMinter_Pattern.MatchString(m.GetNewMasterMinter()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "NewMasterMinter",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinInitializeRequest_NewPauser_Pattern.MatchString(m.GetNewPauser()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "NewPauser",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinInitializeRequest_NewWhiteAndBlackLister_Pattern.MatchString(m.GetNewWhiteAndBlackLister()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "NewWhiteAndBlackLister",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinInitializeRequest_NewConfiscator_Pattern.MatchString(m.GetNewConfiscator()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "NewConfiscator",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinInitializeRequest_NewOwner_Pattern.MatchString(m.GetNewOwner()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "NewOwner",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ProgmatCoinInitializeRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinInitializeRequestMultiError is an error wrapping multiple
// validation errors returned by ProgmatCoinInitializeRequest.ValidateAll() if
// the designated constraints aren't met.
type ProgmatCoinInitializeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinInitializeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinInitializeRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinInitializeRequestValidationError is the validation error returned
// by ProgmatCoinInitializeRequest.Validate if the designated constraints
// aren't met.
type ProgmatCoinInitializeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinInitializeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinInitializeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinInitializeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinInitializeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinInitializeRequestValidationError) ErrorName() string {
	return "ProgmatCoinInitializeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinInitializeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinInitializeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinInitializeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinInitializeRequestValidationError{}

var _ProgmatCoinInitializeRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinInitializeRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinInitializeRequest_NewMasterMinter_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinInitializeRequest_NewPauser_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinInitializeRequest_NewWhiteAndBlackLister_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinInitializeRequest_NewConfiscator_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinInitializeRequest_NewOwner_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinConfigureMinterRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ProgmatCoinConfigureMinterRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgmatCoinConfigureMinterRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ProgmatCoinConfigureMinterRequestMultiError, or nil if none found.
func (m *ProgmatCoinConfigureMinterRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinConfigureMinterRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinConfigureMinterRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinConfigureMinterRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinConfigureMinterRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinConfigureMinterRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinConfigureMinterRequest_Address_Pattern.MatchString(m.GetAddress()) {
		err := ProgmatCoinConfigureMinterRequestValidationError{
			field:  "Address",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for MinterAllowedAmount

	if len(errors) > 0 {
		return ProgmatCoinConfigureMinterRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinConfigureMinterRequestMultiError is an error wrapping multiple
// validation errors returned by
// ProgmatCoinConfigureMinterRequest.ValidateAll() if the designated
// constraints aren't met.
type ProgmatCoinConfigureMinterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinConfigureMinterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinConfigureMinterRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinConfigureMinterRequestValidationError is the validation error
// returned by ProgmatCoinConfigureMinterRequest.Validate if the designated
// constraints aren't met.
type ProgmatCoinConfigureMinterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinConfigureMinterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinConfigureMinterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinConfigureMinterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinConfigureMinterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinConfigureMinterRequestValidationError) ErrorName() string {
	return "ProgmatCoinConfigureMinterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinConfigureMinterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinConfigureMinterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinConfigureMinterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinConfigureMinterRequestValidationError{}

var _ProgmatCoinConfigureMinterRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinConfigureMinterRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinConfigureMinterRequest_Address_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinMintAndTransferRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ProgmatCoinMintAndTransferRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgmatCoinMintAndTransferRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ProgmatCoinMintAndTransferRequestMultiError, or nil if none found.
func (m *ProgmatCoinMintAndTransferRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinMintAndTransferRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinMintAndTransferRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinMintAndTransferRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinMintAndTransferRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinMintAndTransferRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinMintAndTransferRequest_MintAddress_Pattern.MatchString(m.GetMintAddress()) {
		err := ProgmatCoinMintAndTransferRequestValidationError{
			field:  "MintAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinMintAndTransferRequest_TransferAddress_Pattern.MatchString(m.GetTransferAddress()) {
		err := ProgmatCoinMintAndTransferRequestValidationError{
			field:  "TransferAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Amount

	if m.ThroughAddress != nil {

		if !_ProgmatCoinMintAndTransferRequest_ThroughAddress_Pattern.MatchString(m.GetThroughAddress()) {
			err := ProgmatCoinMintAndTransferRequestValidationError{
				field:  "ThroughAddress",
				reason: "value does not match regex pattern \"^$|^(0x)?[0-9a-fA-F]{40}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ProgmatCoinMintAndTransferRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinMintAndTransferRequestMultiError is an error wrapping multiple
// validation errors returned by
// ProgmatCoinMintAndTransferRequest.ValidateAll() if the designated
// constraints aren't met.
type ProgmatCoinMintAndTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinMintAndTransferRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinMintAndTransferRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinMintAndTransferRequestValidationError is the validation error
// returned by ProgmatCoinMintAndTransferRequest.Validate if the designated
// constraints aren't met.
type ProgmatCoinMintAndTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinMintAndTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinMintAndTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinMintAndTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinMintAndTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinMintAndTransferRequestValidationError) ErrorName() string {
	return "ProgmatCoinMintAndTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinMintAndTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinMintAndTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinMintAndTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinMintAndTransferRequestValidationError{}

var _ProgmatCoinMintAndTransferRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinMintAndTransferRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinMintAndTransferRequest_MintAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinMintAndTransferRequest_TransferAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinMintAndTransferRequest_ThroughAddress_Pattern = regexp.MustCompile("^$|^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinMintRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProgmatCoinMintRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgmatCoinMintRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProgmatCoinMintRequestMultiError, or nil if none found.
func (m *ProgmatCoinMintRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinMintRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinMintRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinMintRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinMintRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinMintRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinMintRequest_Address_Pattern.MatchString(m.GetAddress()) {
		err := ProgmatCoinMintRequestValidationError{
			field:  "Address",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Amount

	if len(errors) > 0 {
		return ProgmatCoinMintRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinMintRequestMultiError is an error wrapping multiple validation
// errors returned by ProgmatCoinMintRequest.ValidateAll() if the designated
// constraints aren't met.
type ProgmatCoinMintRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinMintRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinMintRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinMintRequestValidationError is the validation error returned by
// ProgmatCoinMintRequest.Validate if the designated constraints aren't met.
type ProgmatCoinMintRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinMintRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinMintRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinMintRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinMintRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinMintRequestValidationError) ErrorName() string {
	return "ProgmatCoinMintRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinMintRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinMintRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinMintRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinMintRequestValidationError{}

var _ProgmatCoinMintRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinMintRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinMintRequest_Address_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinBurnRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProgmatCoinBurnRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgmatCoinBurnRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProgmatCoinBurnRequestMultiError, or nil if none found.
func (m *ProgmatCoinBurnRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinBurnRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinBurnRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinBurnRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinBurnRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinBurnRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Amount

	if len(errors) > 0 {
		return ProgmatCoinBurnRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinBurnRequestMultiError is an error wrapping multiple validation
// errors returned by ProgmatCoinBurnRequest.ValidateAll() if the designated
// constraints aren't met.
type ProgmatCoinBurnRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinBurnRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinBurnRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinBurnRequestValidationError is the validation error returned by
// ProgmatCoinBurnRequest.Validate if the designated constraints aren't met.
type ProgmatCoinBurnRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinBurnRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinBurnRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinBurnRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinBurnRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinBurnRequestValidationError) ErrorName() string {
	return "ProgmatCoinBurnRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinBurnRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinBurnRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinBurnRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinBurnRequestValidationError{}

var _ProgmatCoinBurnRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinBurnRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinBulkAddToWhitelistRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ProgmatCoinBulkAddToWhitelistRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgmatCoinBulkAddToWhitelistRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ProgmatCoinBulkAddToWhitelistRequestMultiError, or nil if none found.
func (m *ProgmatCoinBulkAddToWhitelistRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinBulkAddToWhitelistRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinBulkAddToWhitelistRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinBulkAddToWhitelistRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinBulkAddToWhitelistRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinBulkAddToWhitelistRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinBulkAddToWhitelistRequest_UtilsAddress_Pattern.MatchString(m.GetUtilsAddress()) {
		err := ProgmatCoinBulkAddToWhitelistRequestValidationError{
			field:  "UtilsAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetAddresses()) > 100 {
		err := ProgmatCoinBulkAddToWhitelistRequestValidationError{
			field:  "Addresses",
			reason: "value must contain no more than 100 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if !_ProgmatCoinBulkAddToWhitelistRequest_Addresses_Pattern.MatchString(item) {
			err := ProgmatCoinBulkAddToWhitelistRequestValidationError{
				field:  fmt.Sprintf("Addresses[%v]", idx),
				reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ProgmatCoinBulkAddToWhitelistRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinBulkAddToWhitelistRequestMultiError is an error wrapping multiple
// validation errors returned by
// ProgmatCoinBulkAddToWhitelistRequest.ValidateAll() if the designated
// constraints aren't met.
type ProgmatCoinBulkAddToWhitelistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinBulkAddToWhitelistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinBulkAddToWhitelistRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinBulkAddToWhitelistRequestValidationError is the validation error
// returned by ProgmatCoinBulkAddToWhitelistRequest.Validate if the designated
// constraints aren't met.
type ProgmatCoinBulkAddToWhitelistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinBulkAddToWhitelistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinBulkAddToWhitelistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinBulkAddToWhitelistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinBulkAddToWhitelistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinBulkAddToWhitelistRequestValidationError) ErrorName() string {
	return "ProgmatCoinBulkAddToWhitelistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinBulkAddToWhitelistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinBulkAddToWhitelistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinBulkAddToWhitelistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinBulkAddToWhitelistRequestValidationError{}

var _ProgmatCoinBulkAddToWhitelistRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinBulkAddToWhitelistRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinBulkAddToWhitelistRequest_UtilsAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinBulkAddToWhitelistRequest_Addresses_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on
// ProgmatCoinBulkRemoveFromWhitelistRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProgmatCoinBulkRemoveFromWhitelistRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ProgmatCoinBulkRemoveFromWhitelistRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ProgmatCoinBulkRemoveFromWhitelistRequestMultiError, or nil if none found.
func (m *ProgmatCoinBulkRemoveFromWhitelistRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinBulkRemoveFromWhitelistRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinBulkRemoveFromWhitelistRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinBulkRemoveFromWhitelistRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinBulkRemoveFromWhitelistRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinBulkRemoveFromWhitelistRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinBulkRemoveFromWhitelistRequest_UtilsAddress_Pattern.MatchString(m.GetUtilsAddress()) {
		err := ProgmatCoinBulkRemoveFromWhitelistRequestValidationError{
			field:  "UtilsAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetAddresses()) > 100 {
		err := ProgmatCoinBulkRemoveFromWhitelistRequestValidationError{
			field:  "Addresses",
			reason: "value must contain no more than 100 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if !_ProgmatCoinBulkRemoveFromWhitelistRequest_Addresses_Pattern.MatchString(item) {
			err := ProgmatCoinBulkRemoveFromWhitelistRequestValidationError{
				field:  fmt.Sprintf("Addresses[%v]", idx),
				reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ProgmatCoinBulkRemoveFromWhitelistRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinBulkRemoveFromWhitelistRequestMultiError is an error wrapping
// multiple validation errors returned by
// ProgmatCoinBulkRemoveFromWhitelistRequest.ValidateAll() if the designated
// constraints aren't met.
type ProgmatCoinBulkRemoveFromWhitelistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinBulkRemoveFromWhitelistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinBulkRemoveFromWhitelistRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinBulkRemoveFromWhitelistRequestValidationError is the validation
// error returned by ProgmatCoinBulkRemoveFromWhitelistRequest.Validate if the
// designated constraints aren't met.
type ProgmatCoinBulkRemoveFromWhitelistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinBulkRemoveFromWhitelistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinBulkRemoveFromWhitelistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinBulkRemoveFromWhitelistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinBulkRemoveFromWhitelistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinBulkRemoveFromWhitelistRequestValidationError) ErrorName() string {
	return "ProgmatCoinBulkRemoveFromWhitelistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinBulkRemoveFromWhitelistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinBulkRemoveFromWhitelistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinBulkRemoveFromWhitelistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinBulkRemoveFromWhitelistRequestValidationError{}

var _ProgmatCoinBulkRemoveFromWhitelistRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinBulkRemoveFromWhitelistRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinBulkRemoveFromWhitelistRequest_UtilsAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinBulkRemoveFromWhitelistRequest_Addresses_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinBulkAddToBlacklistRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the first error encountered is returned, or nil if
// there are no violations.
func (m *ProgmatCoinBulkAddToBlacklistRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgmatCoinBulkAddToBlacklistRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ProgmatCoinBulkAddToBlacklistRequestMultiError, or nil if none found.
func (m *ProgmatCoinBulkAddToBlacklistRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinBulkAddToBlacklistRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinBulkAddToBlacklistRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinBulkAddToBlacklistRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinBulkAddToBlacklistRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinBulkAddToBlacklistRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinBulkAddToBlacklistRequest_UtilsAddress_Pattern.MatchString(m.GetUtilsAddress()) {
		err := ProgmatCoinBulkAddToBlacklistRequestValidationError{
			field:  "UtilsAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetAddresses()) > 100 {
		err := ProgmatCoinBulkAddToBlacklistRequestValidationError{
			field:  "Addresses",
			reason: "value must contain no more than 100 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if !_ProgmatCoinBulkAddToBlacklistRequest_Addresses_Pattern.MatchString(item) {
			err := ProgmatCoinBulkAddToBlacklistRequestValidationError{
				field:  fmt.Sprintf("Addresses[%v]", idx),
				reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ProgmatCoinBulkAddToBlacklistRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinBulkAddToBlacklistRequestMultiError is an error wrapping multiple
// validation errors returned by
// ProgmatCoinBulkAddToBlacklistRequest.ValidateAll() if the designated
// constraints aren't met.
type ProgmatCoinBulkAddToBlacklistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinBulkAddToBlacklistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinBulkAddToBlacklistRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinBulkAddToBlacklistRequestValidationError is the validation error
// returned by ProgmatCoinBulkAddToBlacklistRequest.Validate if the designated
// constraints aren't met.
type ProgmatCoinBulkAddToBlacklistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinBulkAddToBlacklistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinBulkAddToBlacklistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinBulkAddToBlacklistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinBulkAddToBlacklistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinBulkAddToBlacklistRequestValidationError) ErrorName() string {
	return "ProgmatCoinBulkAddToBlacklistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinBulkAddToBlacklistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinBulkAddToBlacklistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinBulkAddToBlacklistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinBulkAddToBlacklistRequestValidationError{}

var _ProgmatCoinBulkAddToBlacklistRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinBulkAddToBlacklistRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinBulkAddToBlacklistRequest_UtilsAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinBulkAddToBlacklistRequest_Addresses_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on
// ProgmatCoinBulkRemoveFromBlacklistRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProgmatCoinBulkRemoveFromBlacklistRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ProgmatCoinBulkRemoveFromBlacklistRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ProgmatCoinBulkRemoveFromBlacklistRequestMultiError, or nil if none found.
func (m *ProgmatCoinBulkRemoveFromBlacklistRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinBulkRemoveFromBlacklistRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinBulkRemoveFromBlacklistRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinBulkRemoveFromBlacklistRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinBulkRemoveFromBlacklistRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinBulkRemoveFromBlacklistRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinBulkRemoveFromBlacklistRequest_UtilsAddress_Pattern.MatchString(m.GetUtilsAddress()) {
		err := ProgmatCoinBulkRemoveFromBlacklistRequestValidationError{
			field:  "UtilsAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(m.GetAddresses()) > 100 {
		err := ProgmatCoinBulkRemoveFromBlacklistRequestValidationError{
			field:  "Addresses",
			reason: "value must contain no more than 100 item(s)",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	for idx, item := range m.GetAddresses() {
		_, _ = idx, item

		if !_ProgmatCoinBulkRemoveFromBlacklistRequest_Addresses_Pattern.MatchString(item) {
			err := ProgmatCoinBulkRemoveFromBlacklistRequestValidationError{
				field:  fmt.Sprintf("Addresses[%v]", idx),
				reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return ProgmatCoinBulkRemoveFromBlacklistRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinBulkRemoveFromBlacklistRequestMultiError is an error wrapping
// multiple validation errors returned by
// ProgmatCoinBulkRemoveFromBlacklistRequest.ValidateAll() if the designated
// constraints aren't met.
type ProgmatCoinBulkRemoveFromBlacklistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinBulkRemoveFromBlacklistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinBulkRemoveFromBlacklistRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinBulkRemoveFromBlacklistRequestValidationError is the validation
// error returned by ProgmatCoinBulkRemoveFromBlacklistRequest.Validate if the
// designated constraints aren't met.
type ProgmatCoinBulkRemoveFromBlacklistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinBulkRemoveFromBlacklistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinBulkRemoveFromBlacklistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinBulkRemoveFromBlacklistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinBulkRemoveFromBlacklistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinBulkRemoveFromBlacklistRequestValidationError) ErrorName() string {
	return "ProgmatCoinBulkRemoveFromBlacklistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinBulkRemoveFromBlacklistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinBulkRemoveFromBlacklistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinBulkRemoveFromBlacklistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinBulkRemoveFromBlacklistRequestValidationError{}

var _ProgmatCoinBulkRemoveFromBlacklistRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinBulkRemoveFromBlacklistRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinBulkRemoveFromBlacklistRequest_UtilsAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinBulkRemoveFromBlacklistRequest_Addresses_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinConfiscateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProgmatCoinConfiscateRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgmatCoinConfiscateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProgmatCoinConfiscateRequestMultiError, or nil if none found.
func (m *ProgmatCoinConfiscateRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinConfiscateRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinConfiscateRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinConfiscateRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinConfiscateRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinConfiscateRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinConfiscateRequest_BlackListedAccount_Pattern.MatchString(m.GetBlackListedAccount()) {
		err := ProgmatCoinConfiscateRequestValidationError{
			field:  "BlackListedAccount",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinConfiscateRequest_ToAccount_Pattern.MatchString(m.GetToAccount()) {
		err := ProgmatCoinConfiscateRequestValidationError{
			field:  "ToAccount",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Amount

	if len(errors) > 0 {
		return ProgmatCoinConfiscateRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinConfiscateRequestMultiError is an error wrapping multiple
// validation errors returned by ProgmatCoinConfiscateRequest.ValidateAll() if
// the designated constraints aren't met.
type ProgmatCoinConfiscateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinConfiscateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinConfiscateRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinConfiscateRequestValidationError is the validation error returned
// by ProgmatCoinConfiscateRequest.Validate if the designated constraints
// aren't met.
type ProgmatCoinConfiscateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinConfiscateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinConfiscateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinConfiscateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinConfiscateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinConfiscateRequestValidationError) ErrorName() string {
	return "ProgmatCoinConfiscateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinConfiscateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinConfiscateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinConfiscateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinConfiscateRequestValidationError{}

var _ProgmatCoinConfiscateRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinConfiscateRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinConfiscateRequest_BlackListedAccount_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinConfiscateRequest_ToAccount_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinPauseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProgmatCoinPauseRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgmatCoinPauseRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProgmatCoinPauseRequestMultiError, or nil if none found.
func (m *ProgmatCoinPauseRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinPauseRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinPauseRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinPauseRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinPauseRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinPauseRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ProgmatCoinPauseRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinPauseRequestMultiError is an error wrapping multiple validation
// errors returned by ProgmatCoinPauseRequest.ValidateAll() if the designated
// constraints aren't met.
type ProgmatCoinPauseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinPauseRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinPauseRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinPauseRequestValidationError is the validation error returned by
// ProgmatCoinPauseRequest.Validate if the designated constraints aren't met.
type ProgmatCoinPauseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinPauseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinPauseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinPauseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinPauseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinPauseRequestValidationError) ErrorName() string {
	return "ProgmatCoinPauseRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinPauseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinPauseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinPauseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinPauseRequestValidationError{}

var _ProgmatCoinPauseRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinPauseRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinUnpauseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, the first error encountered is returned, or nil if there are no violations.
func (m *ProgmatCoinUnpauseRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgmatCoinUnpauseRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, the result is a list of violation errors wrapped in
// ProgmatCoinUnpauseRequestMultiError, or nil if none found.
func (m *ProgmatCoinUnpauseRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinUnpauseRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinUnpauseRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinUnpauseRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinUnpauseRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinUnpauseRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ProgmatCoinUnpauseRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinUnpauseRequestMultiError is an error wrapping multiple validation
// errors returned by ProgmatCoinUnpauseRequest.ValidateAll() if the
// designated constraints aren't met.
type ProgmatCoinUnpauseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinUnpauseRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinUnpauseRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinUnpauseRequestValidationError is the validation error returned by
// ProgmatCoinUnpauseRequest.Validate if the designated constraints aren't met.
type ProgmatCoinUnpauseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinUnpauseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinUnpauseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinUnpauseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinUnpauseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinUnpauseRequestValidationError) ErrorName() string {
	return "ProgmatCoinUnpauseRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinUnpauseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinUnpauseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinUnpauseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinUnpauseRequestValidationError{}

var _ProgmatCoinUnpauseRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinUnpauseRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on
// ProgmatCoinGrantWhiteAndBlackListerRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the first
// error encountered is returned, or nil if there are no violations.
func (m *ProgmatCoinGrantWhiteAndBlackListerRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on
// ProgmatCoinGrantWhiteAndBlackListerRequest with the rules defined in the
// proto definition for this message. If any rules are violated, the result is
// a list of violation errors wrapped in
// ProgmatCoinGrantWhiteAndBlackListerRequestMultiError, or nil if none found.
func (m *ProgmatCoinGrantWhiteAndBlackListerRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinGrantWhiteAndBlackListerRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinGrantWhiteAndBlackListerRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinGrantWhiteAndBlackListerRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinGrantWhiteAndBlackListerRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinGrantWhiteAndBlackListerRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinGrantWhiteAndBlackListerRequest_UtilsAddress_Pattern.MatchString(m.GetUtilsAddress()) {
		err := ProgmatCoinGrantWhiteAndBlackListerRequestValidationError{
			field:  "UtilsAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ProgmatCoinGrantWhiteAndBlackListerRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinGrantWhiteAndBlackListerRequestMultiError is an error wrapping
// multiple validation errors returned by
// ProgmatCoinGrantWhiteAndBlackListerRequest.ValidateAll() if the designated
// constraints aren't met.
type ProgmatCoinGrantWhiteAndBlackListerRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinGrantWhiteAndBlackListerRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinGrantWhiteAndBlackListerRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinGrantWhiteAndBlackListerRequestValidationError is the validation
// error returned by ProgmatCoinGrantWhiteAndBlackListerRequest.Validate if
// the designated constraints aren't met.
type ProgmatCoinGrantWhiteAndBlackListerRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinGrantWhiteAndBlackListerRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinGrantWhiteAndBlackListerRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinGrantWhiteAndBlackListerRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinGrantWhiteAndBlackListerRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinGrantWhiteAndBlackListerRequestValidationError) ErrorName() string {
	return "ProgmatCoinGrantWhiteAndBlackListerRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinGrantWhiteAndBlackListerRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinGrantWhiteAndBlackListerRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinGrantWhiteAndBlackListerRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinGrantWhiteAndBlackListerRequestValidationError{}

var _ProgmatCoinGrantWhiteAndBlackListerRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinGrantWhiteAndBlackListerRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinGrantWhiteAndBlackListerRequest_UtilsAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinUpgradeToAndCallRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ProgmatCoinUpgradeToAndCallRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ProgmatCoinUpgradeToAndCallRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ProgmatCoinUpgradeToAndCallRequestMultiError, or nil if none found.
func (m *ProgmatCoinUpgradeToAndCallRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ProgmatCoinUpgradeToAndCallRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinUpgradeToAndCallRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinUpgradeToAndCallRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinUpgradeToAndCallRequest_ProxyContractAddress_Pattern.MatchString(m.GetProxyContractAddress()) {
		err := ProgmatCoinUpgradeToAndCallRequestValidationError{
			field:  "ProxyContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinUpgradeToAndCallRequest_ImplContractAddress_Pattern.MatchString(m.GetImplContractAddress()) {
		err := ProgmatCoinUpgradeToAndCallRequestValidationError{
			field:  "ImplContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ProgmatCoinUpgradeToAndCallRequestMultiError(errors)
	}

	return nil
}

// ProgmatCoinUpgradeToAndCallRequestMultiError is an error wrapping multiple
// validation errors returned by
// ProgmatCoinUpgradeToAndCallRequest.ValidateAll() if the designated
// constraints aren't met.
type ProgmatCoinUpgradeToAndCallRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinUpgradeToAndCallRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinUpgradeToAndCallRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinUpgradeToAndCallRequestValidationError is the validation error
// returned by ProgmatCoinUpgradeToAndCallRequest.Validate if the designated
// constraints aren't met.
type ProgmatCoinUpgradeToAndCallRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinUpgradeToAndCallRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinUpgradeToAndCallRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinUpgradeToAndCallRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinUpgradeToAndCallRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinUpgradeToAndCallRequestValidationError) ErrorName() string {
	return "ProgmatCoinUpgradeToAndCallRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinUpgradeToAndCallRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinUpgradeToAndCallRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinUpgradeToAndCallRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinUpgradeToAndCallRequestValidationError{}

var _ProgmatCoinUpgradeToAndCallRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinUpgradeToAndCallRequest_ProxyContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinUpgradeToAndCallRequest_ImplContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ListColdFeeDepositAddressesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListColdFeeDepositAddressesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListColdFeeDepositAddressesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListColdFeeDepositAddressesRequestMultiError, or nil if none found.
func (m *ListColdFeeDepositAddressesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListColdFeeDepositAddressesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListColdFeeDepositAddressesRequestMultiError(errors)
	}

	return nil
}

// ListColdFeeDepositAddressesRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListColdFeeDepositAddressesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListColdFeeDepositAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListColdFeeDepositAddressesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListColdFeeDepositAddressesRequestMultiError) AllErrors() []error { return m }

// ListColdFeeDepositAddressesRequestValidationError is the validation error
// returned by ListColdFeeDepositAddressesRequest.Validate if the designated
// constraints aren't met.
type ListColdFeeDepositAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListColdFeeDepositAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListColdFeeDepositAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListColdFeeDepositAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListColdFeeDepositAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListColdFeeDepositAddressesRequestValidationError) ErrorName() string {
	return "ListColdFeeDepositAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListColdFeeDepositAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListColdFeeDepositAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListColdFeeDepositAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListColdFeeDepositAddressesRequestValidationError{}

// Validate checks the field values on ListColdFeeDepositAddressesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListColdFeeDepositAddressesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListColdFeeDepositAddressesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListColdFeeDepositAddressesResponseMultiError, or nil if none found.
func (m *ListColdFeeDepositAddressesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListColdFeeDepositAddressesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCallerAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListColdFeeDepositAddressesResponseValidationError{
						field:  fmt.Sprintf("CallerAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListColdFeeDepositAddressesResponseValidationError{
						field:  fmt.Sprintf("CallerAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListColdFeeDepositAddressesResponseValidationError{
					field:  fmt.Sprintf("CallerAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListColdFeeDepositAddressesResponseMultiError(errors)
	}

	return nil
}

// ListColdFeeDepositAddressesResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListColdFeeDepositAddressesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListColdFeeDepositAddressesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListColdFeeDepositAddressesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListColdFeeDepositAddressesResponseMultiError) AllErrors() []error { return m }

// ListColdFeeDepositAddressesResponseValidationError is the validation error
// returned by ListColdFeeDepositAddressesResponse.Validate if the designated
// constraints aren't met.
type ListColdFeeDepositAddressesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListColdFeeDepositAddressesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListColdFeeDepositAddressesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListColdFeeDepositAddressesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListColdFeeDepositAddressesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListColdFeeDepositAddressesResponseValidationError) ErrorName() string {
	return "ListColdFeeDepositAddressesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListColdFeeDepositAddressesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListColdFeeDepositAddressesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListColdFeeDepositAddressesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListColdFeeDepositAddressesResponseValidationError{}

// Validate checks the field values on ListHotFeeDepositAddressesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListHotFeeDepositAddressesRequest) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListHotFeeDepositAddressesRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListHotFeeDepositAddressesRequestMultiError, or nil if none found.
func (m *ListHotFeeDepositAddressesRequest) ValidateAll() error {
	return m.validate(true)
}

func (m *ListHotFeeDepositAddressesRequest) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListHotFeeDepositAddressesRequestMultiError(errors)
	}

	return nil
}

// ListHotFeeDepositAddressesRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListHotFeeDepositAddressesRequest.ValidateAll() if the designated
// constraints aren't met.
type ListHotFeeDepositAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListHotFeeDepositAddressesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListHotFeeDepositAddressesRequestMultiError) AllErrors() []error { return m }

// ListHotFeeDepositAddressesRequestValidationError is the validation error
// returned by ListHotFeeDepositAddressesRequest.Validate if the designated
// constraints aren't met.
type ListHotFeeDepositAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListHotFeeDepositAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListHotFeeDepositAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListHotFeeDepositAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListHotFeeDepositAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListHotFeeDepositAddressesRequestValidationError) ErrorName() string {
	return "ListHotFeeDepositAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListHotFeeDepositAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListHotFeeDepositAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListHotFeeDepositAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListHotFeeDepositAddressesRequestValidationError{}

// Validate checks the field values on ListHotFeeDepositAddressesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, the first error encountered is returned, or nil if there are
// no violations.
func (m *ListHotFeeDepositAddressesResponse) Validate() error {
	return m.validate(false)
}

// ValidateAll checks the field values on ListHotFeeDepositAddressesResponse
// with the rules defined in the proto definition for this message. If any
// rules are violated, the result is a list of violation errors wrapped in
// ListHotFeeDepositAddressesResponseMultiError, or nil if none found.
func (m *ListHotFeeDepositAddressesResponse) ValidateAll() error {
	return m.validate(true)
}

func (m *ListHotFeeDepositAddressesResponse) validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFeeDepositAddresses() {
		_, _ = idx, item

		if all {
			switch v := interface{}(item).(type) {
			case interface{ ValidateAll() error }:
				if err := v.ValidateAll(); err != nil {
					errors = append(errors, ListHotFeeDepositAddressesResponseValidationError{
						field:  fmt.Sprintf("FeeDepositAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			case interface{ Validate() error }:
				if err := v.Validate(); err != nil {
					errors = append(errors, ListHotFeeDepositAddressesResponseValidationError{
						field:  fmt.Sprintf("FeeDepositAddresses[%v]", idx),
						reason: "embedded message failed validation",
						cause:  err,
					})
				}
			}
		} else if v, ok := interface{}(item).(interface{ Validate() error }); ok {
			if err := v.Validate(); err != nil {
				return ListHotFeeDepositAddressesResponseValidationError{
					field:  fmt.Sprintf("FeeDepositAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
			}
		}

	}

	if len(errors) > 0 {
		return ListHotFeeDepositAddressesResponseMultiError(errors)
	}

	return nil
}

// ListHotFeeDepositAddressesResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListHotFeeDepositAddressesResponse.ValidateAll() if the designated
// constraints aren't met.
type ListHotFeeDepositAddressesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListHotFeeDepositAddressesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListHotFeeDepositAddressesResponseMultiError) AllErrors() []error { return m }

// ListHotFeeDepositAddressesResponseValidationError is the validation error
// returned by ListHotFeeDepositAddressesResponse.Validate if the designated
// constraints aren't met.
type ListHotFeeDepositAddressesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListHotFeeDepositAddressesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListHotFeeDepositAddressesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListHotFeeDepositAddressesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListHotFeeDepositAddressesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListHotFeeDepositAddressesResponseValidationError) ErrorName() string {
	return "ListHotFeeDepositAddressesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListHotFeeDepositAddressesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListHotFeeDepositAddressesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListHotFeeDepositAddressesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListHotFeeDepositAddressesResponseValidationError{}
