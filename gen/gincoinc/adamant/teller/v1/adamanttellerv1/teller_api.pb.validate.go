// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: gincoinc/adamant/teller/v1/adamanttellerv1/teller_api.proto

package adamanttellerv1

import (
	"bytes"
	"errors"
	"fmt"
	"net"
	"net/mail"
	"net/url"
	"regexp"
	"strings"
	"time"
	"unicode/utf8"

	"google.golang.org/protobuf/types/known/anypb"

	adamantglobalv1 "github.com/GincoInc/gew-kmp/gen/gincoinc/adamant/global/v1/adamantglobalv1"

	gincoincglobalv1 "github.com/GincoInc/gew-kmp/gen/gincoinc/global/v1/gincoincglobalv1"
)

// ensure the imports are used
var (
	_ = bytes.MinRead
	_ = errors.New("")
	_ = fmt.Print
	_ = utf8.UTFMax
	_ = (*regexp.Regexp)(nil)
	_ = (*strings.Reader)(nil)
	_ = net.IPv4len
	_ = time.Duration(0)
	_ = (*url.URL)(nil)
	_ = (*mail.Address)(nil)
	_ = anypb.Any{}

	_ = gincoincglobalv1.Coin(0)

	_ = gincoincglobalv1.Network(0)

	_ = adamantglobalv1.WalletType(0)

	_ = gincoincglobalv1.AddressType(0)
)

// Validate checks the field values on CreateWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in CreateWalletRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *CreateWalletRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if l := utf8.RuneCountInString(m.GetWalletName()); l < 1 || l > 40 {
		err := CreateWalletRequestValidationError{
			field:  "WalletName",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateWalletRequest_Coin_NotInLookup[m.GetCoin()]; ok {
		err := CreateWalletRequestValidationError{
			field:  "Coin",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.Coin_name[int32(m.GetCoin())]; !ok {
		err := CreateWalletRequestValidationError{
			field:  "Coin",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateWalletRequest_WalletType_NotInLookup[m.GetWalletType()]; ok {
		err := CreateWalletRequestValidationError{
			field:  "WalletType",
			reason: "value must not be in list [0 2]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := adamantglobalv1.WalletType_name[int32(m.GetWalletType())]; !ok {
		err := CreateWalletRequestValidationError{
			field:  "WalletType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := _CreateWalletRequest_AddressType_NotInLookup[m.GetAddressType()]; ok {
		err := CreateWalletRequestValidationError{
			field:  "AddressType",
			reason: "value must not be in list [0]",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if _, ok := gincoincglobalv1.AddressType_name[int32(m.GetAddressType())]; !ok {
		err := CreateWalletRequestValidationError{
			field:  "AddressType",
			reason: "value must be one of the defined enum values",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateWalletRequest_DestinationWalletId_Pattern.MatchString(m.GetDestinationWalletId()) {
		err := CreateWalletRequestValidationError{
			field:  "DestinationWalletId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_CreateWalletRequest_InheritWalletId_Pattern.MatchString(m.GetInheritWalletId()) {
		err := CreateWalletRequestValidationError{
			field:  "InheritWalletId",
			reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	switch m.XNetwork.(type) {

	case *CreateWalletRequest_Network:

		if _, ok := gincoincglobalv1.Network_name[int32(m.GetNetwork())]; !ok {
			err := CreateWalletRequestValidationError{
				field:  "Network",
				reason: "value must be one of the defined enum values",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	if len(errors) > 0 {
		return CreateWalletRequestMultiError(errors)
	}
	return nil
}

// CreateWalletRequestMultiError is an error wrapping multiple validation
// errors returned by CreateWalletRequest.Validate(true) if the designated
// constraints aren't met.
type CreateWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m CreateWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m CreateWalletRequestMultiError) AllErrors() []error { return m }

// CreateWalletRequestValidationError is the validation error returned by
// CreateWalletRequest.Validate if the designated constraints aren't met.
type CreateWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e CreateWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e CreateWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e CreateWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e CreateWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e CreateWalletRequestValidationError) ErrorName() string {
	return "CreateWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e CreateWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sCreateWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = CreateWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = CreateWalletRequestValidationError{}

var _CreateWalletRequest_Coin_NotInLookup = map[gincoincglobalv1.Coin]struct{}{
	0: {},
}

var _CreateWalletRequest_WalletType_NotInLookup = map[adamantglobalv1.WalletType]struct{}{
	0: {},
	2: {},
}

var _CreateWalletRequest_AddressType_NotInLookup = map[gincoincglobalv1.AddressType]struct{}{
	0: {},
}

var _CreateWalletRequest_DestinationWalletId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _CreateWalletRequest_InheritWalletId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on InitializeXRPWalletRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in InitializeXRPWalletRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *InitializeXRPWalletRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_InitializeXRPWalletRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := InitializeXRPWalletRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return InitializeXRPWalletRequestMultiError(errors)
	}
	return nil
}

// InitializeXRPWalletRequestMultiError is an error wrapping multiple
// validation errors returned by InitializeXRPWalletRequest.Validate(true) if
// the designated constraints aren't met.
type InitializeXRPWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitializeXRPWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitializeXRPWalletRequestMultiError) AllErrors() []error { return m }

// InitializeXRPWalletRequestValidationError is the validation error returned
// by InitializeXRPWalletRequest.Validate if the designated constraints aren't met.
type InitializeXRPWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitializeXRPWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitializeXRPWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitializeXRPWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitializeXRPWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitializeXRPWalletRequestValidationError) ErrorName() string {
	return "InitializeXRPWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitializeXRPWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitializeXRPWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitializeXRPWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitializeXRPWalletRequestValidationError{}

var _InitializeXRPWalletRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on InitializeWalletRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in InitializeWalletRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *InitializeWalletRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_InitializeWalletRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := InitializeWalletRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return InitializeWalletRequestMultiError(errors)
	}
	return nil
}

// InitializeWalletRequestMultiError is an error wrapping multiple validation
// errors returned by InitializeWalletRequest.Validate(true) if the designated
// constraints aren't met.
type InitializeWalletRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m InitializeWalletRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m InitializeWalletRequestMultiError) AllErrors() []error { return m }

// InitializeWalletRequestValidationError is the validation error returned by
// InitializeWalletRequest.Validate if the designated constraints aren't met.
type InitializeWalletRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e InitializeWalletRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e InitializeWalletRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e InitializeWalletRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e InitializeWalletRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e InitializeWalletRequestValidationError) ErrorName() string {
	return "InitializeWalletRequestValidationError"
}

// Error satisfies the builtin error interface
func (e InitializeWalletRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sInitializeWalletRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = InitializeWalletRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = InitializeWalletRequestValidationError{}

var _InitializeWalletRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on SignTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SignTransactionRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *SignTransactionRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SignTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := SignTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SignTransactionRequest_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := SignTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SignTransactionRequestMultiError(errors)
	}
	return nil
}

// SignTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by SignTransactionRequest.Validate(true) if the designated
// constraints aren't met.
type SignTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignTransactionRequestMultiError) AllErrors() []error { return m }

// SignTransactionRequestValidationError is the validation error returned by
// SignTransactionRequest.Validate if the designated constraints aren't met.
type SignTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignTransactionRequestValidationError) ErrorName() string {
	return "SignTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SignTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignTransactionRequestValidationError{}

var _SignTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _SignTransactionRequest_TransactionId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on SignMessageRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SignMessageRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *SignMessageRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SignMessageRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := SignMessageRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Message

	switch m.XAddressId.(type) {

	case *SignMessageRequest_AddressId:

		if !_SignMessageRequest_AddressId_Pattern.MatchString(m.GetAddressId()) {
			err := SignMessageRequestValidationError{
				field:  "AddressId",
				reason: "value does not match regex pattern \"^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
			}
			if !all {
				return err
			}
			errors = append(errors, err)
		}

	}

	switch m.XAddress.(type) {

	case *SignMessageRequest_Address:
		// no validation rules for Address

	}

	if len(errors) > 0 {
		return SignMessageRequestMultiError(errors)
	}
	return nil
}

// SignMessageRequestMultiError is an error wrapping multiple validation errors
// returned by SignMessageRequest.Validate(true) if the designated constraints
// aren't met.
type SignMessageRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignMessageRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignMessageRequestMultiError) AllErrors() []error { return m }

// SignMessageRequestValidationError is the validation error returned by
// SignMessageRequest.Validate if the designated constraints aren't met.
type SignMessageRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignMessageRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignMessageRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignMessageRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignMessageRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignMessageRequestValidationError) ErrorName() string {
	return "SignMessageRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SignMessageRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignMessageRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignMessageRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignMessageRequestValidationError{}

var _SignMessageRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _SignMessageRequest_AddressId_Pattern = regexp.MustCompile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on SignMessageResponse with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SignMessageResponseMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *SignMessageResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	// no validation rules for Signature

	if len(errors) > 0 {
		return SignMessageResponseMultiError(errors)
	}
	return nil
}

// SignMessageResponseMultiError is an error wrapping multiple validation
// errors returned by SignMessageResponse.Validate(true) if the designated
// constraints aren't met.
type SignMessageResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SignMessageResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SignMessageResponseMultiError) AllErrors() []error { return m }

// SignMessageResponseValidationError is the validation error returned by
// SignMessageResponse.Validate if the designated constraints aren't met.
type SignMessageResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SignMessageResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SignMessageResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SignMessageResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SignMessageResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SignMessageResponseValidationError) ErrorName() string {
	return "SignMessageResponseValidationError"
}

// Error satisfies the builtin error interface
func (e SignMessageResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSignMessageResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SignMessageResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SignMessageResponseValidationError{}

// Validate checks the field values on SendTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in SendTransactionRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *SendTransactionRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_SendTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := SendTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_SendTransactionRequest_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := SendTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return SendTransactionRequestMultiError(errors)
	}
	return nil
}

// SendTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by SendTransactionRequest.Validate(true) if the designated
// constraints aren't met.
type SendTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m SendTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m SendTransactionRequestMultiError) AllErrors() []error { return m }

// SendTransactionRequestValidationError is the validation error returned by
// SendTransactionRequest.Validate if the designated constraints aren't met.
type SendTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e SendTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e SendTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e SendTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e SendTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e SendTransactionRequestValidationError) ErrorName() string {
	return "SendTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e SendTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sSendTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = SendTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = SendTransactionRequestValidationError{}

var _SendTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _SendTransactionRequest_TransactionId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ResendTransactionRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ResendTransactionRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ResendTransactionRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ResendTransactionRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ResendTransactionRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ResendTransactionRequest_TransactionId_Pattern.MatchString(m.GetTransactionId()) {
		err := ResendTransactionRequestValidationError{
			field:  "TransactionId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ResendTransactionRequestMultiError(errors)
	}
	return nil
}

// ResendTransactionRequestMultiError is an error wrapping multiple validation
// errors returned by ResendTransactionRequest.Validate(true) if the
// designated constraints aren't met.
type ResendTransactionRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ResendTransactionRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ResendTransactionRequestMultiError) AllErrors() []error { return m }

// ResendTransactionRequestValidationError is the validation error returned by
// ResendTransactionRequest.Validate if the designated constraints aren't met.
type ResendTransactionRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ResendTransactionRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ResendTransactionRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ResendTransactionRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ResendTransactionRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ResendTransactionRequestValidationError) ErrorName() string {
	return "ResendTransactionRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ResendTransactionRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sResendTransactionRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ResendTransactionRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ResendTransactionRequestValidationError{}

var _ResendTransactionRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ResendTransactionRequest_TransactionId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

// Validate checks the field values on ProgmatCoinInitializeRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ProgmatCoinInitializeRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ProgmatCoinInitializeRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinInitializeRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinInitializeRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTokenName()); l < 1 || l > 40 {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "TokenName",
			reason: "value length must be between 1 and 40 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTokenSymbol()); l < 1 || l > 10 {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "TokenSymbol",
			reason: "value length must be between 1 and 10 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if l := utf8.RuneCountInString(m.GetTokenCurrency()); l < 1 || l > 3 {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "TokenCurrency",
			reason: "value length must be between 1 and 3 runes, inclusive",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if m.GetTokenDecimals() >= 100 {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "TokenDecimals",
			reason: "value must be less than 100",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinInitializeRequest_NewMasterMinter_Pattern.MatchString(m.GetNewMasterMinter()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "NewMasterMinter",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinInitializeRequest_NewPauser_Pattern.MatchString(m.GetNewPauser()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "NewPauser",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinInitializeRequest_NewWhiteAndBlackLister_Pattern.MatchString(m.GetNewWhiteAndBlackLister()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "NewWhiteAndBlackLister",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinInitializeRequest_NewConfiscator_Pattern.MatchString(m.GetNewConfiscator()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "NewConfiscator",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinInitializeRequest_NewOwner_Pattern.MatchString(m.GetNewOwner()) {
		err := ProgmatCoinInitializeRequestValidationError{
			field:  "NewOwner",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ProgmatCoinInitializeRequestMultiError(errors)
	}
	return nil
}

// ProgmatCoinInitializeRequestMultiError is an error wrapping multiple
// validation errors returned by ProgmatCoinInitializeRequest.Validate(true)
// if the designated constraints aren't met.
type ProgmatCoinInitializeRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinInitializeRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinInitializeRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinInitializeRequestValidationError is the validation error returned
// by ProgmatCoinInitializeRequest.Validate if the designated constraints
// aren't met.
type ProgmatCoinInitializeRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinInitializeRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinInitializeRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinInitializeRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinInitializeRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinInitializeRequestValidationError) ErrorName() string {
	return "ProgmatCoinInitializeRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinInitializeRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinInitializeRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinInitializeRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinInitializeRequestValidationError{}

var _ProgmatCoinInitializeRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinInitializeRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinInitializeRequest_NewMasterMinter_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinInitializeRequest_NewPauser_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinInitializeRequest_NewWhiteAndBlackLister_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinInitializeRequest_NewConfiscator_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinInitializeRequest_NewOwner_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinConfigureMinterRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ProgmatCoinConfigureMinterRequestMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *ProgmatCoinConfigureMinterRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinConfigureMinterRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinConfigureMinterRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinConfigureMinterRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinConfigureMinterRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinConfigureMinterRequest_Address_Pattern.MatchString(m.GetAddress()) {
		err := ProgmatCoinConfigureMinterRequestValidationError{
			field:  "Address",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for MinterAllowedAmount

	if len(errors) > 0 {
		return ProgmatCoinConfigureMinterRequestMultiError(errors)
	}
	return nil
}

// ProgmatCoinConfigureMinterRequestMultiError is an error wrapping multiple
// validation errors returned by
// ProgmatCoinConfigureMinterRequest.Validate(true) if the designated
// constraints aren't met.
type ProgmatCoinConfigureMinterRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinConfigureMinterRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinConfigureMinterRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinConfigureMinterRequestValidationError is the validation error
// returned by ProgmatCoinConfigureMinterRequest.Validate if the designated
// constraints aren't met.
type ProgmatCoinConfigureMinterRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinConfigureMinterRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinConfigureMinterRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinConfigureMinterRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinConfigureMinterRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinConfigureMinterRequestValidationError) ErrorName() string {
	return "ProgmatCoinConfigureMinterRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinConfigureMinterRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinConfigureMinterRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinConfigureMinterRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinConfigureMinterRequestValidationError{}

var _ProgmatCoinConfigureMinterRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinConfigureMinterRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinConfigureMinterRequest_Address_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinMintAndTransferRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ProgmatCoinMintAndTransferRequestMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *ProgmatCoinMintAndTransferRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinMintAndTransferRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinMintAndTransferRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinMintAndTransferRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinMintAndTransferRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinMintAndTransferRequest_MintAddress_Pattern.MatchString(m.GetMintAddress()) {
		err := ProgmatCoinMintAndTransferRequestValidationError{
			field:  "MintAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinMintAndTransferRequest_TransferAddress_Pattern.MatchString(m.GetTransferAddress()) {
		err := ProgmatCoinMintAndTransferRequestValidationError{
			field:  "TransferAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Amount

	if len(errors) > 0 {
		return ProgmatCoinMintAndTransferRequestMultiError(errors)
	}
	return nil
}

// ProgmatCoinMintAndTransferRequestMultiError is an error wrapping multiple
// validation errors returned by
// ProgmatCoinMintAndTransferRequest.Validate(true) if the designated
// constraints aren't met.
type ProgmatCoinMintAndTransferRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinMintAndTransferRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinMintAndTransferRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinMintAndTransferRequestValidationError is the validation error
// returned by ProgmatCoinMintAndTransferRequest.Validate if the designated
// constraints aren't met.
type ProgmatCoinMintAndTransferRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinMintAndTransferRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinMintAndTransferRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinMintAndTransferRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinMintAndTransferRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinMintAndTransferRequestValidationError) ErrorName() string {
	return "ProgmatCoinMintAndTransferRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinMintAndTransferRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinMintAndTransferRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinMintAndTransferRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinMintAndTransferRequestValidationError{}

var _ProgmatCoinMintAndTransferRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinMintAndTransferRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinMintAndTransferRequest_MintAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinMintAndTransferRequest_TransferAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinMintRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ProgmatCoinMintRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ProgmatCoinMintRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinMintRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinMintRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinMintRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinMintRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinMintRequest_Address_Pattern.MatchString(m.GetAddress()) {
		err := ProgmatCoinMintRequestValidationError{
			field:  "Address",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Amount

	if len(errors) > 0 {
		return ProgmatCoinMintRequestMultiError(errors)
	}
	return nil
}

// ProgmatCoinMintRequestMultiError is an error wrapping multiple validation
// errors returned by ProgmatCoinMintRequest.Validate(true) if the designated
// constraints aren't met.
type ProgmatCoinMintRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinMintRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinMintRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinMintRequestValidationError is the validation error returned by
// ProgmatCoinMintRequest.Validate if the designated constraints aren't met.
type ProgmatCoinMintRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinMintRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinMintRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinMintRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinMintRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinMintRequestValidationError) ErrorName() string {
	return "ProgmatCoinMintRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinMintRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinMintRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinMintRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinMintRequestValidationError{}

var _ProgmatCoinMintRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinMintRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinMintRequest_Address_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinBurnRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ProgmatCoinBurnRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ProgmatCoinBurnRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinBurnRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinBurnRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinBurnRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinBurnRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Amount

	if len(errors) > 0 {
		return ProgmatCoinBurnRequestMultiError(errors)
	}
	return nil
}

// ProgmatCoinBurnRequestMultiError is an error wrapping multiple validation
// errors returned by ProgmatCoinBurnRequest.Validate(true) if the designated
// constraints aren't met.
type ProgmatCoinBurnRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinBurnRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinBurnRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinBurnRequestValidationError is the validation error returned by
// ProgmatCoinBurnRequest.Validate if the designated constraints aren't met.
type ProgmatCoinBurnRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinBurnRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinBurnRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinBurnRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinBurnRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinBurnRequestValidationError) ErrorName() string {
	return "ProgmatCoinBurnRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinBurnRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinBurnRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinBurnRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinBurnRequestValidationError{}

var _ProgmatCoinBurnRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinBurnRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinAddToWhitelistRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ProgmatCoinAddToWhitelistRequestMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *ProgmatCoinAddToWhitelistRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinAddToWhitelistRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinAddToWhitelistRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinAddToWhitelistRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinAddToWhitelistRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinAddToWhitelistRequest_Address_Pattern.MatchString(m.GetAddress()) {
		err := ProgmatCoinAddToWhitelistRequestValidationError{
			field:  "Address",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ProgmatCoinAddToWhitelistRequestMultiError(errors)
	}
	return nil
}

// ProgmatCoinAddToWhitelistRequestMultiError is an error wrapping multiple
// validation errors returned by
// ProgmatCoinAddToWhitelistRequest.Validate(true) if the designated
// constraints aren't met.
type ProgmatCoinAddToWhitelistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinAddToWhitelistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinAddToWhitelistRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinAddToWhitelistRequestValidationError is the validation error
// returned by ProgmatCoinAddToWhitelistRequest.Validate if the designated
// constraints aren't met.
type ProgmatCoinAddToWhitelistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinAddToWhitelistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinAddToWhitelistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinAddToWhitelistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinAddToWhitelistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinAddToWhitelistRequestValidationError) ErrorName() string {
	return "ProgmatCoinAddToWhitelistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinAddToWhitelistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinAddToWhitelistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinAddToWhitelistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinAddToWhitelistRequestValidationError{}

var _ProgmatCoinAddToWhitelistRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinAddToWhitelistRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinAddToWhitelistRequest_Address_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinRemoveFromWhitelistRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in
// ProgmatCoinRemoveFromWhitelistRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ProgmatCoinRemoveFromWhitelistRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinRemoveFromWhitelistRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinRemoveFromWhitelistRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinRemoveFromWhitelistRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinRemoveFromWhitelistRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinRemoveFromWhitelistRequest_Address_Pattern.MatchString(m.GetAddress()) {
		err := ProgmatCoinRemoveFromWhitelistRequestValidationError{
			field:  "Address",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ProgmatCoinRemoveFromWhitelistRequestMultiError(errors)
	}
	return nil
}

// ProgmatCoinRemoveFromWhitelistRequestMultiError is an error wrapping
// multiple validation errors returned by
// ProgmatCoinRemoveFromWhitelistRequest.Validate(true) if the designated
// constraints aren't met.
type ProgmatCoinRemoveFromWhitelistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinRemoveFromWhitelistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinRemoveFromWhitelistRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinRemoveFromWhitelistRequestValidationError is the validation error
// returned by ProgmatCoinRemoveFromWhitelistRequest.Validate if the
// designated constraints aren't met.
type ProgmatCoinRemoveFromWhitelistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinRemoveFromWhitelistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinRemoveFromWhitelistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinRemoveFromWhitelistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinRemoveFromWhitelistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinRemoveFromWhitelistRequestValidationError) ErrorName() string {
	return "ProgmatCoinRemoveFromWhitelistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinRemoveFromWhitelistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinRemoveFromWhitelistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinRemoveFromWhitelistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinRemoveFromWhitelistRequestValidationError{}

var _ProgmatCoinRemoveFromWhitelistRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinRemoveFromWhitelistRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinRemoveFromWhitelistRequest_Address_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinAddToBlacklistRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ProgmatCoinAddToBlacklistRequestMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *ProgmatCoinAddToBlacklistRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinAddToBlacklistRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinAddToBlacklistRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinAddToBlacklistRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinAddToBlacklistRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinAddToBlacklistRequest_Address_Pattern.MatchString(m.GetAddress()) {
		err := ProgmatCoinAddToBlacklistRequestValidationError{
			field:  "Address",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ProgmatCoinAddToBlacklistRequestMultiError(errors)
	}
	return nil
}

// ProgmatCoinAddToBlacklistRequestMultiError is an error wrapping multiple
// validation errors returned by
// ProgmatCoinAddToBlacklistRequest.Validate(true) if the designated
// constraints aren't met.
type ProgmatCoinAddToBlacklistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinAddToBlacklistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinAddToBlacklistRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinAddToBlacklistRequestValidationError is the validation error
// returned by ProgmatCoinAddToBlacklistRequest.Validate if the designated
// constraints aren't met.
type ProgmatCoinAddToBlacklistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinAddToBlacklistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinAddToBlacklistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinAddToBlacklistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinAddToBlacklistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinAddToBlacklistRequestValidationError) ErrorName() string {
	return "ProgmatCoinAddToBlacklistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinAddToBlacklistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinAddToBlacklistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinAddToBlacklistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinAddToBlacklistRequestValidationError{}

var _ProgmatCoinAddToBlacklistRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinAddToBlacklistRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinAddToBlacklistRequest_Address_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinRemoveFromBlacklistRequest
// with the rules defined in the proto definition for this message. If any
// rules are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in
// ProgmatCoinRemoveFromBlacklistRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ProgmatCoinRemoveFromBlacklistRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinRemoveFromBlacklistRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinRemoveFromBlacklistRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinRemoveFromBlacklistRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinRemoveFromBlacklistRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinRemoveFromBlacklistRequest_Address_Pattern.MatchString(m.GetAddress()) {
		err := ProgmatCoinRemoveFromBlacklistRequestValidationError{
			field:  "Address",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ProgmatCoinRemoveFromBlacklistRequestMultiError(errors)
	}
	return nil
}

// ProgmatCoinRemoveFromBlacklistRequestMultiError is an error wrapping
// multiple validation errors returned by
// ProgmatCoinRemoveFromBlacklistRequest.Validate(true) if the designated
// constraints aren't met.
type ProgmatCoinRemoveFromBlacklistRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinRemoveFromBlacklistRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinRemoveFromBlacklistRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinRemoveFromBlacklistRequestValidationError is the validation error
// returned by ProgmatCoinRemoveFromBlacklistRequest.Validate if the
// designated constraints aren't met.
type ProgmatCoinRemoveFromBlacklistRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinRemoveFromBlacklistRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinRemoveFromBlacklistRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinRemoveFromBlacklistRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinRemoveFromBlacklistRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinRemoveFromBlacklistRequestValidationError) ErrorName() string {
	return "ProgmatCoinRemoveFromBlacklistRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinRemoveFromBlacklistRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinRemoveFromBlacklistRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinRemoveFromBlacklistRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinRemoveFromBlacklistRequestValidationError{}

var _ProgmatCoinRemoveFromBlacklistRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinRemoveFromBlacklistRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinRemoveFromBlacklistRequest_Address_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinConfiscateRequest with the
// rules defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ProgmatCoinConfiscateRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ProgmatCoinConfiscateRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinConfiscateRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinConfiscateRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinConfiscateRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinConfiscateRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinConfiscateRequest_BlackListedAccount_Pattern.MatchString(m.GetBlackListedAccount()) {
		err := ProgmatCoinConfiscateRequestValidationError{
			field:  "BlackListedAccount",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if !_ProgmatCoinConfiscateRequest_ToAccount_Pattern.MatchString(m.GetToAccount()) {
		err := ProgmatCoinConfiscateRequestValidationError{
			field:  "ToAccount",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for Amount

	if len(errors) > 0 {
		return ProgmatCoinConfiscateRequestMultiError(errors)
	}
	return nil
}

// ProgmatCoinConfiscateRequestMultiError is an error wrapping multiple
// validation errors returned by ProgmatCoinConfiscateRequest.Validate(true)
// if the designated constraints aren't met.
type ProgmatCoinConfiscateRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinConfiscateRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinConfiscateRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinConfiscateRequestValidationError is the validation error returned
// by ProgmatCoinConfiscateRequest.Validate if the designated constraints
// aren't met.
type ProgmatCoinConfiscateRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinConfiscateRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinConfiscateRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinConfiscateRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinConfiscateRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinConfiscateRequestValidationError) ErrorName() string {
	return "ProgmatCoinConfiscateRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinConfiscateRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinConfiscateRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinConfiscateRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinConfiscateRequestValidationError{}

var _ProgmatCoinConfiscateRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinConfiscateRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinConfiscateRequest_BlackListedAccount_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

var _ProgmatCoinConfiscateRequest_ToAccount_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinPauseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ProgmatCoinPauseRequestMultiError, or nil if none found.
// Otherwise, only the first error is returned, if any.
func (m *ProgmatCoinPauseRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinPauseRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinPauseRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinPauseRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinPauseRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ProgmatCoinPauseRequestMultiError(errors)
	}
	return nil
}

// ProgmatCoinPauseRequestMultiError is an error wrapping multiple validation
// errors returned by ProgmatCoinPauseRequest.Validate(true) if the designated
// constraints aren't met.
type ProgmatCoinPauseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinPauseRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinPauseRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinPauseRequestValidationError is the validation error returned by
// ProgmatCoinPauseRequest.Validate if the designated constraints aren't met.
type ProgmatCoinPauseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinPauseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinPauseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinPauseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinPauseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinPauseRequestValidationError) ErrorName() string {
	return "ProgmatCoinPauseRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinPauseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinPauseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinPauseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinPauseRequestValidationError{}

var _ProgmatCoinPauseRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinPauseRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ProgmatCoinUnpauseRequest with the rules
// defined in the proto definition for this message. If any rules are
// violated, an error is returned. When asked to return all errors, validation
// continues after first violation, and the result is a list of violation
// errors wrapped in ProgmatCoinUnpauseRequestMultiError, or nil if none
// found. Otherwise, only the first error is returned, if any.
func (m *ProgmatCoinUnpauseRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if !_ProgmatCoinUnpauseRequest_WalletId_Pattern.MatchString(m.GetWalletId()) {
		err := ProgmatCoinUnpauseRequestValidationError{
			field:  "WalletId",
			reason: "value does not match regex pattern \"^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	// no validation rules for FeeRate

	if !_ProgmatCoinUnpauseRequest_ContractAddress_Pattern.MatchString(m.GetContractAddress()) {
		err := ProgmatCoinUnpauseRequestValidationError{
			field:  "ContractAddress",
			reason: "value does not match regex pattern \"^(0x)?[0-9a-fA-F]{40}$\"",
		}
		if !all {
			return err
		}
		errors = append(errors, err)
	}

	if len(errors) > 0 {
		return ProgmatCoinUnpauseRequestMultiError(errors)
	}
	return nil
}

// ProgmatCoinUnpauseRequestMultiError is an error wrapping multiple validation
// errors returned by ProgmatCoinUnpauseRequest.Validate(true) if the
// designated constraints aren't met.
type ProgmatCoinUnpauseRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ProgmatCoinUnpauseRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ProgmatCoinUnpauseRequestMultiError) AllErrors() []error { return m }

// ProgmatCoinUnpauseRequestValidationError is the validation error returned by
// ProgmatCoinUnpauseRequest.Validate if the designated constraints aren't met.
type ProgmatCoinUnpauseRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ProgmatCoinUnpauseRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ProgmatCoinUnpauseRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ProgmatCoinUnpauseRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ProgmatCoinUnpauseRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ProgmatCoinUnpauseRequestValidationError) ErrorName() string {
	return "ProgmatCoinUnpauseRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ProgmatCoinUnpauseRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sProgmatCoinUnpauseRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ProgmatCoinUnpauseRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ProgmatCoinUnpauseRequestValidationError{}

var _ProgmatCoinUnpauseRequest_WalletId_Pattern = regexp.MustCompile("^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$")

var _ProgmatCoinUnpauseRequest_ContractAddress_Pattern = regexp.MustCompile("^(0x)?[0-9a-fA-F]{40}$")

// Validate checks the field values on ListColdFeeDepositAddressesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListColdFeeDepositAddressesRequestMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListColdFeeDepositAddressesRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListColdFeeDepositAddressesRequestMultiError(errors)
	}
	return nil
}

// ListColdFeeDepositAddressesRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListColdFeeDepositAddressesRequest.Validate(true) if the designated
// constraints aren't met.
type ListColdFeeDepositAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListColdFeeDepositAddressesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListColdFeeDepositAddressesRequestMultiError) AllErrors() []error { return m }

// ListColdFeeDepositAddressesRequestValidationError is the validation error
// returned by ListColdFeeDepositAddressesRequest.Validate if the designated
// constraints aren't met.
type ListColdFeeDepositAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListColdFeeDepositAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListColdFeeDepositAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListColdFeeDepositAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListColdFeeDepositAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListColdFeeDepositAddressesRequestValidationError) ErrorName() string {
	return "ListColdFeeDepositAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListColdFeeDepositAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListColdFeeDepositAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListColdFeeDepositAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListColdFeeDepositAddressesRequestValidationError{}

// Validate checks the field values on ListColdFeeDepositAddressesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListColdFeeDepositAddressesResponseMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListColdFeeDepositAddressesResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetCallerAddresses() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListColdFeeDepositAddressesResponseValidationError{
					field:  fmt.Sprintf("CallerAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListColdFeeDepositAddressesResponseMultiError(errors)
	}
	return nil
}

// ListColdFeeDepositAddressesResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListColdFeeDepositAddressesResponse.Validate(true) if the designated
// constraints aren't met.
type ListColdFeeDepositAddressesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListColdFeeDepositAddressesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListColdFeeDepositAddressesResponseMultiError) AllErrors() []error { return m }

// ListColdFeeDepositAddressesResponseValidationError is the validation error
// returned by ListColdFeeDepositAddressesResponse.Validate if the designated
// constraints aren't met.
type ListColdFeeDepositAddressesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListColdFeeDepositAddressesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListColdFeeDepositAddressesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListColdFeeDepositAddressesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListColdFeeDepositAddressesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListColdFeeDepositAddressesResponseValidationError) ErrorName() string {
	return "ListColdFeeDepositAddressesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListColdFeeDepositAddressesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListColdFeeDepositAddressesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListColdFeeDepositAddressesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListColdFeeDepositAddressesResponseValidationError{}

// Validate checks the field values on ListHotFeeDepositAddressesRequest with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListHotFeeDepositAddressesRequestMultiError, or
// nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListHotFeeDepositAddressesRequest) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	if len(errors) > 0 {
		return ListHotFeeDepositAddressesRequestMultiError(errors)
	}
	return nil
}

// ListHotFeeDepositAddressesRequestMultiError is an error wrapping multiple
// validation errors returned by
// ListHotFeeDepositAddressesRequest.Validate(true) if the designated
// constraints aren't met.
type ListHotFeeDepositAddressesRequestMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListHotFeeDepositAddressesRequestMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListHotFeeDepositAddressesRequestMultiError) AllErrors() []error { return m }

// ListHotFeeDepositAddressesRequestValidationError is the validation error
// returned by ListHotFeeDepositAddressesRequest.Validate if the designated
// constraints aren't met.
type ListHotFeeDepositAddressesRequestValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListHotFeeDepositAddressesRequestValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListHotFeeDepositAddressesRequestValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListHotFeeDepositAddressesRequestValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListHotFeeDepositAddressesRequestValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListHotFeeDepositAddressesRequestValidationError) ErrorName() string {
	return "ListHotFeeDepositAddressesRequestValidationError"
}

// Error satisfies the builtin error interface
func (e ListHotFeeDepositAddressesRequestValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListHotFeeDepositAddressesRequest.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListHotFeeDepositAddressesRequestValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListHotFeeDepositAddressesRequestValidationError{}

// Validate checks the field values on ListHotFeeDepositAddressesResponse with
// the rules defined in the proto definition for this message. If any rules
// are violated, an error is returned. When asked to return all errors,
// validation continues after first violation, and the result is a list of
// violation errors wrapped in ListHotFeeDepositAddressesResponseMultiError,
// or nil if none found. Otherwise, only the first error is returned, if any.
func (m *ListHotFeeDepositAddressesResponse) Validate(all bool) error {
	if m == nil {
		return nil
	}

	var errors []error

	for idx, item := range m.GetFeeDepositAddresses() {
		_, _ = idx, item

		if v, ok := interface{}(item).(interface{ Validate(bool) error }); ok {
			if err := v.Validate(all); err != nil {
				err = ListHotFeeDepositAddressesResponseValidationError{
					field:  fmt.Sprintf("FeeDepositAddresses[%v]", idx),
					reason: "embedded message failed validation",
					cause:  err,
				}
				if !all {
					return err
				}
				errors = append(errors, err)
			}
		}

	}

	if len(errors) > 0 {
		return ListHotFeeDepositAddressesResponseMultiError(errors)
	}
	return nil
}

// ListHotFeeDepositAddressesResponseMultiError is an error wrapping multiple
// validation errors returned by
// ListHotFeeDepositAddressesResponse.Validate(true) if the designated
// constraints aren't met.
type ListHotFeeDepositAddressesResponseMultiError []error

// Error returns a concatenation of all the error messages it wraps.
func (m ListHotFeeDepositAddressesResponseMultiError) Error() string {
	var msgs []string
	for _, err := range m {
		msgs = append(msgs, err.Error())
	}
	return strings.Join(msgs, "; ")
}

// AllErrors returns a list of validation violation errors.
func (m ListHotFeeDepositAddressesResponseMultiError) AllErrors() []error { return m }

// ListHotFeeDepositAddressesResponseValidationError is the validation error
// returned by ListHotFeeDepositAddressesResponse.Validate if the designated
// constraints aren't met.
type ListHotFeeDepositAddressesResponseValidationError struct {
	field  string
	reason string
	cause  error
	key    bool
}

// Field function returns field value.
func (e ListHotFeeDepositAddressesResponseValidationError) Field() string { return e.field }

// Reason function returns reason value.
func (e ListHotFeeDepositAddressesResponseValidationError) Reason() string { return e.reason }

// Cause function returns cause value.
func (e ListHotFeeDepositAddressesResponseValidationError) Cause() error { return e.cause }

// Key function returns key value.
func (e ListHotFeeDepositAddressesResponseValidationError) Key() bool { return e.key }

// ErrorName returns error name.
func (e ListHotFeeDepositAddressesResponseValidationError) ErrorName() string {
	return "ListHotFeeDepositAddressesResponseValidationError"
}

// Error satisfies the builtin error interface
func (e ListHotFeeDepositAddressesResponseValidationError) Error() string {
	cause := ""
	if e.cause != nil {
		cause = fmt.Sprintf(" | caused by: %v", e.cause)
	}

	key := ""
	if e.key {
		key = "key for "
	}

	return fmt.Sprintf(
		"invalid %sListHotFeeDepositAddressesResponse.%s: %s%s",
		key,
		e.field,
		e.reason,
		cause)
}

var _ error = ListHotFeeDepositAddressesResponseValidationError{}

var _ interface {
	Field() string
	Reason() string
	Key() bool
	Cause() error
	ErrorName() string
} = ListHotFeeDepositAddressesResponseValidationError{}
