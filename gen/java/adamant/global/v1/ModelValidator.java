// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: gincoinc/adamant/global/v1/adamantglobalv1/model.proto

package adamant.global.v1;

public class ModelValidator {
	public static io.envoyproxy.pgv.ValidatorImpl validatorFor(Class clazz) {
		
		if (clazz.equals(adamant.global.v1.Model.Wallet.class)) return new WalletValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletWithoutBalance.class)) return new WalletWithoutBalanceValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletProposal.class)) return new WalletProposalValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletMember.class)) return new WalletMemberValidator();
		if (clazz.equals(adamant.global.v1.Model.Key.class)) return new KeyValidator();
		if (clazz.equals(adamant.global.v1.Model.Address.class)) return new AddressValidator();
		if (clazz.equals(adamant.global.v1.Model.AddressWithoutBalance.class)) return new AddressWithoutBalanceValidator();
		if (clazz.equals(adamant.global.v1.Model.FlushedAddress.class)) return new FlushedAddressValidator();
		if (clazz.equals(adamant.global.v1.Model.EthereumFeeAddress.class)) return new EthereumFeeAddressValidator();
		if (clazz.equals(adamant.global.v1.Model.AddressWithBalance.class)) return new AddressWithBalanceValidator();
		if (clazz.equals(adamant.global.v1.Model.Transaction.class)) return new TransactionValidator();
		if (clazz.equals(adamant.global.v1.Model.TransactionMember.class)) return new TransactionMemberValidator();
		if (clazz.equals(adamant.global.v1.Model.TxInput.class)) return new TxInputValidator();
		if (clazz.equals(adamant.global.v1.Model.TxOutput.class)) return new TxOutputValidator();
		if (clazz.equals(adamant.global.v1.Model.BitcoinSpecific.class)) return new BitcoinSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.LitecoinSpecific.class)) return new LitecoinSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.BitcoincashSpecific.class)) return new BitcoincashSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.EthereumSpecific.class)) return new EthereumSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.XrpSpecific.class)) return new XrpSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.TronSpecific.class)) return new TronSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.C0banSpecific.class)) return new C0BanSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.StellarSpecific.class)) return new StellarSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.SignInfo.class)) return new SignInfoValidator();
		if (clazz.equals(adamant.global.v1.Model.SignTxInput.class)) return new SignTxInputValidator();
		if (clazz.equals(adamant.global.v1.Model.Transfer.class)) return new TransferValidator();
		if (clazz.equals(adamant.global.v1.Model.Rate.class)) return new RateValidator();
		if (clazz.equals(adamant.global.v1.Model.RateSnapshot.class)) return new RateSnapshotValidator();
		if (clazz.equals(adamant.global.v1.Model.Deactivatability.class)) return new DeactivatabilityValidator();
		if (clazz.equals(adamant.global.v1.Model.LabeledAddress.class)) return new LabeledAddressValidator();
		if (clazz.equals(adamant.global.v1.Model.LabeledAddressProposal.class)) return new LabeledAddressProposalValidator();
		if (clazz.equals(adamant.global.v1.Model.Whitelist.class)) return new WhitelistValidator();
		if (clazz.equals(adamant.global.v1.Model.TransferLimit.class)) return new TransferLimitValidator();
		if (clazz.equals(adamant.global.v1.Model.TransferLimitProposal.class)) return new TransferLimitProposalValidator();
		if (clazz.equals(adamant.global.v1.Model.Policy.class)) return new PolicyValidator();
		if (clazz.equals(adamant.global.v1.Model.PolicyProposal.class)) return new PolicyProposalValidator();
		if (clazz.equals(adamant.global.v1.Model.TotalBalanceByCoin.class)) return new TotalBalanceByCoinValidator();
		if (clazz.equals(adamant.global.v1.Model.TotalBalance.class)) return new TotalBalanceValidator();
		if (clazz.equals(adamant.global.v1.Model.BalanceSnapshot.class)) return new BalanceSnapshotValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletBalanceSnapshotMap.class)) return new WalletBalanceSnapshotMapValidator();
		if (clazz.equals(adamant.global.v1.Model.ListWalletBalanceSnapshots.class)) return new ListWalletBalanceSnapshotsValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletBalanceSnapshot.class)) return new WalletBalanceSnapshotValidator();
		if (clazz.equals(adamant.global.v1.Model.TransferVolumeSnapshots.class)) return new TransferVolumeSnapshotsValidator();
		if (clazz.equals(adamant.global.v1.Model.ListTransferVolumeSnapshots.class)) return new ListTransferVolumeSnapshotsValidator();
		if (clazz.equals(adamant.global.v1.Model.TransferVolumeSnapshot.class)) return new TransferVolumeSnapshotValidator();
		if (clazz.equals(adamant.global.v1.Model.TransferVolume.class)) return new TransferVolumeValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletTransferVolumeSnapshots.class)) return new WalletTransferVolumeSnapshotsValidator();
		if (clazz.equals(adamant.global.v1.Model.ListWalletTransferVolumeSnapshots.class)) return new ListWalletTransferVolumeSnapshotsValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletTransferVolumeSnapshot.class)) return new WalletTransferVolumeSnapshotValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletTransferVolume.class)) return new WalletTransferVolumeValidator();
		if (clazz.equals(adamant.global.v1.Model.Confirmation.class)) return new ConfirmationValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletFlushSetting.class)) return new WalletFlushSettingValidator();
		if (clazz.equals(adamant.global.v1.Model.CompensationFee.class)) return new CompensationFeeValidator();
		if (clazz.equals(adamant.global.v1.Model.RequestTxOutput.class)) return new RequestTxOutputValidator();
		if (clazz.equals(adamant.global.v1.Model.RequestSignedInfo.class)) return new RequestSignedInfoValidator();
		if (clazz.equals(adamant.global.v1.Model.RequestSignature.class)) return new RequestSignatureValidator();
		if (clazz.equals(adamant.global.v1.Model.RequestTransferLimitEntry.class)) return new RequestTransferLimitEntryValidator();
		if (clazz.equals(adamant.global.v1.Model.RequestRate.class)) return new RequestRateValidator();
		return null;
	}


	/**
	 * Validates {@code Wallet} protobuf objects.
	 */
	public static class WalletValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Wallet> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Wallet proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for HdAccount

	// no validation rules for WalletType

	// no validation rules for AddressType

	// no validation rules for M

	// no validation rules for N

	// no validation rules for State

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getKeysList(), item -> {
				
			// Validate keys
			if (true) index.validatorFor(item).assertValid(item);
			});

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getMembersList(), item -> {
				
			// Validate members
			if (true) index.validatorFor(item).assertValid(item);
			});

	// no validation rules for RequiredApprovalCount

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for Address

	// no validation rules for PolicyId

	
			// Validate proposal
			if (proto.hasProposal()) index.validatorFor(proto.getProposal()).assertValid(proto.getProposal());
	// no validation rules for DestinationWalletId

	// no validation rules for WatchOnly

	// no validation rules for AddressNumber

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}

	/**
	 * Validates {@code WalletWithoutBalance} protobuf objects.
	 */
	public static class WalletWithoutBalanceValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletWithoutBalance> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletWithoutBalance proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for HdAccount

	// no validation rules for WalletType

	// no validation rules for AddressType

	// no validation rules for M

	// no validation rules for N

	// no validation rules for State

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getKeysList(), item -> {
				
			// Validate keys
			if (true) index.validatorFor(item).assertValid(item);
			});

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getMembersList(), item -> {
				
			// Validate members
			if (true) index.validatorFor(item).assertValid(item);
			});

	// no validation rules for RequiredApprovalCount

	// no validation rules for Address

	// no validation rules for PolicyId

	
			// Validate proposal
			if (proto.hasProposal()) index.validatorFor(proto.getProposal()).assertValid(proto.getProposal());
	// no validation rules for DestinationWalletId

	// no validation rules for WatchOnly

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}

	/**
	 * Validates {@code WalletProposal} protobuf objects.
	 */
	public static class WalletProposalValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletProposal> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletProposal proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for ProposalType

	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	// no validation rules for ProposedPolicy

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getProposedValidatorsList(), item -> {
				// no validation rules for ProposedValidators

			});

	// no validation rules for ProposedRequiredApprovalCount

	// no validation rules for IsReviewed

	
	}
}

	/**
	 * Validates {@code WalletMember} protobuf objects.
	 */
	public static class WalletMemberValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletMember> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletMember proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for Name

	// no validation rules for Email

	// no validation rules for Role

	// no validation rules for IsKeyRegistered

	// no validation rules for IsMaster

	// no validation rules for IsValidatedToCreateWallet

	
	}
}

	/**
	 * Validates {@code Key} protobuf objects.
	 */
	public static class KeyValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Key> {
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Key proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for KeyId

	// no validation rules for KeyIndex

	
	}
}

	/**
	 * Validates {@code Address} protobuf objects.
	 */
	public static class AddressValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Address> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Address proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for AddressId

	// no validation rules for Coin

	// no validation rules for Address

	// no validation rules for Index

	// no validation rules for HdChange

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for State

	// no validation rules for AddressType

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}

	/**
	 * Validates {@code AddressWithoutBalance} protobuf objects.
	 */
	public static class AddressWithoutBalanceValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.AddressWithoutBalance> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.AddressWithoutBalance proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for AddressId

	// no validation rules for Coin

	// no validation rules for Address

	// no validation rules for Index

	// no validation rules for HdChange

	// no validation rules for State

	// no validation rules for AddressType

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}

	/**
	 * Validates {@code FlushedAddress} protobuf objects.
	 */
	public static class FlushedAddressValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.FlushedAddress> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.FlushedAddress proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for AddressId

	// no validation rules for Coin

	// no validation rules for Address

	// no validation rules for Index

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for State

	// no validation rules for AddressType

	
	}
}

	/**
	 * Validates {@code EthereumFeeAddress} protobuf objects.
	 */
	public static class EthereumFeeAddressValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.EthereumFeeAddress> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.EthereumFeeAddress proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	
	}
}

	/**
	 * Validates {@code AddressWithBalance} protobuf objects.
	 */
	public static class AddressWithBalanceValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.AddressWithBalance> {
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.AddressWithBalance proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for FeeBalance

	// no validation rules for StringFeeBalance

	
	}
}

	/**
	 * Validates {@code Transaction} protobuf objects.
	 */
	public static class TransactionValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Transaction> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Transaction proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for Coin

	// no validation rules for TxId

	// no validation rules for Address

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for JpyRate

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for FeeRate

	// no validation rules for State

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getSignedKeysList(), item -> {
				
			// Validate signed_keys
			if (true) index.validatorFor(item).assertValid(item);
			});

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getMembersList(), item -> {
				
			// Validate members
			if (true) index.validatorFor(item).assertValid(item);
			});

	
			// Validate bitcoin_specific
			if (proto.hasBitcoinSpecific()) index.validatorFor(proto.getBitcoinSpecific()).assertValid(proto.getBitcoinSpecific());
	
			// Validate ethereum_specific
			if (proto.hasEthereumSpecific()) index.validatorFor(proto.getEthereumSpecific()).assertValid(proto.getEthereumSpecific());
	
			// Validate litecoin_specific
			if (proto.hasLitecoinSpecific()) index.validatorFor(proto.getLitecoinSpecific()).assertValid(proto.getLitecoinSpecific());
	
			// Validate bitcoincash_specific
			if (proto.hasBitcoincashSpecific()) index.validatorFor(proto.getBitcoincashSpecific()).assertValid(proto.getBitcoincashSpecific());
	
			// Validate xrp_specific
			if (proto.hasXrpSpecific()) index.validatorFor(proto.getXrpSpecific()).assertValid(proto.getXrpSpecific());
	
			// Validate tron_specific
			if (proto.hasTronSpecific()) index.validatorFor(proto.getTronSpecific()).assertValid(proto.getTronSpecific());
	
			// Validate c0ban_specific
			if (proto.hasC0BanSpecific()) index.validatorFor(proto.getC0BanSpecific()).assertValid(proto.getC0BanSpecific());
	
			// Validate stellar_specific
			if (proto.hasStellarSpecific()) index.validatorFor(proto.getStellarSpecific()).assertValid(proto.getStellarSpecific());
	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}

	/**
	 * Validates {@code TransactionMember} protobuf objects.
	 */
	public static class TransactionMemberValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TransactionMember> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TransactionMember proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for Name

	// no validation rules for Email

	// no validation rules for Role

	// no validation rules for Signed

	// no validation rules for Validated

	
	}
}

	/**
	 * Validates {@code TxInput} protobuf objects.
	 */
	public static class TxInputValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TxInput> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TxInput proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TxId

	// no validation rules for TxIndex

	// no validation rules for Value

	// no validation rules for StringValue

	
	}
}

	/**
	 * Validates {@code TxOutput} protobuf objects.
	 */
	public static class TxOutputValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TxOutput> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TxOutput proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Address

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for IsChange

	
	}
}

	/**
	 * Validates {@code BitcoinSpecific} protobuf objects.
	 */
	public static class BitcoinSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.BitcoinSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.BitcoinSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxInputsList(), item -> {
				
			// Validate tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxOutputsList(), item -> {
				
			// Validate tx_outputs
			if (true) index.validatorFor(item).assertValid(item);
			});

	
	}
}

	/**
	 * Validates {@code LitecoinSpecific} protobuf objects.
	 */
	public static class LitecoinSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.LitecoinSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.LitecoinSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxInputsList(), item -> {
				
			// Validate tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxOutputsList(), item -> {
				
			// Validate tx_outputs
			if (true) index.validatorFor(item).assertValid(item);
			});

	
	}
}

	/**
	 * Validates {@code BitcoincashSpecific} protobuf objects.
	 */
	public static class BitcoincashSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.BitcoincashSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.BitcoincashSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxInputsList(), item -> {
				
			// Validate tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxOutputsList(), item -> {
				
			// Validate tx_outputs
			if (true) index.validatorFor(item).assertValid(item);
			});

	
	}
}

	/**
	 * Validates {@code EthereumSpecific} protobuf objects.
	 */
	public static class EthereumSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.EthereumSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.EthereumSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	
	}
}

	/**
	 * Validates {@code XrpSpecific} protobuf objects.
	 */
	public static class XrpSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.XrpSpecific> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.XrpSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for SequenceNumber

	// no validation rules for DestinationTag

	// no validation rules for TxType

	// no validation rules for IsNextSequenceNumber

	
	}
}

	/**
	 * Validates {@code TronSpecific} protobuf objects.
	 */
	public static class TronSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TronSpecific> {
		
	
	

	public void assertValid(adamant.global.v1.Model.TronSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Expiration

	
	}
}

	/**
	 * Validates {@code C0BanSpecific} protobuf objects.
	 */
	public static class C0BanSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.C0banSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.C0banSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxInputsList(), item -> {
				
			// Validate tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxOutputsList(), item -> {
				
			// Validate tx_outputs
			if (true) index.validatorFor(item).assertValid(item);
			});

	
	}
}

	/**
	 * Validates {@code StellarSpecific} protobuf objects.
	 */
	public static class StellarSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.StellarSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.StellarSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for SequenceNumber

	// no validation rules for MemoId

	// no validation rules for IsNextSequenceNumber

	
	}
}

	/**
	 * Validates {@code SignInfo} protobuf objects.
	 */
	public static class SignInfoValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.SignInfo> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.SignInfo proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for KeyId

	// no validation rules for HdAccount

	// no validation rules for Coin

	// no validation rules for TxId

	// no validation rules for SignIndex

	// no validation rules for SignMessage

	// no validation rules for HdChange

	// no validation rules for HdIndex

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getSignTxInputsList(), item -> {
				
			// Validate sign_tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});

	
	}
}

	/**
	 * Validates {@code SignTxInput} protobuf objects.
	 */
	public static class SignTxInputValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.SignTxInput> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.SignTxInput proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TxInputIndex

	// no validation rules for SignMessage

	// no validation rules for HdChange

	// no validation rules for HdIndex

	
	}
}

	/**
	 * Validates {@code Transfer} protobuf objects.
	 */
	public static class TransferValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Transfer> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Transfer proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for TransferId

	// no validation rules for Coin

	// no validation rules for TxId

	// no validation rules for TransferType

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for JpyRate

	// no validation rules for PartnerWalletId

	// no validation rules for PartnerAddress

	// no validation rules for DestinationTag

	// no validation rules for MemoId

	// no validation rules for State

	// no validation rules for Result

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}

	/**
	 * Validates {@code Rate} protobuf objects.
	 */
	public static class RateValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Rate> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Rate proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Coin

	// no validation rules for Jpy

	
	}
}

	/**
	 * Validates {@code RateSnapshot} protobuf objects.
	 */
	public static class RateSnapshotValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.RateSnapshot> {
		
	
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.RateSnapshot proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for RateSnapshotId

	
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getRatesMap().keySet(), key -> {
				// no validation rules for Rates

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getRatesMap().values(), value -> {
				
			// Validate rates
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}

	/**
	 * Validates {@code Deactivatability} protobuf objects.
	 */
	public static class DeactivatabilityValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Deactivatability> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Deactivatability proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for AccountId

	// no validation rules for Deactivatable

	
	}
}

	/**
	 * Validates {@code LabeledAddress} protobuf objects.
	 */
	public static class LabeledAddressValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.LabeledAddress> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.LabeledAddress proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for LabeledAddressId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Address

	
			// Validate proposal
			if (proto.hasProposal()) index.validatorFor(proto.getProposal()).assertValid(proto.getProposal());
	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}

	/**
	 * Validates {@code LabeledAddressProposal} protobuf objects.
	 */
	public static class LabeledAddressProposalValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.LabeledAddressProposal> {
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.LabeledAddressProposal proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	// no validation rules for ProposedAddress

	// no validation rules for AddressIsReviewed

	
	}
}

	/**
	 * Validates {@code Whitelist} protobuf objects.
	 */
	public static class WhitelistValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Whitelist> {
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Whitelist proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WhitelistId

	// no validation rules for Name

	// no validation rules for Coin

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getAddressesList(), item -> {
				
			// Validate addresses
			if (true) index.validatorFor(item).assertValid(item);
			});

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}

	/**
	 * Validates {@code TransferLimit} protobuf objects.
	 */
	public static class TransferLimitValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TransferLimit> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TransferLimit proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TransferLimitId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for HourlyLimit

	// no validation rules for DailyLimit

	// no validation rules for OneTimeLimit

	
			// Validate proposal
			if (proto.hasProposal()) index.validatorFor(proto.getProposal()).assertValid(proto.getProposal());
	// no validation rules for IsReviewed

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}

	/**
	 * Validates {@code TransferLimitProposal} protobuf objects.
	 */
	public static class TransferLimitProposalValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TransferLimitProposal> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TransferLimitProposal proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	// no validation rules for ProposedHourlyLimit

	// no validation rules for ProposedDailyLimit

	// no validation rules for ProposedOneTimeLimit

	// no validation rules for IsReviewed

	
	}
}

	/**
	 * Validates {@code Policy} protobuf objects.
	 */
	public static class PolicyValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Policy> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Policy proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for PolicyId

	// no validation rules for PolicyType

	// no validation rules for Name

	// no validation rules for IsBasePolicy

	// no validation rules for Coin

	
			// Validate whitelist
			if (proto.hasWhitelist()) index.validatorFor(proto.getWhitelist()).assertValid(proto.getWhitelist());
	
			// Validate transfer_limit
			if (proto.hasTransferLimit()) index.validatorFor(proto.getTransferLimit()).assertValid(proto.getTransferLimit());
	
			// Validate proposal
			if (proto.hasProposal()) index.validatorFor(proto.getProposal()).assertValid(proto.getProposal());
	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}

	/**
	 * Validates {@code PolicyProposal} protobuf objects.
	 */
	public static class PolicyProposalValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.PolicyProposal> {
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.PolicyProposal proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	
			// Validate proposed_whitelist
			if (proto.hasProposedWhitelist()) index.validatorFor(proto.getProposedWhitelist()).assertValid(proto.getProposedWhitelist());
	// no validation rules for IsReviewed

	
	}
}

	/**
	 * Validates {@code TotalBalanceByCoin} protobuf objects.
	 */
	public static class TotalBalanceByCoinValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TotalBalanceByCoin> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TotalBalanceByCoin proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Coin

	// no validation rules for ColdStringBalance

	// no validation rules for HotStringBalance

	
	}
}

	/**
	 * Validates {@code TotalBalance} protobuf objects.
	 */
	public static class TotalBalanceValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TotalBalance> {
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.TotalBalance proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.MapValidation.noSparse(".adamant.global.v1.TotalBalance.total_balances", proto.getTotalBalancesMap());
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTotalBalancesMap().keySet(), key -> {
				// no validation rules for TotalBalances

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTotalBalancesMap().values(), value -> {
				
			// Validate total_balances
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}

	/**
	 * Validates {@code BalanceSnapshot} protobuf objects.
	 */
	public static class BalanceSnapshotValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.BalanceSnapshot> {
		
	
		
		
		
	
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.BalanceSnapshot proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			io.envoyproxy.pgv.MapValidation.noSparse(".adamant.global.v1.BalanceSnapshot.total_balances", proto.getTotalBalancesMap());
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTotalBalancesMap().keySet(), key -> {
				// no validation rules for TotalBalances

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTotalBalancesMap().values(), value -> {
				
			// Validate total_balances
			if (true) index.validatorFor(value).assertValid(value);
			});
	
			io.envoyproxy.pgv.MapValidation.noSparse(".adamant.global.v1.BalanceSnapshot.rates", proto.getRatesMap());
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getRatesMap().keySet(), key -> {
				// no validation rules for Rates

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getRatesMap().values(), value -> {
				
			// Validate rates
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}

	/**
	 * Validates {@code WalletBalanceSnapshotMap} protobuf objects.
	 */
	public static class WalletBalanceSnapshotMapValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletBalanceSnapshotMap> {
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletBalanceSnapshotMap proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.MapValidation.noSparse(".adamant.global.v1.WalletBalanceSnapshotMap.wallet_balance_snapshot_map", proto.getWalletBalanceSnapshotMapMap());
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getWalletBalanceSnapshotMapMap().keySet(), key -> {
				// no validation rules for WalletBalanceSnapshotMap

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getWalletBalanceSnapshotMapMap().values(), value -> {
				
			// Validate wallet_balance_snapshot_map
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}

	/**
	 * Validates {@code ListWalletBalanceSnapshots} protobuf objects.
	 */
	public static class ListWalletBalanceSnapshotsValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.ListWalletBalanceSnapshots> {
		
	
	

	public void assertValid(adamant.global.v1.Model.ListWalletBalanceSnapshots proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getWalletBalanceSnapshotsList(), item -> {
				
			// Validate wallet_balance_snapshots
			if (true) index.validatorFor(item).assertValid(item);
			});

	
	}
}

	/**
	 * Validates {@code WalletBalanceSnapshot} protobuf objects.
	 */
	public static class WalletBalanceSnapshotValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletBalanceSnapshot> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletBalanceSnapshot proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	// no validation rules for StringBalance

	// no validation rules for Jpy

	
	}
}

	/**
	 * Validates {@code TransferVolumeSnapshots} protobuf objects.
	 */
	public static class TransferVolumeSnapshotsValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TransferVolumeSnapshots> {
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.TransferVolumeSnapshots proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.MapValidation.noSparse(".adamant.global.v1.TransferVolumeSnapshots.transfer_volume_snapshot_by_transfer_type", proto.getTransferVolumeSnapshotByTransferTypeMap());
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTransferVolumeSnapshotByTransferTypeMap().keySet(), key -> {
				// no validation rules for TransferVolumeSnapshotByTransferType

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTransferVolumeSnapshotByTransferTypeMap().values(), value -> {
				
			// Validate transfer_volume_snapshot_by_transfer_type
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}

	/**
	 * Validates {@code ListTransferVolumeSnapshots} protobuf objects.
	 */
	public static class ListTransferVolumeSnapshotsValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.ListTransferVolumeSnapshots> {
		
	
	

	public void assertValid(adamant.global.v1.Model.ListTransferVolumeSnapshots proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTransferVolumeSnapshotsList(), item -> {
				
			// Validate transfer_volume_snapshots
			if (true) index.validatorFor(item).assertValid(item);
			});

	
	}
}

	/**
	 * Validates {@code TransferVolumeSnapshot} protobuf objects.
	 */
	public static class TransferVolumeSnapshotValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TransferVolumeSnapshot> {
		
	
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.TransferVolumeSnapshot proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			// Validate target_time
			if (proto.hasTargetTime()) index.validatorFor(proto.getTargetTime()).assertValid(proto.getTargetTime());
	
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTransferVolumeByCoinMap().keySet(), key -> {
				// no validation rules for TransferVolumeByCoin

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTransferVolumeByCoinMap().values(), value -> {
				
			// Validate transfer_volume_by_coin
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}

	/**
	 * Validates {@code TransferVolume} protobuf objects.
	 */
	public static class TransferVolumeValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TransferVolume> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TransferVolume proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Coin

	// no validation rules for HotStringVolume

	// no validation rules for ColdStringVolume

	// no validation rules for HotStringJpyVolume

	// no validation rules for ColdStringJpyVolume

	// no validation rules for HotNumber

	// no validation rules for ColdNumber

	// no validation rules for TransferType

	
	}
}

	/**
	 * Validates {@code WalletTransferVolumeSnapshots} protobuf objects.
	 */
	public static class WalletTransferVolumeSnapshotsValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletTransferVolumeSnapshots> {
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletTransferVolumeSnapshots proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.MapValidation.noSparse(".adamant.global.v1.WalletTransferVolumeSnapshots.wallet_transfer_volume_snapshot_by_wallet_id", proto.getWalletTransferVolumeSnapshotByWalletIdMap());
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getWalletTransferVolumeSnapshotByWalletIdMap().keySet(), key -> {
				// no validation rules for WalletTransferVolumeSnapshotByWalletId

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getWalletTransferVolumeSnapshotByWalletIdMap().values(), value -> {
				
			// Validate wallet_transfer_volume_snapshot_by_wallet_id
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}

	/**
	 * Validates {@code ListWalletTransferVolumeSnapshots} protobuf objects.
	 */
	public static class ListWalletTransferVolumeSnapshotsValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.ListWalletTransferVolumeSnapshots> {
		
	
	

	public void assertValid(adamant.global.v1.Model.ListWalletTransferVolumeSnapshots proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getWalletTransferVolumeSnapshotsList(), item -> {
				
			// Validate wallet_transfer_volume_snapshots
			if (true) index.validatorFor(item).assertValid(item);
			});

	
	}
}

	/**
	 * Validates {@code WalletTransferVolumeSnapshot} protobuf objects.
	 */
	public static class WalletTransferVolumeSnapshotValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletTransferVolumeSnapshot> {
		
	
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletTransferVolumeSnapshot proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			// Validate target_time
			if (proto.hasTargetTime()) index.validatorFor(proto.getTargetTime()).assertValid(proto.getTargetTime());
	
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getWalletTransferVolumeByTransferTypeMap().keySet(), key -> {
				// no validation rules for WalletTransferVolumeByTransferType

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getWalletTransferVolumeByTransferTypeMap().values(), value -> {
				
			// Validate wallet_transfer_volume_by_transfer_type
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}

	/**
	 * Validates {@code WalletTransferVolume} protobuf objects.
	 */
	public static class WalletTransferVolumeValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletTransferVolume> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletTransferVolume proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for StringVolume

	// no validation rules for StringJpyVolume

	// no validation rules for Number

	// no validation rules for TransferType

	
	}
}

	/**
	 * Validates {@code Confirmation} protobuf objects.
	 */
	public static class ConfirmationValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Confirmation> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Confirmation proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Coin

	// no validation rules for Confirmation

	
	}
}

	/**
	 * Validates {@code WalletFlushSetting} protobuf objects.
	 */
	public static class WalletFlushSettingValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletFlushSetting> {
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletFlushSetting proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for OwnerId

	// no validation rules for Coin

	// no validation rules for DestinationWalletId

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}

	/**
	 * Validates {@code CompensationFee} protobuf objects.
	 */
	public static class CompensationFeeValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CompensationFee> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CompensationFee proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for StringValue

	// no validation rules for IsSpent

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
	}
}

	/**
	 * Validates {@code RequestTxOutput} protobuf objects.
	 */
	public static class RequestTxOutputValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.RequestTxOutput> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.RequestTxOutput proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.StringValidation.minLength(".adamant.global.v1.RequestTxOutput.address", proto.getAddress(), 3);
	
			io.envoyproxy.pgv.StringValidation.minLength(".adamant.global.v1.RequestTxOutput.string_value", proto.getStringValue(), 1);
	
	}
}

	/**
	 * Validates {@code RequestSignedInfo} protobuf objects.
	 */
	public static class RequestSignedInfoValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.RequestSignedInfo> {
		
	
	

	public void assertValid(adamant.global.v1.Model.RequestSignedInfo proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.minItems(".adamant.global.v1.RequestSignedInfo.signatures", proto.getSignaturesList(), 1);
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getSignaturesList(), item -> {
				
			// Validate signatures
			if (true) index.validatorFor(item).assertValid(item);
			});

	
	}
}

	/**
	 * Validates {@code RequestSignature} protobuf objects.
	 */
	public static class RequestSignatureValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.RequestSignature> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.RequestSignature proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for SignIndex

	
			io.envoyproxy.pgv.StringValidation.minLength(".adamant.global.v1.RequestSignature.signature", proto.getSignature(), 1);
	
	}
}

	/**
	 * Validates {@code RequestTransferLimitEntry} protobuf objects.
	 */
	public static class RequestTransferLimitEntryValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.RequestTransferLimitEntry> {
		
		private final adamant.global.v1.Enum.TransferLimitType[] TRANSFER_LIMIT_TYPE__NOT_IN = new adamant.global.v1.Enum.TransferLimitType[]{
			adamant.global.v1.Enum.TransferLimitType.forNumber(0),
		};
	
		
		private final Long TRANSFER_LIMIT_VALUE__GTE = 0L;
	
	

	public void assertValid(adamant.global.v1.Model.RequestTransferLimitEntry proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.EnumValidation.definedOnly(".adamant.global.v1.RequestTransferLimitEntry.transfer_limit_type", proto.getTransferLimitType());
			io.envoyproxy.pgv.CollectiveValidation.notIn(".adamant.global.v1.RequestTransferLimitEntry.transfer_limit_type", proto.getTransferLimitType(), TRANSFER_LIMIT_TYPE__NOT_IN);
	
			io.envoyproxy.pgv.ComparativeValidation.greaterThanOrEqual(".adamant.global.v1.RequestTransferLimitEntry.transfer_limit_value", proto.getTransferLimitValue(), TRANSFER_LIMIT_VALUE__GTE, java.util.Comparator.naturalOrder());
	
	}
}

	/**
	 * Validates {@code RequestRate} protobuf objects.
	 */
	public static class RequestRateValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.RequestRate> {
		
		private final gincoinc.global.v1.Enum.Coin[] COIN__NOT_IN = new gincoinc.global.v1.Enum.Coin[]{
			gincoinc.global.v1.Enum.Coin.forNumber(0),
		};
	
		
		private final Double JPY__GTE = 0D;
	
	

	public void assertValid(adamant.global.v1.Model.RequestRate proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.EnumValidation.definedOnly(".adamant.global.v1.RequestRate.coin", proto.getCoin());
			io.envoyproxy.pgv.CollectiveValidation.notIn(".adamant.global.v1.RequestRate.coin", proto.getCoin(), COIN__NOT_IN);
	
			io.envoyproxy.pgv.ComparativeValidation.greaterThanOrEqual(".adamant.global.v1.RequestRate.jpy", proto.getJpy(), JPY__GTE, java.util.Comparator.naturalOrder());
	
	}
}

}

