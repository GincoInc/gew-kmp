// Code generated by protoc-gen-validate. DO NOT EDIT.
// source: gincoinc/adamant/global/v1/adamantglobalv1/model.proto

package adamant.global.v1;


@SuppressWarnings("all")
public class ModelValidator {
	public static io.envoyproxy.pgv.ValidatorImpl validatorFor(Class clazz) {
		
		if (clazz.equals(adamant.global.v1.Model.Wallet.class)) return new WalletValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletWithoutBalance.class)) return new WalletWithoutBalanceValidator();
		if (clazz.equals(adamant.global.v1.Model.StakingWallet.class)) return new StakingWalletValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletProposal.class)) return new WalletProposalValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletMember.class)) return new WalletMemberValidator();
		if (clazz.equals(adamant.global.v1.Model.Key.class)) return new KeyValidator();
		if (clazz.equals(adamant.global.v1.Model.Address.class)) return new AddressValidator();
		if (clazz.equals(adamant.global.v1.Model.AddressWithoutBalance.class)) return new AddressWithoutBalanceValidator();
		if (clazz.equals(adamant.global.v1.Model.FlushedAddress.class)) return new FlushedAddressValidator();
		if (clazz.equals(adamant.global.v1.Model.EthereumFeeAddress.class)) return new EthereumFeeAddressValidator();
		if (clazz.equals(adamant.global.v1.Model.AddressWithBalance.class)) return new AddressWithBalanceValidator();
		if (clazz.equals(adamant.global.v1.Model.Transaction.class)) return new TransactionValidator();
		if (clazz.equals(adamant.global.v1.Model.UnconfirmedTransaction.class)) return new UnconfirmedTransactionValidator();
		if (clazz.equals(adamant.global.v1.Model.TransactionMember.class)) return new TransactionMemberValidator();
		if (clazz.equals(adamant.global.v1.Model.TxInput.class)) return new TxInputValidator();
		if (clazz.equals(adamant.global.v1.Model.TxOutput.class)) return new TxOutputValidator();
		if (clazz.equals(adamant.global.v1.Model.UTXO.class)) return new UTXOValidator();
		if (clazz.equals(adamant.global.v1.Model.CardanoUTXOSpecific.class)) return new CardanoUTXOSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.AvalanchePlatformChainUTXOSpecific.class)) return new AvalanchePlatformChainUTXOSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CardanoCustomToken.class)) return new CardanoCustomTokenValidator();
		if (clazz.equals(adamant.global.v1.Model.BitcoinSpecific.class)) return new BitcoinSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.LitecoinSpecific.class)) return new LitecoinSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.DogecoinSpecific.class)) return new DogecoinSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.BitcoincashSpecific.class)) return new BitcoincashSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.EthereumSpecific.class)) return new EthereumSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.XrpSpecific.class)) return new XrpSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.TronSpecific.class)) return new TronSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.C0banSpecific.class)) return new C0BanSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.StellarSpecific.class)) return new StellarSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CardanoSpecific.class)) return new CardanoSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.SubstrateSpecific.class)) return new SubstrateSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.MonacoinSpecific.class)) return new MonacoinSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.NemSpecific.class)) return new NemSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.IOSTSpecific.class)) return new IOSTSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.PolygonSpecific.class)) return new PolygonSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.KlaytnSpecific.class)) return new KlaytnSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.SymbolSpecific.class)) return new SymbolSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.AvalancheSpecific.class)) return new AvalancheSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.OasysSpecific.class)) return new OasysSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.XdcSpecific.class)) return new XdcSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CosmosSpecific.class)) return new CosmosSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.EthereumClassicSpecific.class)) return new EthereumClassicSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.AlgorandSpecific.class)) return new AlgorandSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.HederaSpecific.class)) return new HederaSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.JapanOpenChainSpecific.class)) return new JapanOpenChainSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.SolanaSpecific.class)) return new SolanaSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.AptosSpecific.class)) return new AptosSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.BNBSmartChainSpecific.class)) return new BNBSmartChainSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.FlareSpecific.class)) return new FlareSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.ArbitrumOneSpecific.class)) return new ArbitrumOneSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.AtomicTx.class)) return new AtomicTxValidator();
		if (clazz.equals(adamant.global.v1.Model.AvalanchePlatformChainSpecific.class)) return new AvalanchePlatformChainSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.AvalancheTxInput.class)) return new AvalancheTxInputValidator();
		if (clazz.equals(adamant.global.v1.Model.AvalancheTxOutput.class)) return new AvalancheTxOutputValidator();
		if (clazz.equals(adamant.global.v1.Model.CreateTransactionSubstrateSpecific.class)) return new CreateTransactionSubstrateSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CreateTransactionWalletConnectSpecific.class)) return new CreateTransactionWalletConnectSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CreateTransactionNemSpecific.class)) return new CreateTransactionNemSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CreateTransactionIOSTSpecific.class)) return new CreateTransactionIOSTSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CreateTransactionSymbolSpecific.class)) return new CreateTransactionSymbolSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CreateTransactionEthereumSpecific.class)) return new CreateTransactionEthereumSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CreateTransactionCosmosSpecific.class)) return new CreateTransactionCosmosSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CreateTransactionAlgorandSpecific.class)) return new CreateTransactionAlgorandSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CreateTransactionHederaSpecific.class)) return new CreateTransactionHederaSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CreateTransactionSolanaSpecific.class)) return new CreateTransactionSolanaSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CreateTransactionAptosSpecific.class)) return new CreateTransactionAptosSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.CreateTransactionAvalancheSpecific.class)) return new CreateTransactionAvalancheSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.ImportTxSpecific.class)) return new ImportTxSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.StakingSpecific.class)) return new StakingSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.SelectedUTXO.class)) return new SelectedUTXOValidator();
		if (clazz.equals(adamant.global.v1.Model.SubstrateMultisigTransaction.class)) return new SubstrateMultisigTransactionValidator();
		if (clazz.equals(adamant.global.v1.Model.NemMultisigTransaction.class)) return new NemMultisigTransactionValidator();
		if (clazz.equals(adamant.global.v1.Model.SymbolMultisigTransaction.class)) return new SymbolMultisigTransactionValidator();
		if (clazz.equals(adamant.global.v1.Model.SignInfo.class)) return new SignInfoValidator();
		if (clazz.equals(adamant.global.v1.Model.SignTxInput.class)) return new SignTxInputValidator();
		if (clazz.equals(adamant.global.v1.Model.Transfer.class)) return new TransferValidator();
		if (clazz.equals(adamant.global.v1.Model.TransferCosmosSpecific.class)) return new TransferCosmosSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.UncheckedTransfer.class)) return new UncheckedTransferValidator();
		if (clazz.equals(adamant.global.v1.Model.EventTriggeredMessage.class)) return new EventTriggeredMessageValidator();
		if (clazz.equals(adamant.global.v1.Model.Rate.class)) return new RateValidator();
		if (clazz.equals(adamant.global.v1.Model.RateSnapshot.class)) return new RateSnapshotValidator();
		if (clazz.equals(adamant.global.v1.Model.Deactivatability.class)) return new DeactivatabilityValidator();
		if (clazz.equals(adamant.global.v1.Model.LabeledAddress.class)) return new LabeledAddressValidator();
		if (clazz.equals(adamant.global.v1.Model.LabeledAddressProposal.class)) return new LabeledAddressProposalValidator();
		if (clazz.equals(adamant.global.v1.Model.Whitelist.class)) return new WhitelistValidator();
		if (clazz.equals(adamant.global.v1.Model.TransferLimit.class)) return new TransferLimitValidator();
		if (clazz.equals(adamant.global.v1.Model.TransferLimitProposal.class)) return new TransferLimitProposalValidator();
		if (clazz.equals(adamant.global.v1.Model.Policy.class)) return new PolicyValidator();
		if (clazz.equals(adamant.global.v1.Model.PolicyProposal.class)) return new PolicyProposalValidator();
		if (clazz.equals(adamant.global.v1.Model.TotalBalanceByCoin.class)) return new TotalBalanceByCoinValidator();
		if (clazz.equals(adamant.global.v1.Model.TotalBalance.class)) return new TotalBalanceValidator();
		if (clazz.equals(adamant.global.v1.Model.BalanceSnapshot.class)) return new BalanceSnapshotValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletBalanceSnapshotMap.class)) return new WalletBalanceSnapshotMapValidator();
		if (clazz.equals(adamant.global.v1.Model.ListWalletBalanceSnapshots.class)) return new ListWalletBalanceSnapshotsValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletBalanceSnapshot.class)) return new WalletBalanceSnapshotValidator();
		if (clazz.equals(adamant.global.v1.Model.TransferVolumeSnapshots.class)) return new TransferVolumeSnapshotsValidator();
		if (clazz.equals(adamant.global.v1.Model.ListTransferVolumeSnapshots.class)) return new ListTransferVolumeSnapshotsValidator();
		if (clazz.equals(adamant.global.v1.Model.TransferVolumeSnapshot.class)) return new TransferVolumeSnapshotValidator();
		if (clazz.equals(adamant.global.v1.Model.TransferVolume.class)) return new TransferVolumeValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletTransferVolumeSnapshots.class)) return new WalletTransferVolumeSnapshotsValidator();
		if (clazz.equals(adamant.global.v1.Model.ListWalletTransferVolumeSnapshots.class)) return new ListWalletTransferVolumeSnapshotsValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletTransferVolumeSnapshot.class)) return new WalletTransferVolumeSnapshotValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletTransferVolume.class)) return new WalletTransferVolumeValidator();
		if (clazz.equals(adamant.global.v1.Model.Confirmation.class)) return new ConfirmationValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletFlushSetting.class)) return new WalletFlushSettingValidator();
		if (clazz.equals(adamant.global.v1.Model.CompensationFee.class)) return new CompensationFeeValidator();
		if (clazz.equals(adamant.global.v1.Model.WalletGroup.class)) return new WalletGroupValidator();
		if (clazz.equals(adamant.global.v1.Model.RequestTxOutput.class)) return new RequestTxOutputValidator();
		if (clazz.equals(adamant.global.v1.Model.RequestSignedInfo.class)) return new RequestSignedInfoValidator();
		if (clazz.equals(adamant.global.v1.Model.RequestSignature.class)) return new RequestSignatureValidator();
		if (clazz.equals(adamant.global.v1.Model.RequestTransferLimitEntry.class)) return new RequestTransferLimitEntryValidator();
		if (clazz.equals(adamant.global.v1.Model.RequestRate.class)) return new RequestRateValidator();
		if (clazz.equals(adamant.global.v1.Model.SubstrateChildAddress.class)) return new SubstrateChildAddressValidator();
		if (clazz.equals(adamant.global.v1.Model.SymbolChildAddress.class)) return new SymbolChildAddressValidator();
		if (clazz.equals(adamant.global.v1.Model.IOSTChildAccount.class)) return new IOSTChildAccountValidator();
		if (clazz.equals(adamant.global.v1.Model.IOSTCallerAccount.class)) return new IOSTCallerAccountValidator();
		if (clazz.equals(adamant.global.v1.Model.CallerAddress.class)) return new CallerAddressValidator();
		if (clazz.equals(adamant.global.v1.Model.FeeDepositAddress.class)) return new FeeDepositAddressValidator();
		if (clazz.equals(adamant.global.v1.Model.CosmosDelegation.class)) return new CosmosDelegationValidator();
		if (clazz.equals(adamant.global.v1.Model.StakingHistory.class)) return new StakingHistoryValidator();
		if (clazz.equals(adamant.global.v1.Model.StakingHistoryEthereumSpecific.class)) return new StakingHistoryEthereumSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.StakingHistoryAvalancheSpecific.class)) return new StakingHistoryAvalancheSpecificValidator();
		if (clazz.equals(adamant.global.v1.Model.StakingValidator.class)) return new StakingValidatorValidator();
		return null;
	}


/**
	 * Validates {@code Wallet} protobuf objects.
	 */
	public static class WalletValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Wallet> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Wallet proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for HdAccount

	// no validation rules for WalletType

	// no validation rules for AddressType

	// no validation rules for M

	// no validation rules for N

	// no validation rules for State

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getKeysList(), item -> {
				
			// Validate keys
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getMembersList(), item -> {
				
			// Validate members
			if (true) index.validatorFor(item).assertValid(item);
			});
	// no validation rules for RequiredApprovalCount

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for Address

	// no validation rules for PolicyId

	
			// Validate proposal
			if (proto.hasProposal()) index.validatorFor(proto.getProposal()).assertValid(proto.getProposal());
	// no validation rules for DestinationWalletId

	// no validation rules for WatchOnly

	// no validation rules for AddressNumber

	// no validation rules for ShouldCheckRemittance

	// no validation rules for InheritWalletId

	// no validation rules for IsStakingAvailable

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code WalletWithoutBalance} protobuf objects.
	 */
	public static class WalletWithoutBalanceValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletWithoutBalance> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletWithoutBalance proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for HdAccount

	// no validation rules for WalletType

	// no validation rules for AddressType

	// no validation rules for M

	// no validation rules for N

	// no validation rules for State

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getKeysList(), item -> {
				
			// Validate keys
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getMembersList(), item -> {
				
			// Validate members
			if (true) index.validatorFor(item).assertValid(item);
			});
	// no validation rules for RequiredApprovalCount

	// no validation rules for Address

	// no validation rules for PolicyId

	
			// Validate proposal
			if (proto.hasProposal()) index.validatorFor(proto.getProposal()).assertValid(proto.getProposal());
	// no validation rules for DestinationWalletId

	// no validation rules for WatchOnly

	// no validation rules for ShouldCheckRemittance

	// no validation rules for InheritWalletId

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code StakingWallet} protobuf objects.
	 */
	public static class StakingWalletValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.StakingWallet> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.StakingWallet proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for WalletType

	// no validation rules for AddressType

	// no validation rules for State

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for SpendableBalance

	// no validation rules for StringSpendableBalance

	// no validation rules for StakingBalance

	// no validation rules for StringStakingBalance

	// no validation rules for ClaimableRewardBalance

	// no validation rules for StringClaimableRewardBalance

	// no validation rules for WithdrawableUnstakedBalance

	// no validation rules for StringWithdrawableUnstakedBalance

	// no validation rules for FrozenUnstakedBalance

	// no validation rules for StringFrozenUnstakedBalance

	// no validation rules for Address

	// no validation rules for ActiveValidatorsCount

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code WalletProposal} protobuf objects.
	 */
	public static class WalletProposalValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletProposal> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletProposal proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for ProposalType

	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	// no validation rules for ProposedPolicy

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getProposedValidatorsList(), item -> {
				// no validation rules for ProposedValidators

			});
	// no validation rules for ProposedRequiredApprovalCount

	// no validation rules for IsReviewed

	
	}
}
/**
	 * Validates {@code WalletMember} protobuf objects.
	 */
	public static class WalletMemberValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletMember> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletMember proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for Name

	// no validation rules for Email

	// no validation rules for Role

	// no validation rules for IsKeyRegistered

	// no validation rules for IsMaster

	// no validation rules for IsValidatedToCreateWallet

	
	}
}
/**
	 * Validates {@code Key} protobuf objects.
	 */
	public static class KeyValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Key> {
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Key proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for KeyId

	// no validation rules for KeyIndex

	// no validation rules for HdIndex

	
	}
}
/**
	 * Validates {@code Address} protobuf objects.
	 */
	public static class AddressValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Address> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Address proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for AddressId

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for Address

	// no validation rules for Index

	// no validation rules for HdChange

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for State

	// no validation rules for AddressType

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code AddressWithoutBalance} protobuf objects.
	 */
	public static class AddressWithoutBalanceValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.AddressWithoutBalance> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.AddressWithoutBalance proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for AddressId

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for Address

	// no validation rules for Index

	// no validation rules for HdChange

	// no validation rules for State

	// no validation rules for AddressType

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code FlushedAddress} protobuf objects.
	 */
	public static class FlushedAddressValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.FlushedAddress> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.FlushedAddress proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for AddressId

	// no validation rules for Coin

	// no validation rules for Address

	// no validation rules for Index

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for State

	// no validation rules for AddressType

	
	}
}
/**
	 * Validates {@code EthereumFeeAddress} protobuf objects.
	 */
	public static class EthereumFeeAddressValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.EthereumFeeAddress> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.EthereumFeeAddress proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	
	}
}
/**
	 * Validates {@code AddressWithBalance} protobuf objects.
	 */
	public static class AddressWithBalanceValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.AddressWithBalance> {
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.AddressWithBalance proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for FeeBalance

	// no validation rules for StringFeeBalance

	
	}
}
/**
	 * Validates {@code Transaction} protobuf objects.
	 */
	public static class TransactionValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Transaction> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Transaction proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for TxId

	// no validation rules for Address

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for JpyRate

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for FeeRate

	// no validation rules for State

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getSignedKeysList(), item -> {
				
			// Validate signed_keys
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getMembersList(), item -> {
				
			// Validate members
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			// Validate bitcoin_specific
			if (proto.hasBitcoinSpecific()) index.validatorFor(proto.getBitcoinSpecific()).assertValid(proto.getBitcoinSpecific());
	
			// Validate ethereum_specific
			if (proto.hasEthereumSpecific()) index.validatorFor(proto.getEthereumSpecific()).assertValid(proto.getEthereumSpecific());
	
			// Validate litecoin_specific
			if (proto.hasLitecoinSpecific()) index.validatorFor(proto.getLitecoinSpecific()).assertValid(proto.getLitecoinSpecific());
	
			// Validate bitcoincash_specific
			if (proto.hasBitcoincashSpecific()) index.validatorFor(proto.getBitcoincashSpecific()).assertValid(proto.getBitcoincashSpecific());
	
			// Validate xrp_specific
			if (proto.hasXrpSpecific()) index.validatorFor(proto.getXrpSpecific()).assertValid(proto.getXrpSpecific());
	
			// Validate tron_specific
			if (proto.hasTronSpecific()) index.validatorFor(proto.getTronSpecific()).assertValid(proto.getTronSpecific());
	
			// Validate c0ban_specific
			if (proto.hasC0BanSpecific()) index.validatorFor(proto.getC0BanSpecific()).assertValid(proto.getC0BanSpecific());
	
			// Validate stellar_specific
			if (proto.hasStellarSpecific()) index.validatorFor(proto.getStellarSpecific()).assertValid(proto.getStellarSpecific());
	
			// Validate cardano_specific
			if (proto.hasCardanoSpecific()) index.validatorFor(proto.getCardanoSpecific()).assertValid(proto.getCardanoSpecific());
	
			// Validate substrate_specific
			if (proto.hasSubstrateSpecific()) index.validatorFor(proto.getSubstrateSpecific()).assertValid(proto.getSubstrateSpecific());
	
			// Validate monacoin_specific
			if (proto.hasMonacoinSpecific()) index.validatorFor(proto.getMonacoinSpecific()).assertValid(proto.getMonacoinSpecific());
	
			// Validate nem_specific
			if (proto.hasNemSpecific()) index.validatorFor(proto.getNemSpecific()).assertValid(proto.getNemSpecific());
	
			// Validate iost_specific
			if (proto.hasIostSpecific()) index.validatorFor(proto.getIostSpecific()).assertValid(proto.getIostSpecific());
	
			// Validate polygon_specific
			if (proto.hasPolygonSpecific()) index.validatorFor(proto.getPolygonSpecific()).assertValid(proto.getPolygonSpecific());
	
			// Validate klaytn_specific
			if (proto.hasKlaytnSpecific()) index.validatorFor(proto.getKlaytnSpecific()).assertValid(proto.getKlaytnSpecific());
	
			// Validate symbol_specific
			if (proto.hasSymbolSpecific()) index.validatorFor(proto.getSymbolSpecific()).assertValid(proto.getSymbolSpecific());
	
			// Validate avalanche_specific
			if (proto.hasAvalancheSpecific()) index.validatorFor(proto.getAvalancheSpecific()).assertValid(proto.getAvalancheSpecific());
	
			// Validate oasys_specific
			if (proto.hasOasysSpecific()) index.validatorFor(proto.getOasysSpecific()).assertValid(proto.getOasysSpecific());
	
			// Validate xdc_specific
			if (proto.hasXdcSpecific()) index.validatorFor(proto.getXdcSpecific()).assertValid(proto.getXdcSpecific());
	
			// Validate cosmos_specific
			if (proto.hasCosmosSpecific()) index.validatorFor(proto.getCosmosSpecific()).assertValid(proto.getCosmosSpecific());
	
			// Validate ethereum_classic_specific
			if (proto.hasEthereumClassicSpecific()) index.validatorFor(proto.getEthereumClassicSpecific()).assertValid(proto.getEthereumClassicSpecific());
	
			// Validate algorand_specific
			if (proto.hasAlgorandSpecific()) index.validatorFor(proto.getAlgorandSpecific()).assertValid(proto.getAlgorandSpecific());
	
			// Validate hedera_specific
			if (proto.hasHederaSpecific()) index.validatorFor(proto.getHederaSpecific()).assertValid(proto.getHederaSpecific());
	
			// Validate japan_open_chain_specific
			if (proto.hasJapanOpenChainSpecific()) index.validatorFor(proto.getJapanOpenChainSpecific()).assertValid(proto.getJapanOpenChainSpecific());
	
			// Validate solana_specific
			if (proto.hasSolanaSpecific()) index.validatorFor(proto.getSolanaSpecific()).assertValid(proto.getSolanaSpecific());
	
			// Validate bnb_smart_chain_specific
			if (proto.hasBnbSmartChainSpecific()) index.validatorFor(proto.getBnbSmartChainSpecific()).assertValid(proto.getBnbSmartChainSpecific());
	
			// Validate flare_specific
			if (proto.hasFlareSpecific()) index.validatorFor(proto.getFlareSpecific()).assertValid(proto.getFlareSpecific());
	
			// Validate arbitrum_one_specific
			if (proto.hasArbitrumOneSpecific()) index.validatorFor(proto.getArbitrumOneSpecific()).assertValid(proto.getArbitrumOneSpecific());
	
			// Validate aptos_specific
			if (proto.hasAptosSpecific()) index.validatorFor(proto.getAptosSpecific()).assertValid(proto.getAptosSpecific());
	
			// Validate dogecoin_specific
			if (proto.hasDogecoinSpecific()) index.validatorFor(proto.getDogecoinSpecific()).assertValid(proto.getDogecoinSpecific());
	
			// Validate avalanche_platform_chain_specific
			if (proto.hasAvalanchePlatformChainSpecific()) index.validatorFor(proto.getAvalanchePlatformChainSpecific()).assertValid(proto.getAvalanchePlatformChainSpecific());
	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code UnconfirmedTransaction} protobuf objects.
	 */
	public static class UnconfirmedTransactionValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.UnconfirmedTransaction> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.UnconfirmedTransaction proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for TxId

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for Address

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for FeeRate

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate bitcoin_specific
			if (proto.hasBitcoinSpecific()) index.validatorFor(proto.getBitcoinSpecific()).assertValid(proto.getBitcoinSpecific());
	
			// Validate litecoin_specific
			if (proto.hasLitecoinSpecific()) index.validatorFor(proto.getLitecoinSpecific()).assertValid(proto.getLitecoinSpecific());
	
			// Validate bitcoincash_specific
			if (proto.hasBitcoincashSpecific()) index.validatorFor(proto.getBitcoincashSpecific()).assertValid(proto.getBitcoincashSpecific());
	
			// Validate c0ban_specific
			if (proto.hasC0BanSpecific()) index.validatorFor(proto.getC0BanSpecific()).assertValid(proto.getC0BanSpecific());
	
			// Validate cardano_specific
			if (proto.hasCardanoSpecific()) index.validatorFor(proto.getCardanoSpecific()).assertValid(proto.getCardanoSpecific());
	
			// Validate monacoin_specific
			if (proto.hasMonacoinSpecific()) index.validatorFor(proto.getMonacoinSpecific()).assertValid(proto.getMonacoinSpecific());
	
			// Validate avalanche_platform_chain_specific
			if (proto.hasAvalanchePlatformChainSpecific()) index.validatorFor(proto.getAvalanchePlatformChainSpecific()).assertValid(proto.getAvalanchePlatformChainSpecific());
	
	}
}
/**
	 * Validates {@code TransactionMember} protobuf objects.
	 */
	public static class TransactionMemberValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TransactionMember> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TransactionMember proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for AccountId

	// no validation rules for AccountType

	// no validation rules for Name

	// no validation rules for Email

	// no validation rules for Role

	// no validation rules for Signed

	// no validation rules for Validated

	
	}
}
/**
	 * Validates {@code TxInput} protobuf objects.
	 */
	public static class TxInputValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TxInput> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TxInput proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TxId

	// no validation rules for TxIndex

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for TxInputIndex

	// no validation rules for Address

	// no validation rules for WitnessScript

	// no validation rules for NSequence

	
	}
}
/**
	 * Validates {@code TxOutput} protobuf objects.
	 */
	public static class TxOutputValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TxOutput> {
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TxOutput proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Address

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for IsChange

	// no validation rules for TxOutputIndex

	
	}
}
/**
	 * Validates {@code UTXO} protobuf objects.
	 */
	public static class UTXOValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.UTXO> {
		
	
		
	
		
	
		
	
		
	
		
		com.google.re2j.Pattern TRANSACTION_ID__PATTERN = com.google.re2j.Pattern.compile("^$|^[0-9a-f]{8}-[0-9a-f]{4}-4[0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}$");
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.UTXO proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TxId

	// no validation rules for Vout

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for Address

	
			io.envoyproxy.pgv.StringValidation.pattern(".adamant.global.v1.UTXO.transaction_id", proto.getTransactionId(), TRANSACTION_ID__PATTERN);
	
			// Validate cardano_specific
			if (proto.hasCardanoSpecific()) index.validatorFor(proto.getCardanoSpecific()).assertValid(proto.getCardanoSpecific());
	
			// Validate avalanche_platform_chain_specific
			if (proto.hasAvalanchePlatformChainSpecific()) index.validatorFor(proto.getAvalanchePlatformChainSpecific()).assertValid(proto.getAvalanchePlatformChainSpecific());
	
	}
}
/**
	 * Validates {@code CardanoUTXOSpecific} protobuf objects.
	 */
	public static class CardanoUTXOSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CardanoUTXOSpecific> {
		
	
	

	public void assertValid(adamant.global.v1.Model.CardanoUTXOSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTokensList(), item -> {
				
			// Validate tokens
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code AvalanchePlatformChainUTXOSpecific} protobuf objects.
	 */
	public static class AvalanchePlatformChainUTXOSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.AvalanchePlatformChainUTXOSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.AvalanchePlatformChainUTXOSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Threshold

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getAddressesList(), item -> {
				// no validation rules for Addresses

			});
	
	}
}
/**
	 * Validates {@code CardanoCustomToken} protobuf objects.
	 */
	public static class CardanoCustomTokenValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CardanoCustomToken> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CardanoCustomToken proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for PolicyId

	// no validation rules for AssetName

	// no validation rules for Value

	
	}
}
/**
	 * Validates {@code BitcoinSpecific} protobuf objects.
	 */
	public static class BitcoinSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.BitcoinSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.BitcoinSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxInputsList(), item -> {
				
			// Validate tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxOutputsList(), item -> {
				
			// Validate tx_outputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code LitecoinSpecific} protobuf objects.
	 */
	public static class LitecoinSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.LitecoinSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.LitecoinSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxInputsList(), item -> {
				
			// Validate tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxOutputsList(), item -> {
				
			// Validate tx_outputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code DogecoinSpecific} protobuf objects.
	 */
	public static class DogecoinSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.DogecoinSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.DogecoinSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxInputsList(), item -> {
				
			// Validate tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxOutputsList(), item -> {
				
			// Validate tx_outputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code BitcoincashSpecific} protobuf objects.
	 */
	public static class BitcoincashSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.BitcoincashSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.BitcoincashSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxInputsList(), item -> {
				
			// Validate tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxOutputsList(), item -> {
				
			// Validate tx_outputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code EthereumSpecific} protobuf objects.
	 */
	public static class EthereumSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.EthereumSpecific> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.EthereumSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	// no validation rules for MethodIdType

	// no validation rules for Expiration

	// no validation rules for Data

	// no validation rules for IsStakingTransaction

	
	}
}
/**
	 * Validates {@code XrpSpecific} protobuf objects.
	 */
	public static class XrpSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.XrpSpecific> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.XrpSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for SequenceNumber

	// no validation rules for DestinationTag

	// no validation rules for TxType

	// no validation rules for IsNextSequenceNumber

	
	}
}
/**
	 * Validates {@code TronSpecific} protobuf objects.
	 */
	public static class TronSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TronSpecific> {
		
	
	

	public void assertValid(adamant.global.v1.Model.TronSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Expiration

	
	}
}
/**
	 * Validates {@code C0BanSpecific} protobuf objects.
	 */
	public static class C0BanSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.C0banSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.C0banSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxInputsList(), item -> {
				
			// Validate tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxOutputsList(), item -> {
				
			// Validate tx_outputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code StellarSpecific} protobuf objects.
	 */
	public static class StellarSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.StellarSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.StellarSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for SequenceNumber

	// no validation rules for MemoId

	// no validation rules for IsNextSequenceNumber

	
	}
}
/**
	 * Validates {@code CardanoSpecific} protobuf objects.
	 */
	public static class CardanoSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CardanoSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CardanoSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxInputsList(), item -> {
				
			// Validate tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxOutputsList(), item -> {
				
			// Validate tx_outputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code SubstrateSpecific} protobuf objects.
	 */
	public static class SubstrateSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.SubstrateSpecific> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.SubstrateSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getSubstrateMultisigTransactionsList(), item -> {
				
			// Validate substrate_multisig_transactions
			if (true) index.validatorFor(item).assertValid(item);
			});
	// no validation rules for CallType

	
	}
}
/**
	 * Validates {@code MonacoinSpecific} protobuf objects.
	 */
	public static class MonacoinSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.MonacoinSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.MonacoinSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxInputsList(), item -> {
				
			// Validate tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxOutputsList(), item -> {
				
			// Validate tx_outputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code NemSpecific} protobuf objects.
	 */
	public static class NemSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.NemSpecific> {
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.NemSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Message

	// no validation rules for TxType

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getNemMultisigTransactionsList(), item -> {
				
			// Validate nem_multisig_transactions
			if (true) index.validatorFor(item).assertValid(item);
			});
	// no validation rules for Expiration

	// no validation rules for Timestamp

	
	}
}
/**
	 * Validates {@code IOSTSpecific} protobuf objects.
	 */
	public static class IOSTSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.IOSTSpecific> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.IOSTSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Memo

	// no validation rules for Timestamp

	// no validation rules for Expiration

	// no validation rules for Type

	
	}
}
/**
	 * Validates {@code PolygonSpecific} protobuf objects.
	 */
	public static class PolygonSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.PolygonSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.PolygonSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	
	}
}
/**
	 * Validates {@code KlaytnSpecific} protobuf objects.
	 */
	public static class KlaytnSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.KlaytnSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.KlaytnSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	
	}
}
/**
	 * Validates {@code SymbolSpecific} protobuf objects.
	 */
	public static class SymbolSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.SymbolSpecific> {
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.SymbolSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Message

	// no validation rules for TxType

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getSymbolMultisigTransactionsList(), item -> {
				
			// Validate symbol_multisig_transactions
			if (true) index.validatorFor(item).assertValid(item);
			});
	// no validation rules for Expiration

	// no validation rules for Timestamp

	
	}
}
/**
	 * Validates {@code AvalancheSpecific} protobuf objects.
	 */
	public static class AvalancheSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.AvalancheSpecific> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.AvalancheSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	
			// Validate atomic_tx
			if (proto.hasAtomicTx()) index.validatorFor(proto.getAtomicTx()).assertValid(proto.getAtomicTx());
	
	}
}
/**
	 * Validates {@code OasysSpecific} protobuf objects.
	 */
	public static class OasysSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.OasysSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.OasysSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	
	}
}
/**
	 * Validates {@code XdcSpecific} protobuf objects.
	 */
	public static class XdcSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.XdcSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.XdcSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	
	}
}
/**
	 * Validates {@code CosmosSpecific} protobuf objects.
	 */
	public static class CosmosSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CosmosSpecific> {
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CosmosSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	// no validation rules for Type

	// no validation rules for Memo

	// no validation rules for GasAdjustment

	
	}
}
/**
	 * Validates {@code EthereumClassicSpecific} protobuf objects.
	 */
	public static class EthereumClassicSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.EthereumClassicSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.EthereumClassicSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	
	}
}
/**
	 * Validates {@code AlgorandSpecific} protobuf objects.
	 */
	public static class AlgorandSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.AlgorandSpecific> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.AlgorandSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	// no validation rules for Memo

	// no validation rules for FirstRound

	// no validation rules for LastRound

	// no validation rules for Expiration

	// no validation rules for Timestamp

	
	}
}
/**
	 * Validates {@code HederaSpecific} protobuf objects.
	 */
	public static class HederaSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.HederaSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.HederaSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Memo

	// no validation rules for Timestamp

	// no validation rules for Expiration

	
	}
}
/**
	 * Validates {@code JapanOpenChainSpecific} protobuf objects.
	 */
	public static class JapanOpenChainSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.JapanOpenChainSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.JapanOpenChainSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	
	}
}
/**
	 * Validates {@code SolanaSpecific} protobuf objects.
	 */
	public static class SolanaSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.SolanaSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.SolanaSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Expiration

	// no validation rules for EventType

	
	}
}
/**
	 * Validates {@code AptosSpecific} protobuf objects.
	 */
	public static class AptosSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.AptosSpecific> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.AptosSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	// no validation rules for Expiration

	
	}
}
/**
	 * Validates {@code BNBSmartChainSpecific} protobuf objects.
	 */
	public static class BNBSmartChainSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.BNBSmartChainSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.BNBSmartChainSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	
	}
}
/**
	 * Validates {@code FlareSpecific} protobuf objects.
	 */
	public static class FlareSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.FlareSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.FlareSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	
	}
}
/**
	 * Validates {@code ArbitrumOneSpecific} protobuf objects.
	 */
	public static class ArbitrumOneSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.ArbitrumOneSpecific> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.ArbitrumOneSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for GasLimit

	// no validation rules for Nonce

	// no validation rules for IsNextNonce

	// no validation rules for Data

	
	}
}
/**
	 * Validates {@code AtomicTx} protobuf objects.
	 */
	public static class AtomicTxValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.AtomicTx> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.AtomicTx proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TxType

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxInputsList(), item -> {
				
			// Validate tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxOutputsList(), item -> {
				
			// Validate tx_outputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code AvalanchePlatformChainSpecific} protobuf objects.
	 */
	public static class AvalanchePlatformChainSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.AvalanchePlatformChainSpecific> {
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.AvalanchePlatformChainSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TxType

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxInputsList(), item -> {
				
			// Validate tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTxOutputsList(), item -> {
				
			// Validate tx_outputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	// no validation rules for StartTime

	// no validation rules for EndTime

	
	}
}
/**
	 * Validates {@code AvalancheTxInput} protobuf objects.
	 */
	public static class AvalancheTxInputValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.AvalancheTxInput> {
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.AvalancheTxInput proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TxId

	// no validation rules for InputIndex

	// no validation rules for InputIndexType

	// no validation rules for Value

	// no validation rules for StringValue

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getAddressIndicesList(), item -> {
				// no validation rules for AddressIndices

			});
	
	}
}
/**
	 * Validates {@code AvalancheTxOutput} protobuf objects.
	 */
	public static class AvalancheTxOutputValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.AvalancheTxOutput> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.AvalancheTxOutput proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for OutputIndex

	// no validation rules for OutputType

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for Locktime

	// no validation rules for Threshold

	// no validation rules for IsChange

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getAddressesList(), item -> {
				// no validation rules for Addresses

			});
	
	}
}
/**
	 * Validates {@code CreateTransactionSubstrateSpecific} protobuf objects.
	 */
	public static class CreateTransactionSubstrateSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CreateTransactionSubstrateSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CreateTransactionSubstrateSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TransactionId

	// no validation rules for CallType

	// no validation rules for MultisigCallType

	
	}
}
/**
	 * Validates {@code CreateTransactionWalletConnectSpecific} protobuf objects.
	 */
	public static class CreateTransactionWalletConnectSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CreateTransactionWalletConnectSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CreateTransactionWalletConnectSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for CallRequestType

	// no validation rules for CallRequestParams

	
	}
}
/**
	 * Validates {@code CreateTransactionNemSpecific} protobuf objects.
	 */
	public static class CreateTransactionNemSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CreateTransactionNemSpecific> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CreateTransactionNemSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TransactionId

	// no validation rules for TxType

	// no validation rules for Message

	// no validation rules for Timestamp

	
	}
}
/**
	 * Validates {@code CreateTransactionIOSTSpecific} protobuf objects.
	 */
	public static class CreateTransactionIOSTSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CreateTransactionIOSTSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CreateTransactionIOSTSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Memo

	// no validation rules for Timestamp

	
	}
}
/**
	 * Validates {@code CreateTransactionSymbolSpecific} protobuf objects.
	 */
	public static class CreateTransactionSymbolSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CreateTransactionSymbolSpecific> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CreateTransactionSymbolSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TransactionId

	// no validation rules for TxType

	// no validation rules for Message

	// no validation rules for Timestamp

	
	}
}
/**
	 * Validates {@code CreateTransactionEthereumSpecific} protobuf objects.
	 */
	public static class CreateTransactionEthereumSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CreateTransactionEthereumSpecific> {
		
	
	

	public void assertValid(adamant.global.v1.Model.CreateTransactionEthereumSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Data

	
	}
}
/**
	 * Validates {@code CreateTransactionCosmosSpecific} protobuf objects.
	 */
	public static class CreateTransactionCosmosSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CreateTransactionCosmosSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CreateTransactionCosmosSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Type

	// no validation rules for Memo

	
	}
}
/**
	 * Validates {@code CreateTransactionAlgorandSpecific} protobuf objects.
	 */
	public static class CreateTransactionAlgorandSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CreateTransactionAlgorandSpecific> {
		
	
	

	public void assertValid(adamant.global.v1.Model.CreateTransactionAlgorandSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Timestamp

	
	}
}
/**
	 * Validates {@code CreateTransactionHederaSpecific} protobuf objects.
	 */
	public static class CreateTransactionHederaSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CreateTransactionHederaSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CreateTransactionHederaSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Memo

	// no validation rules for Timestamp

	
	}
}
/**
	 * Validates {@code CreateTransactionSolanaSpecific} protobuf objects.
	 */
	public static class CreateTransactionSolanaSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CreateTransactionSolanaSpecific> {
		
	
	

	public void assertValid(adamant.global.v1.Model.CreateTransactionSolanaSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for EventType

	
	}
}
/**
	 * Validates {@code CreateTransactionAptosSpecific} protobuf objects.
	 */
	public static class CreateTransactionAptosSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CreateTransactionAptosSpecific> {
	

	public void assertValid(adamant.global.v1.Model.CreateTransactionAptosSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
	}
}
/**
	 * Validates {@code CreateTransactionAvalancheSpecific} protobuf objects.
	 */
	public static class CreateTransactionAvalancheSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CreateTransactionAvalancheSpecific> {
	

	public void assertValid(adamant.global.v1.Model.CreateTransactionAvalancheSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
	}
}
/**
	 * Validates {@code ImportTxSpecific} protobuf objects.
	 */
	public static class ImportTxSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.ImportTxSpecific> {
		
	
	

	public void assertValid(adamant.global.v1.Model.ImportTxSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TxId

	
	}
}
/**
	 * Validates {@code StakingSpecific} protobuf objects.
	 */
	public static class StakingSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.StakingSpecific> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.StakingSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for StartTime

	// no validation rules for EndTime

	
	}
}
/**
	 * Validates {@code SelectedUTXO} protobuf objects.
	 */
	public static class SelectedUTXOValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.SelectedUTXO> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.SelectedUTXO proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TxId

	// no validation rules for Vout

	
	}
}
/**
	 * Validates {@code SubstrateMultisigTransaction} protobuf objects.
	 */
	public static class SubstrateMultisigTransactionValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.SubstrateMultisigTransaction> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.SubstrateMultisigTransaction proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for SubstrateMultisigTransactionId

	// no validation rules for AccountId

	// no validation rules for TxId

	// no validation rules for ExtrinsicId

	// no validation rules for JpyRate

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for Nonce

	// no validation rules for MultisigCallType

	// no validation rules for State

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code NemMultisigTransaction} protobuf objects.
	 */
	public static class NemMultisigTransactionValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.NemMultisigTransaction> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.NemMultisigTransaction proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for NemMultisigTransactionId

	// no validation rules for AccountId

	// no validation rules for TxType

	// no validation rules for Data

	// no validation rules for Signature

	// no validation rules for State

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code SymbolMultisigTransaction} protobuf objects.
	 */
	public static class SymbolMultisigTransactionValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.SymbolMultisigTransaction> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.SymbolMultisigTransaction proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for SymbolMultisigTransactionId

	// no validation rules for AccountId

	// no validation rules for TxType

	// no validation rules for Data

	// no validation rules for Signature

	// no validation rules for State

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code SignInfo} protobuf objects.
	 */
	public static class SignInfoValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.SignInfo> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.SignInfo proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for TransactionId

	// no validation rules for KeyId

	// no validation rules for HdAccount

	// no validation rules for Coin

	// no validation rules for TxId

	// no validation rules for SignIndex

	// no validation rules for SignMessage

	// no validation rules for HdChange

	// no validation rules for HdIndex

	// no validation rules for Network

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getSignTxInputsList(), item -> {
				
			// Validate sign_tx_inputs
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code SignTxInput} protobuf objects.
	 */
	public static class SignTxInputValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.SignTxInput> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.SignTxInput proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TxInputIndex

	// no validation rules for SignMessage

	// no validation rules for HdChange

	// no validation rules for HdIndex

	
	}
}
/**
	 * Validates {@code Transfer} protobuf objects.
	 */
	public static class TransferValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Transfer> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Transfer proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for TransferId

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for TxId

	// no validation rules for TransferType

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for JpyRate

	// no validation rules for PartnerWalletId

	// no validation rules for PartnerAddress

	// no validation rules for DestinationTag

	// no validation rules for MemoId

	// no validation rules for Message

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for From

	// no validation rules for To

	// no validation rules for State

	// no validation rules for Result

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
			// Validate cosmos_specific
			if (proto.hasCosmosSpecific()) index.validatorFor(proto.getCosmosSpecific()).assertValid(proto.getCosmosSpecific());
	// no validation rules for StakingEventType

	// no validation rules for Method

	
	}
}
/**
	 * Validates {@code TransferCosmosSpecific} protobuf objects.
	 */
	public static class TransferCosmosSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TransferCosmosSpecific> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TransferCosmosSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Type

	// no validation rules for DelegateAmount

	// no validation rules for RewardAmount

	
	}
}
/**
	 * Validates {@code UncheckedTransfer} protobuf objects.
	 */
	public static class UncheckedTransferValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.UncheckedTransfer> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.UncheckedTransfer proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for TransferId

	// no validation rules for Coin

	// no validation rules for TxId

	// no validation rules for TransferType

	// no validation rules for State

	// no validation rules for Result

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for JpyRate

	// no validation rules for PartnerWalletId

	// no validation rules for PartnerAddress

	// no validation rules for DestinationTag

	// no validation rules for MemoId

	// no validation rules for Message

	// no validation rules for Fee

	// no validation rules for StringFee

	// no validation rules for From

	// no validation rules for To

	// no validation rules for HasChecked

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code EventTriggeredMessage} protobuf objects.
	 */
	public static class EventTriggeredMessageValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.EventTriggeredMessage> {
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.EventTriggeredMessage proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for EventTriggeredMessageId

	// no validation rules for EventTriggeredMessageType

	// no validation rules for OwnerId

	// no validation rules for Destination

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code Rate} protobuf objects.
	 */
	public static class RateValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Rate> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Rate proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Coin

	// no validation rules for Jpy

	
	}
}
/**
	 * Validates {@code RateSnapshot} protobuf objects.
	 */
	public static class RateSnapshotValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.RateSnapshot> {
		
	
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.RateSnapshot proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for RateSnapshotId

	
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getRatesMap().keySet(), key -> {
				// no validation rules for Rates

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getRatesMap().values(), value -> {
				
			// Validate rates
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}
/**
	 * Validates {@code Deactivatability} protobuf objects.
	 */
	public static class DeactivatabilityValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Deactivatability> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Deactivatability proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for AccountId

	// no validation rules for Deactivatable

	
	}
}
/**
	 * Validates {@code LabeledAddress} protobuf objects.
	 */
	public static class LabeledAddressValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.LabeledAddress> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.LabeledAddress proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for LabeledAddressId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Address

	
			// Validate proposal
			if (proto.hasProposal()) index.validatorFor(proto.getProposal()).assertValid(proto.getProposal());
	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	// no validation rules for Network

	// no validation rules for Message

	
	}
}
/**
	 * Validates {@code LabeledAddressProposal} protobuf objects.
	 */
	public static class LabeledAddressProposalValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.LabeledAddressProposal> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.LabeledAddressProposal proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	// no validation rules for ProposedAddress

	// no validation rules for AddressIsReviewed

	// no validation rules for ProposedMessage

	
	}
}
/**
	 * Validates {@code Whitelist} protobuf objects.
	 */
	public static class WhitelistValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Whitelist> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Whitelist proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WhitelistId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Network

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getAddressesList(), item -> {
				
			// Validate addresses
			if (true) index.validatorFor(item).assertValid(item);
			});
	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code TransferLimit} protobuf objects.
	 */
	public static class TransferLimitValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TransferLimit> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TransferLimit proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for TransferLimitId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for HourlyLimit

	// no validation rules for DailyLimit

	// no validation rules for OneTimeLimit

	
			// Validate proposal
			if (proto.hasProposal()) index.validatorFor(proto.getProposal()).assertValid(proto.getProposal());
	// no validation rules for IsReviewed

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code TransferLimitProposal} protobuf objects.
	 */
	public static class TransferLimitProposalValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TransferLimitProposal> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TransferLimitProposal proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	// no validation rules for ProposedHourlyLimit

	// no validation rules for ProposedDailyLimit

	// no validation rules for ProposedOneTimeLimit

	// no validation rules for IsReviewed

	
	}
}
/**
	 * Validates {@code Policy} protobuf objects.
	 */
	public static class PolicyValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Policy> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Policy proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for PolicyId

	// no validation rules for PolicyType

	// no validation rules for Name

	// no validation rules for IsBasePolicy

	// no validation rules for Coin

	// no validation rules for Network

	
			// Validate whitelist
			if (proto.hasWhitelist()) index.validatorFor(proto.getWhitelist()).assertValid(proto.getWhitelist());
	
			// Validate transfer_limit
			if (proto.hasTransferLimit()) index.validatorFor(proto.getTransferLimit()).assertValid(proto.getTransferLimit());
	
			// Validate proposal
			if (proto.hasProposal()) index.validatorFor(proto.getProposal()).assertValid(proto.getProposal());
	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code PolicyProposal} protobuf objects.
	 */
	public static class PolicyProposalValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.PolicyProposal> {
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.PolicyProposal proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for RequesterAccountId

	// no validation rules for RequesterName

	// no validation rules for ApproverAccountId

	// no validation rules for ApproverName

	
			// Validate proposed_whitelist
			if (proto.hasProposedWhitelist()) index.validatorFor(proto.getProposedWhitelist()).assertValid(proto.getProposedWhitelist());
	// no validation rules for IsReviewed

	
	}
}
/**
	 * Validates {@code TotalBalanceByCoin} protobuf objects.
	 */
	public static class TotalBalanceByCoinValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TotalBalanceByCoin> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TotalBalanceByCoin proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for ColdStringBalance

	// no validation rules for HotStringBalance

	
	}
}
/**
	 * Validates {@code TotalBalance} protobuf objects.
	 */
	public static class TotalBalanceValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TotalBalance> {
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.TotalBalance proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.MapValidation.noSparse(".adamant.global.v1.TotalBalance.total_balances", proto.getTotalBalancesMap());
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTotalBalancesMap().keySet(), key -> {
				// no validation rules for TotalBalances

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTotalBalancesMap().values(), value -> {
				
			// Validate total_balances
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}
/**
	 * Validates {@code BalanceSnapshot} protobuf objects.
	 */
	public static class BalanceSnapshotValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.BalanceSnapshot> {
		
	
		
		
		
	
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.BalanceSnapshot proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			io.envoyproxy.pgv.MapValidation.noSparse(".adamant.global.v1.BalanceSnapshot.total_balances", proto.getTotalBalancesMap());
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTotalBalancesMap().keySet(), key -> {
				// no validation rules for TotalBalances

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTotalBalancesMap().values(), value -> {
				
			// Validate total_balances
			if (true) index.validatorFor(value).assertValid(value);
			});
	
			io.envoyproxy.pgv.MapValidation.noSparse(".adamant.global.v1.BalanceSnapshot.rates", proto.getRatesMap());
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getRatesMap().keySet(), key -> {
				// no validation rules for Rates

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getRatesMap().values(), value -> {
				
			// Validate rates
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}
/**
	 * Validates {@code WalletBalanceSnapshotMap} protobuf objects.
	 */
	public static class WalletBalanceSnapshotMapValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletBalanceSnapshotMap> {
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletBalanceSnapshotMap proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.MapValidation.noSparse(".adamant.global.v1.WalletBalanceSnapshotMap.wallet_balance_snapshot_map", proto.getWalletBalanceSnapshotMapMap());
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getWalletBalanceSnapshotMapMap().keySet(), key -> {
				// no validation rules for WalletBalanceSnapshotMap

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getWalletBalanceSnapshotMapMap().values(), value -> {
				
			// Validate wallet_balance_snapshot_map
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}
/**
	 * Validates {@code ListWalletBalanceSnapshots} protobuf objects.
	 */
	public static class ListWalletBalanceSnapshotsValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.ListWalletBalanceSnapshots> {
		
	
	

	public void assertValid(adamant.global.v1.Model.ListWalletBalanceSnapshots proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getWalletBalanceSnapshotsList(), item -> {
				
			// Validate wallet_balance_snapshots
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code WalletBalanceSnapshot} protobuf objects.
	 */
	public static class WalletBalanceSnapshotValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletBalanceSnapshot> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletBalanceSnapshot proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	// no validation rules for StringBalance

	// no validation rules for Jpy

	
	}
}
/**
	 * Validates {@code TransferVolumeSnapshots} protobuf objects.
	 */
	public static class TransferVolumeSnapshotsValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TransferVolumeSnapshots> {
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.TransferVolumeSnapshots proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.MapValidation.noSparse(".adamant.global.v1.TransferVolumeSnapshots.transfer_volume_snapshot_by_transfer_type", proto.getTransferVolumeSnapshotByTransferTypeMap());
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTransferVolumeSnapshotByTransferTypeMap().keySet(), key -> {
				// no validation rules for TransferVolumeSnapshotByTransferType

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTransferVolumeSnapshotByTransferTypeMap().values(), value -> {
				
			// Validate transfer_volume_snapshot_by_transfer_type
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}
/**
	 * Validates {@code ListTransferVolumeSnapshots} protobuf objects.
	 */
	public static class ListTransferVolumeSnapshotsValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.ListTransferVolumeSnapshots> {
		
	
	

	public void assertValid(adamant.global.v1.Model.ListTransferVolumeSnapshots proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getTransferVolumeSnapshotsList(), item -> {
				
			// Validate transfer_volume_snapshots
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code TransferVolumeSnapshot} protobuf objects.
	 */
	public static class TransferVolumeSnapshotValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TransferVolumeSnapshot> {
		
	
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.TransferVolumeSnapshot proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			// Validate target_time
			if (proto.hasTargetTime()) index.validatorFor(proto.getTargetTime()).assertValid(proto.getTargetTime());
	
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTransferVolumeByCoinMap().keySet(), key -> {
				// no validation rules for TransferVolumeByCoin

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getTransferVolumeByCoinMap().values(), value -> {
				
			// Validate transfer_volume_by_coin
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}
/**
	 * Validates {@code TransferVolume} protobuf objects.
	 */
	public static class TransferVolumeValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.TransferVolume> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.TransferVolume proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for HotStringVolume

	// no validation rules for ColdStringVolume

	// no validation rules for HotStringJpyVolume

	// no validation rules for ColdStringJpyVolume

	// no validation rules for HotNumber

	// no validation rules for ColdNumber

	// no validation rules for TransferType

	
	}
}
/**
	 * Validates {@code WalletTransferVolumeSnapshots} protobuf objects.
	 */
	public static class WalletTransferVolumeSnapshotsValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletTransferVolumeSnapshots> {
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletTransferVolumeSnapshots proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.MapValidation.noSparse(".adamant.global.v1.WalletTransferVolumeSnapshots.wallet_transfer_volume_snapshot_by_wallet_id", proto.getWalletTransferVolumeSnapshotByWalletIdMap());
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getWalletTransferVolumeSnapshotByWalletIdMap().keySet(), key -> {
				// no validation rules for WalletTransferVolumeSnapshotByWalletId

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getWalletTransferVolumeSnapshotByWalletIdMap().values(), value -> {
				
			// Validate wallet_transfer_volume_snapshot_by_wallet_id
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}
/**
	 * Validates {@code ListWalletTransferVolumeSnapshots} protobuf objects.
	 */
	public static class ListWalletTransferVolumeSnapshotsValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.ListWalletTransferVolumeSnapshots> {
		
	
	

	public void assertValid(adamant.global.v1.Model.ListWalletTransferVolumeSnapshots proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getWalletTransferVolumeSnapshotsList(), item -> {
				
			// Validate wallet_transfer_volume_snapshots
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code WalletTransferVolumeSnapshot} protobuf objects.
	 */
	public static class WalletTransferVolumeSnapshotValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletTransferVolumeSnapshot> {
		
	
		
		
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletTransferVolumeSnapshot proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			// Validate target_time
			if (proto.hasTargetTime()) index.validatorFor(proto.getTargetTime()).assertValid(proto.getTargetTime());
	
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getWalletTransferVolumeByTransferTypeMap().keySet(), key -> {
				// no validation rules for WalletTransferVolumeByTransferType

			});
			io.envoyproxy.pgv.MapValidation.validateParts(proto.getWalletTransferVolumeByTransferTypeMap().values(), value -> {
				
			// Validate wallet_transfer_volume_by_transfer_type
			if (true) index.validatorFor(value).assertValid(value);
			});
	
	}
}
/**
	 * Validates {@code WalletTransferVolume} protobuf objects.
	 */
	public static class WalletTransferVolumeValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletTransferVolume> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletTransferVolume proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for StringVolume

	// no validation rules for StringJpyVolume

	// no validation rules for Number

	// no validation rules for TransferType

	
	}
}
/**
	 * Validates {@code Confirmation} protobuf objects.
	 */
	public static class ConfirmationValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.Confirmation> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.Confirmation proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Coin

	// no validation rules for Confirmation

	
	}
}
/**
	 * Validates {@code WalletFlushSetting} protobuf objects.
	 */
	public static class WalletFlushSettingValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletFlushSetting> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletFlushSetting proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for OwnerId

	// no validation rules for Coin

	// no validation rules for Network

	// no validation rules for DestinationWalletId

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	// no validation rules for FlushThreshold

	
	}
}
/**
	 * Validates {@code CompensationFee} protobuf objects.
	 */
	public static class CompensationFeeValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CompensationFee> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CompensationFee proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for StringValue

	// no validation rules for IsSpent

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
	}
}
/**
	 * Validates {@code WalletGroup} protobuf objects.
	 */
	public static class WalletGroupValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.WalletGroup> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.WalletGroup proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletGroupId

	// no validation rules for Name

	// no validation rules for Coin

	// no validation rules for Network

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getWalletsList(), item -> {
				
			// Validate wallets
			if (true) index.validatorFor(item).assertValid(item);
			});
	// no validation rules for WatchOnly

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code RequestTxOutput} protobuf objects.
	 */
	public static class RequestTxOutputValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.RequestTxOutput> {
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.RequestTxOutput proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.StringValidation.minLength(".adamant.global.v1.RequestTxOutput.address", proto.getAddress(), 3);
	
			io.envoyproxy.pgv.StringValidation.minLength(".adamant.global.v1.RequestTxOutput.string_value", proto.getStringValue(), 1);
	
	}
}
/**
	 * Validates {@code RequestSignedInfo} protobuf objects.
	 */
	public static class RequestSignedInfoValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.RequestSignedInfo> {
		
	
	

	public void assertValid(adamant.global.v1.Model.RequestSignedInfo proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.RepeatedValidation.minItems(".adamant.global.v1.RequestSignedInfo.signatures", proto.getSignaturesList(), 1);
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getSignaturesList(), item -> {
				
			// Validate signatures
			if (true) index.validatorFor(item).assertValid(item);
			});
	
	}
}
/**
	 * Validates {@code RequestSignature} protobuf objects.
	 */
	public static class RequestSignatureValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.RequestSignature> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.RequestSignature proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for SignIndex

	
			io.envoyproxy.pgv.StringValidation.minLength(".adamant.global.v1.RequestSignature.signature", proto.getSignature(), 1);
	// no validation rules for HdIndex

	
	}
}
/**
	 * Validates {@code RequestTransferLimitEntry} protobuf objects.
	 */
	public static class RequestTransferLimitEntryValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.RequestTransferLimitEntry> {
		
		private final adamant.global.v1.Enum.TransferLimitType[] TRANSFER_LIMIT_TYPE__NOT_IN = new adamant.global.v1.Enum.TransferLimitType[]{
			adamant.global.v1.Enum.TransferLimitType.forNumber(0),
		};
	
		
		private final Long TRANSFER_LIMIT_VALUE__GTE = 0L;
	
	

	public void assertValid(adamant.global.v1.Model.RequestTransferLimitEntry proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.EnumValidation.definedOnly(".adamant.global.v1.RequestTransferLimitEntry.transfer_limit_type", proto.getTransferLimitType());
			io.envoyproxy.pgv.CollectiveValidation.notIn(".adamant.global.v1.RequestTransferLimitEntry.transfer_limit_type", proto.getTransferLimitType(), TRANSFER_LIMIT_TYPE__NOT_IN);
	
			io.envoyproxy.pgv.ComparativeValidation.greaterThanOrEqual(".adamant.global.v1.RequestTransferLimitEntry.transfer_limit_value", proto.getTransferLimitValue(), TRANSFER_LIMIT_VALUE__GTE, java.util.Comparator.naturalOrder());
	
	}
}
/**
	 * Validates {@code RequestRate} protobuf objects.
	 */
	public static class RequestRateValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.RequestRate> {
		
		private final gincoinc.global.v1.Enum.Coin[] COIN__NOT_IN = new gincoinc.global.v1.Enum.Coin[]{
			gincoinc.global.v1.Enum.Coin.forNumber(0),
		};
	
		
		private final Double JPY__GTE = 0D;
	
	

	public void assertValid(adamant.global.v1.Model.RequestRate proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	
			io.envoyproxy.pgv.EnumValidation.definedOnly(".adamant.global.v1.RequestRate.coin", proto.getCoin());
			io.envoyproxy.pgv.CollectiveValidation.notIn(".adamant.global.v1.RequestRate.coin", proto.getCoin(), COIN__NOT_IN);
	
			io.envoyproxy.pgv.ComparativeValidation.greaterThanOrEqual(".adamant.global.v1.RequestRate.jpy", proto.getJpy(), JPY__GTE, java.util.Comparator.naturalOrder());
	
	}
}
/**
	 * Validates {@code SubstrateChildAddress} protobuf objects.
	 */
	public static class SubstrateChildAddressValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.SubstrateChildAddress> {
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.SubstrateChildAddress proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for AccountId

	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	
	}
}
/**
	 * Validates {@code SymbolChildAddress} protobuf objects.
	 */
	public static class SymbolChildAddressValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.SymbolChildAddress> {
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.SymbolChildAddress proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for AccountId

	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	
	}
}
/**
	 * Validates {@code IOSTChildAccount} protobuf objects.
	 */
	public static class IOSTChildAccountValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.IOSTChildAccount> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.IOSTChildAccount proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for WalletId

	// no validation rules for AccountId

	// no validation rules for AccountName

	
	}
}
/**
	 * Validates {@code IOSTCallerAccount} protobuf objects.
	 */
	public static class IOSTCallerAccountValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.IOSTCallerAccount> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.IOSTCallerAccount proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for AccountName

	// no validation rules for Balance

	// no validation rules for StringBalance

	
	}
}
/**
	 * Validates {@code CallerAddress} protobuf objects.
	 */
	public static class CallerAddressValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CallerAddress> {
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CallerAddress proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for Coin

	// no validation rules for Network

	
	}
}
/**
	 * Validates {@code FeeDepositAddress} protobuf objects.
	 */
	public static class FeeDepositAddressValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.FeeDepositAddress> {
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.FeeDepositAddress proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for Address

	// no validation rules for Balance

	// no validation rules for StringBalance

	// no validation rules for Coin

	// no validation rules for Network

	
	}
}
/**
	 * Validates {@code CosmosDelegation} protobuf objects.
	 */
	public static class CosmosDelegationValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.CosmosDelegation> {
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.CosmosDelegation proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for ValidatorAddress

	// no validation rules for DelegateAmount

	// no validation rules for RewardAmount

	
	}
}
/**
	 * Validates {@code StakingHistory} protobuf objects.
	 */
	public static class StakingHistoryValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.StakingHistory> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.StakingHistory proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for StakingHistoryId

	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Coin

	// no validation rules for ValidatorId

	// no validation rules for TxId

	// no validation rules for TxIndex

	// no validation rules for BlockHash

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for EventType

	// no validation rules for EventId

	
			// Validate ethereum_specific
			if (proto.hasEthereumSpecific()) index.validatorFor(proto.getEthereumSpecific()).assertValid(proto.getEthereumSpecific());
	
			// Validate avalanche_specific
			if (proto.hasAvalancheSpecific()) index.validatorFor(proto.getAvalancheSpecific()).assertValid(proto.getAvalancheSpecific());
	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
/**
	 * Validates {@code StakingHistoryEthereumSpecific} protobuf objects.
	 */
	public static class StakingHistoryEthereumSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.StakingHistoryEthereumSpecific> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.StakingHistoryEthereumSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for EventId

	// no validation rules for Address

	// no validation rules for WithdrawalIndex

	// no validation rules for ValidatorIndex

	// no validation rules for BlockNumber

	
			// Validate block_time
			if (proto.hasBlockTime()) index.validatorFor(proto.getBlockTime()).assertValid(proto.getBlockTime());
	// no validation rules for HistoryType

	
	}
}
/**
	 * Validates {@code StakingHistoryAvalancheSpecific} protobuf objects.
	 */
	public static class StakingHistoryAvalancheSpecificValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.StakingHistoryAvalancheSpecific> {
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.StakingHistoryAvalancheSpecific proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for StartTime

	// no validation rules for EndTime

	// no validation rules for RewardsOwnerThreshold

	
			io.envoyproxy.pgv.RepeatedValidation.forEach(proto.getRewardsOwnerAddressesList(), item -> {
				// no validation rules for RewardsOwnerAddresses

			});
	
	}
}
/**
	 * Validates {@code StakingValidator} protobuf objects.
	 */
	public static class StakingValidatorValidator implements io.envoyproxy.pgv.ValidatorImpl<adamant.global.v1.Model.StakingValidator> {
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
		
	
	

	public void assertValid(adamant.global.v1.Model.StakingValidator proto, io.envoyproxy.pgv.ValidatorIndex index) throws io.envoyproxy.pgv.ValidationException {
	// no validation rules for StakingValidatorId

	// no validation rules for OwnerId

	// no validation rules for WalletId

	// no validation rules for Coin

	// no validation rules for ValidatorId

	// no validation rules for RecipientWalletId

	// no validation rules for Status

	// no validation rules for Value

	// no validation rules for StringValue

	// no validation rules for ExpirationTime

	
			// Validate create_time
			if (proto.hasCreateTime()) index.validatorFor(proto.getCreateTime()).assertValid(proto.getCreateTime());
	
			// Validate update_time
			if (proto.hasUpdateTime()) index.validatorFor(proto.getUpdateTime()).assertValid(proto.getUpdateTime());
	
	}
}
}

